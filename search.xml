<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty挖掘机（十二）ChannelHandler底层原理</title>
      <link href="/2021/06/02/netty-wa-jue-ji-shi-er-channelhandler-di-ceng-yuan-li/"/>
      <url>/2021/06/02/netty-wa-jue-ji-shi-er-channelhandler-di-ceng-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>上一篇主要了解了<code>ChannelHandler</code>相关的接口和接口方法，这一篇则着重讲解涉及到的工作原理。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>以下所讲内容，代码标准基于《Netty挖掘机（四）结合spring boot搭建netty脚手架》。</p><p>当产生一次请求时，触发读就绪事件（channelRead），I/O线程<code>NioEventLoop</code>开始调用<code>ChannelPipeline</code>的<code>fireChannelRead()</code>方法，将消息传递给数据管道。如本文第一幅图，其中消息会依次经过<code>HeadContext</code>、添加的多个<code>ChannelHandler</code>、<code>TailContext</code>，进行消息拦截和处理，这期间可以随时中断消息的传递。之后开始反方向地通过<code>write()</code>发送消息，将消息写入到消息缓冲区，调用<code>flush()</code>冲刷到远端节点。</p><p>我这里把它分为五个过程，一个是<strong>创建通道，注册通道，激活通道，执行职责链的读取消息事件、执行职责链的读取完成事件</strong>。</p><h3 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a>创建通道</h3><p>在之前讲过的《Netty挖掘机 EventLoop底层原理》部分，我们了解到<code>NioEventLoop</code>作为I/O线程会持续监听事件，当有事件进来时会将其添加到任务队列，并异步执行。故当触发读就绪事件时，<code>NioEventLoop</code>会添加异步任务，注册<code>Channel</code>后执行管道初始化操作。</p><p>对应的时序图如下<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200923182049817_869395745.png" alt="ChannelHandler工作原理1"></p><h4 id="Selector轮询检测，发现有需要处理的I-O事件"><a href="#Selector轮询检测，发现有需要处理的I-O事件" class="headerlink" title="Selector轮询检测，发现有需要处理的I/O事件"></a>Selector轮询检测，发现有需要处理的I/O事件</h4><p>代码位于<code>NioEventLoop#processSelectedKey(SelectionKey, AbstractNioChannel)</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来来到<code>AbstractNioMessageChannel.NioMessageUnsafe#read</code>，看一下read方法（忽略部分代码）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 读消息，将消息放到集合readBuf 中</span>    <span class="token keyword">int</span> localRead <span class="token operator">=</span> <span class="token function">doReadMessages</span><span class="token punctuation">(</span>readBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localRead <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localRead <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        closed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> readBuf<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行fireChannelRead传递消息</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>readBuf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    readBuf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="创建通道NioSocketChannel"><a href="#创建通道NioSocketChannel" class="headerlink" title="创建通道NioSocketChannel"></a>创建通道<code>NioSocketChannel</code></h4><p>当触发读就绪时，调用<code>NioUnsafe#read</code>开始处理事件，其中调用<code>doReadMessages</code>时，会创建一个<code>NioSocketChannel</code>实例</p><pre class=" language-java"><code class="language-java">SocketChannel ch <span class="token operator">=</span> SocketUtils<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    buf<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NioSocketChannel</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>内部再初始化一个数据管道<code>DefaultChannelPipeline</code>，用于后续消息传递。前面我们提到在<code>ChannelPipeline</code>内部持有一组I/O处理器<code>ChannelHandler</code>链表，在初始化数据管道时，会先在链表头尾分别创建一个头节点处理器<code>HeadContext</code>和尾节点处理器<code>TailContext</code>。最终放到集合对象<code>readBuf</code>中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">DefaultChannelPipeline</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>channel <span class="token operator">=</span> ObjectUtil<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token string">"channel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    succeededFuture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SucceededChannelFuture</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    voidPromise <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">VoidChannelPromise</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TailContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeadContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>    tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="传递通道对象readBuf"><a href="#传递通道对象readBuf" class="headerlink" title="传递通道对象readBuf"></a>传递通道对象<code>readBuf</code></h4><p>入口代码位于<code>DefaultChannelPipeline#fireChannelRead</code>。</p><p>我们知道，Netty在启动期间，会创建一个<code>NioServerSocketChannel</code>实例，内部也初始化了一个数据管道<code>DefaultChannelPipeline</code>，不同于上面的<code>NioSocketChannel</code>，其中的I/O处理器链表，还会穿插一个<code>ServerBootstrapAcceptor</code>，代码位于<code>ServerBootstrap#init</code></p><pre class=" language-java"><code class="language-java">ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServerBootstrapAcceptor</span><span class="token punctuation">(</span>                ch<span class="token punctuation">,</span> currentChildGroup<span class="token punctuation">,</span> currentChildHandler<span class="token punctuation">,</span> currentChildOptions<span class="token punctuation">,</span> currentChildAttrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>那么它的作用是什么？回顾下前面的启动代码，调用了<code>ServerBootstrap#childHandler(io.netty.channel.ChannelHandler)</code>，用于添加一个处理器<code>ChannelInitializer</code>，处理<code>NioSocketChannel</code>的请求。</p><pre class=" language-java"><code class="language-java">ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap<span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpChannelInitializer</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ......</span>bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>故在传递通道对象时(<code>fireChannelRead</code>)，会依次调用<code>NioServerSocketChannel</code>中数据管道所持有的链表，调用顺序为<code>HeadContext</code>、<code>ServerBootstrapAcceptor</code>、<code>TailContext</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeChannelRead</span><span class="token punctuation">(</span><span class="token keyword">final</span> AbstractChannelHandlerContext next<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Object m <span class="token operator">=</span> next<span class="token punctuation">.</span>pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>ObjectUtil<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    EventExecutor executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前线程是I/O线程，则执行invokeChannelRead</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        next<span class="token punctuation">.</span><span class="token function">invokeChannelRead</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 否则异步执行</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                next<span class="token punctuation">.</span><span class="token function">invokeChannelRead</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里主要看<code>ServerBootstrapAcceptor#channelRead</code>，内部逻辑是将启动代码中的<code>childHandler</code>，添加到<code>NioSocketChannel</code>，即将<code>HttpChannelInitializer</code>插入到链表中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Channel child <span class="token operator">=</span> <span class="token punctuation">(</span>Channel<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>    child<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>childHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setChannelOptions</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> childOptions<span class="token punctuation">,</span> logger<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setAttributes</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> childAttrs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="注册通道任务"><a href="#注册通道任务" class="headerlink" title="注册通道任务"></a>注册通道任务</h4><p>接着将<code>NioSocketChannel</code>注册到<code>EventLoop</code>中，主要是利用执行器异步执行注册方法<code>AbstractChannel.AbstractUnsafe#register0</code>，并添加了监听器，监听异步操作完成的回调。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    childGroup<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>ChannelFuture future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">forceClose</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">forceClose</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此时链表的顺序为<code>HeadContext</code>、<code>ChannelInitializer</code>、<code>TailContext</code></p><p>最终将具体的task推到任务队列中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addTask</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">offerTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">reject</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="注册通道"><a href="#注册通道" class="headerlink" title="注册通道"></a>注册通道</h3><p>上一步将注册方法放置任务队列中执行，执行入口在之前讲过的《Netty挖掘机 EventLoop底层原理》部分也已经谈到了，<code>NioEventLoop#run</code>会不断轮询任务队列任务。</p><p>看下注册代码，总共有3个步骤</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">register0</span><span class="token punctuation">(</span>ChannelPromise promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 检查是否需要添加处理器</span>        pipeline<span class="token punctuation">.</span><span class="token function">invokeHandlerAddedIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">safeSetSuccess</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若通道注册完成，则pipeline会调用fireChannelRegistered 触发注册完成事件</span>        pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRegistration<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 触发通道激活事件</span>                pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">beginRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">closeForcibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        closeFuture<span class="token punctuation">.</span><span class="token function">setClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">safeSetFailure</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再看下时序图，包含了3个步骤的具体流程，很清晰。很明显这一块大多都是<code>ChannelPipeline</code>和<code>ChannelHandlerContext</code>在交互。<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200923182520424_33749741.png" alt="ChannelHandler工作原理2"></p><h4 id="检查是否需要添加I-O处理器"><a href="#检查是否需要添加I-O处理器" class="headerlink" title="检查是否需要添加I/O处理器"></a>检查是否需要添加I/O处理器</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">invokeHandlerAddedIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 确认是否在I/O线程里，是否是第一次注册</span>    <span class="token keyword">assert</span> channel<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRegistration<span class="token punctuation">)</span> <span class="token punctuation">{</span>        firstRegistration <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">callHandlerAddedForAllHandlers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="加锁控制注册过程"><a href="#加锁控制注册过程" class="headerlink" title="加锁控制注册过程"></a>加锁控制注册过程</h5><ul><li><p>针对<code>ChannelPipeline</code>实例上锁，此时将<code>registered</code>置为true，目的在于标识<code>pipeline</code>关联的<code>Channel</code>已经被注册，一旦注册即不再会有新的处理器加入，后续操作亦会沿用此状态；</p></li><li><p>将全局变量的<code>pendingHandlerCallbackHead</code>的引用赋给局部变量<code>pendingHandlerCallbackHead</code>并置为空，目的在于便于GC及时回收；</p></li><li><p>上面的引用赋值操作在锁外部执行，目的在于避免死锁，当持有锁期间调用内层的<code>handlerAdded()</code>时，在I/O线程外部执行了<code>handlerAdded()</code>新增一个handler时，会产生死锁。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">callHandlerAddedForAllHandlers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead<span class="token punctuation">;</span>  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">assert</span> <span class="token operator">!</span>registered<span class="token punctuation">;</span>      registered <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      pendingHandlerCallbackHead <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pendingHandlerCallbackHead<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>pendingHandlerCallbackHead <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  PendingHandlerCallback task <span class="token operator">=</span> pendingHandlerCallbackHead<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      task<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      task <span class="token operator">=</span> task<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><p>了解下<code>PendingHandlerCallback</code>，作为<code>DefaultChannelPipeline</code>中的抽象静态内部类，它还是一个Runnable，内部维护了处理器上下文<code>ctx</code>和<code>next</code>节点，定义了一个抽象方法<code>execute()</code>，用于直接提交自身到I/O线程<code>EventLoop</code>中去执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PendingHandlerCallback</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AbstractChannelHandlerContext ctx<span class="token punctuation">;</span>    PendingHandlerCallback next<span class="token punctuation">;</span>    <span class="token function">PendingHandlerCallback</span><span class="token punctuation">(</span>AbstractChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以简单看下它的子类<code>PendingHandlerAddedTask</code>和<code>PendingHandlerRemovedTask</code>，分别用于添加handler和移除handler</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PendingHandlerAddedTask</span> <span class="token keyword">extends</span> <span class="token class-name">PendingHandlerCallback</span> <span class="token punctuation">{</span>    <span class="token function">PendingHandlerAddedTask</span><span class="token punctuation">(</span>AbstractChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">callHandlerAdded0</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        EventExecutor executor <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若在I/O线程中则直接调用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">callHandlerAdded0</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 否则异步调用</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RejectedExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>                            <span class="token string">"Can't invoke handlerAdded() as the EventExecutor {} rejected it, removing handler {}."</span><span class="token punctuation">,</span>                            executor<span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token function">atomicRemoveFromHandlerList</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx<span class="token punctuation">.</span><span class="token function">setRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="添加处理器，将ChannelContext状态置为ADD-COMPLETE"><a href="#添加处理器，将ChannelContext状态置为ADD-COMPLETE" class="headerlink" title="添加处理器，将ChannelContext状态置为ADD_COMPLETE"></a>添加处理器，将<code>ChannelContext</code>状态置为<code>ADD_COMPLETE</code></h5><p>调用链路来到<code>callHandlerAdded()</code>，开始管理<code>ChannelContext</code>的状态。对于handler的状态可以往上翻”什么是ChannelHandlerContext“</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">callHandlerAdded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates</span>    <span class="token comment" spellcheck="true">// any pipeline events ctx.handler() will miss them because the state will not allow it.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setAddComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handlerAdded</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在执行<code>handlerAdded()</code>之前，即添加handler到链表之前，必须先将状态置为<code>ADD_COMPLETE</code>，这里使用CAS的方式进行修改</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">setAddComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> oldState <span class="token operator">=</span> handlerState<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldState <span class="token operator">==</span> REMOVE_COMPLETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Ensure we never update when the handlerState is REMOVE_COMPLETE already.</span>        <span class="token comment" spellcheck="true">// oldState is usually ADD_PENDING but can also be REMOVE_COMPLETE when an EventExecutor is used that is not</span>        <span class="token comment" spellcheck="true">// exposing ordering guarantees.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>HANDLER_STATE_UPDATER<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> oldState<span class="token punctuation">,</span> ADD_COMPLETE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="基于添加的处理器，调用handlerAdded"><a href="#基于添加的处理器，调用handlerAdded" class="headerlink" title="基于添加的处理器，调用handlerAdded"></a>基于添加的处理器，调用<code>handlerAdded</code></h5><p>在上面提到，此时这里添加的处理器是<code>ChannelInitializer</code>，即初始化通道处理器，一般会往管道中添加多个I/O事件处理器，最常用的是解码器和编码器，还有自定义的业务处理器。</p><p>如果<code>registered</code>为true，则开始初始化通道，且当初始化处理器执行完后，需要从链表中移除该处理器，避免多次初始化！</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">initChannel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">removeState</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initMap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Guard against re-entrance.</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            ChannelPipeline pipeline <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pipeline<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pipeline<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>初始化的逻辑需要看对应的实现类，如以下是自定义的实现，添加多个I/O事件处理器，常用的解码器和编码器，还有自定义的业务处理器。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>Channel ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpFirstServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpLastServerHandler</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"添加处理器到管道..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>经过初始化操作后，此时链表的节点顺序为<code>HeadContext</code>、<code>ChannelInitializer</code>、<code>HttpRequestDecoder</code>、<code>HttpResponseEncoder</code>、<code>HttpFirstServerHandler</code>、<code>HttpLastServerHandler</code>、<code>TailContext</code>。</p><h5 id="移除处理器，将ChannelContext状态置为REMOVE-COMPLETE"><a href="#移除处理器，将ChannelContext状态置为REMOVE-COMPLETE" class="headerlink" title="移除处理器，将ChannelContext状态置为REMOVE_COMPLETE"></a>移除处理器，将<code>ChannelContext</code>状态置为<code>REMOVE_COMPLETE</code></h5><p>上面提到初始化后，需要移除处理器，内部调用了<code>DefaultChannelPipeline#callHandlerRemoved0</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">callHandlerRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Only call handlerRemoved(...) if we called handlerAdded(...) before.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>handlerState <span class="token operator">==</span> ADD_COMPLETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 调用处理器中的handlerRemoved</span>            <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handlerRemoved</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Mark the handler as removed in any case.</span>        <span class="token function">setRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setRemoved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    handlerState <span class="token operator">=</span> REMOVE_COMPLETE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>经过移除操作后，此时链表的节点顺序为<code>HeadContext</code>、<code>HttpRequestDecoder</code>、<code>HttpResponseEncoder</code>、<code>HttpFirstServerHandler</code>、<code>HttpLastServerHandler</code>、<code>TailContext</code>。</p><h4 id="注册完成（事件传播channelRegistered）"><a href="#注册完成（事件传播channelRegistered）" class="headerlink" title="注册完成（事件传播channelRegistered）"></a>注册完成（事件传播<code>channelRegistered</code>）</h4><p>上一步通道注册并初始化完成后，则开始触发注册完成事件。</p><p>这里会触发入站的注册完成事件传播，传递于<code>channelRegistered</code>。</p><ul><li>调用pipeline的<code>fireChannelRegistered</code>，开启事件传递，由于当前事件是入站事件，入站事件是往链表后继节点方向传递的，故这里首先传入的是链表的head节点，即<code>HeadContext</code>。<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> ChannelPipeline <span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  AbstractChannelHandlerContext<span class="token punctuation">.</span><span class="token function">invokeChannelRegistered</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li>传入头结点后，<code>AbstractChannelHandlerContext</code>接着调用内部的<code>invokeChannelRegistered</code>方法，把事件转发给<code>DefaultChannelPipeline.HeadContext#channelRegistered</code>。<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRegistered</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 二次确认是否要检测</span>  <span class="token function">invokeHandlerAddedIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ctx<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>看下<code>AbstractChannelHandlerContext#fireChannelRegistered</code>，其中调用的<code>findContextInbound</code>，在于查找最近的入站处理器，接着再调用<code>invokeChannelRegistered</code> 把事件传递传递到该处理器的<code>channelRegistered</code>。这个过程就是入站激活事件的传播过程。在示例代码中，这里只会传播到<code>DefaultChannelPipeline.TailContext#channelRegistered</code>。<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ChannelHandlerContext <span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">invokeChannelRegistered</span><span class="token punctuation">(</span><span class="token function">findContextInbound</span><span class="token punctuation">(</span>MASK_CHANNEL_REGISTERED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="激活通道（事件传播channelActive）"><a href="#激活通道（事件传播channelActive）" class="headerlink" title="激活通道（事件传播channelActive）"></a>激活通道（事件传播<code>channelActive</code>）</h4><p>激活的最终目的在于触发真正的读就绪操作。</p><p>上一步触发通道注册成功事件后，接下来将走激活通道的流程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRegistration<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// This channel was registered before and autoRead() is set. This means we need to begin read</span>        <span class="token comment" spellcheck="true">// again so that we process inbound data.</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/4805</span>        <span class="token function">beginRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里会触发入站的激活事件传播，传递于<code>channelActive</code>。</p><ul><li><p>先判断通道是否处于激活状态并且已连接，是否首次注册，满足则开始触发通道激活事件。此时调用pipeline的<code>fireChannelActive</code>方法，由于当前事件是入站事件，入站事件是往链表后继节点方向传递的，故这里首先传入的是链表的head节点，即<code>HeadContext</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> ChannelPipeline <span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  AbstractChannelHandlerContext<span class="token punctuation">.</span><span class="token function">invokeChannelActive</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>传入头结点后，<code>AbstractChannelHandlerContext</code>接着调用内部的<code>invokeChannelActive</code>方法，把事件转发给，<code>DefaultChannelPipeline.HeadContext#channelActive</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelActive</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ctx<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 自动读取数据</span>  <span class="token function">readIfIsAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看下<code>AbstractChannelHandlerContext#fireChannelActive</code>，其中调用的<code>findContextInbound</code>，在于往后继节点方向查找最近的入站处理器，接着再调用<code>invokeChannelActive</code> 把事件传递传递到该处理器的<code>channelActive</code>。这个过程就是入站激活事件的传播过程。在示例代码中，这里只会传播到<code>DefaultChannelPipeline.TailContext#channelActive</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ChannelHandlerContext <span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">invokeChannelActive</span><span class="token punctuation">(</span><span class="token function">findContextInbound</span><span class="token punctuation">(</span>MASK_CHANNEL_ACTIVE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="自动读取数据（事件传播）"><a href="#自动读取数据（事件传播）" class="headerlink" title="自动读取数据（事件传播）"></a>自动读取数据（事件传播）</h5><p>如果配置了通道自动读取数据，则需要调用<code>NioSocketChannel#read</code>，这一步主要是为了触发再一次的读就绪操作，开始真正的数据传输。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readIfIsAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>里面的链路相对简单，通过调用<code>DefaultChannelPipeline#read</code>，从<code>tail</code>节点开始调用<code>TailContext#read</code>。查看源码可知，read方法是在<code>ChannelOutboundInvoker</code>接口定义的，这个接口定义的是出站事件的调用方法。故在下面的代码中，我们可以看到<code>Outbound</code>的字眼。<br>调用<code>AbstractChannelHandlerContext#findContextOutbound</code>，即从<code>tail</code>节点开始，逐步往前驱节点方向遍历最近的有出站事件执行的处理器并返回，在示例代码中，这里只会传播到<code>DefaultChannelPipeline.HeadContext#read</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ChannelHandlerContext <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AbstractChannelHandlerContext next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span>MASK_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>    EventExecutor executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        next<span class="token punctuation">.</span><span class="token function">invokeRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        Tasks tasks <span class="token operator">=</span> next<span class="token punctuation">.</span>invokeTasks<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span>invokeTasks <span class="token operator">=</span> tasks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tasks</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span>invokeReadTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后调用了<code>NioSocketChannel#doBeginRead</code>，即给当前的<code>NioSocketChannel</code>注册读就绪事件。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doBeginRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="token keyword">final</span> SelectionKey selectionKey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selectionKey<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>selectionKey<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    readPending <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> interestOps <span class="token operator">=</span> selectionKey<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 与操作为0，则将其注册</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interestOps <span class="token operator">&amp;</span> readInterestOp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重新设置为感兴趣的读就绪事件</span>        selectionKey<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>interestOps <span class="token operator">|</span> readInterestOp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这一步执行完后，将再次触发读就绪事件，上次的读就绪事件来源，是为了创建和注册通道，这次的读就绪事件则是为了下一步。</p><h3 id="执行职责链的读取消息事件（入站）"><a href="#执行职责链的读取消息事件（入站）" class="headerlink" title="执行职责链的读取消息事件（入站）"></a>执行职责链的读取消息事件（入站）</h3><p>先回顾下，基于示例代码，之前我们整理得到的一次请求入站的链表顺序是<code>HeadContext</code>、<code>HttpRequestDecoder</code>、<code>HttpResponseEncoder</code>、<code>HttpFirstServerHandler</code>、<code>HttpLastServerHandler</code>、<code>TailContext</code>。</p><p>监听读就绪事件后，来到<code>AbstractNioByteChannel.NioByteUnsafe#read</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">{</span>    byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>    allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// nothing was read. release the buffer.</span>        byteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        byteBuf <span class="token operator">=</span> null<span class="token punctuation">;</span>        close <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// There is nothing left to read as we received an EOF.</span>            readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    allocHandle<span class="token punctuation">.</span><span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    byteBuf <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对应时序图如下<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200923112732087_199784311.png" alt="读取消息拦截转发"></p><h4 id="读取Bytebuf"><a href="#读取Bytebuf" class="headerlink" title="读取Bytebuf"></a>读取Bytebuf</h4><p>关于<code>Bytebuf</code>的内容下次再细讲…<br>TODO</p><h4 id="读取消息拦截转发（事件传播channelRead）"><a href="#读取消息拦截转发（事件传播channelRead）" class="headerlink" title="读取消息拦截转发（事件传播channelRead）"></a>读取消息拦截转发（事件传播<code>channelRead</code>）</h4><p>入口是调用pipeline的<code>fireChannelRead</code>，这里会触发入站的读事件传播，传递于<code>channelRead</code>。</p><ul><li><p>在<code>AbstractNioByteChannel.NioByteUnsafe#read()</code>中，将数据解析成<code>ByteBuf</code>对象后，调用pipeline的<code>fireChannelRead</code>，由于当前事件是入站事件，入站事件是往链表后继节点方向传递的，故这里首先传入的是链表的head节点，即<code>HeadContext</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> ChannelPipeline <span class="token function">fireChannelRead</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  AbstractChannelHandlerContext<span class="token punctuation">.</span><span class="token function">invokeChannelRead</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>传入头结点后，<code>AbstractChannelHandlerContext</code>接着调用内部的<code>invokeChannelActive</code>方法，把事件转发给，<code>DefaultChannelPipeline.HeadContext#channelActive</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRegistered</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>由链表可知，接下来会把消息传入<code>HttpRequestDecoder</code>，此时会调用<code>ByteToMessageDecoder#channelRead</code>。</p><ul><li>如果消息对象不是<code>ByteBuf</code>类型，则不处理，传递给下个处理器</li><li>否则将消息强转为ByteBuf类型，并且调用<code>callDecode</code>将消息拆分成消息集合<code>CodecOutputList</code>，我们知道Netty中一次完整的http请求，<code>HttpRequest</code>是请求的第一步，<code>LastHttpContent</code>标志着请求的结束，集合里就是存放着一次请求中的几个步骤。<pre class=" language-java"><code class="language-java">  CodecOutputList out <span class="token operator">=</span> CodecOutputList<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>      ByteBuf data <span class="token operator">=</span> <span class="token punctuation">(</span>ByteBuf<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>      first <span class="token operator">=</span> cumulation <span class="token operator">==</span> null<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>          cumulation <span class="token operator">=</span> data<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          cumulation <span class="token operator">=</span> cumulator<span class="token punctuation">.</span><span class="token function">cumulate</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cumulation<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">callDecode</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cumulation<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li>调用<code>fireChannelRead</code>，将会遍历集合<code>CodecOutputList</code>，逐个传递到下一个处理器<pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fireChannelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> CodecOutputList msgs<span class="token punctuation">,</span> <span class="token keyword">int</span> numElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numElements<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msgs<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li></ul></li><li><p>依此类推，经过几个处理器的拦截处理后，准备反方向地通过<code>write()</code>发送消息，将消息写入到消息缓冲区</p></li></ul><h4 id="结果发送到消息缓冲区"><a href="#结果发送到消息缓冲区" class="headerlink" title="结果发送到消息缓冲区"></a>结果发送到消息缓冲区</h4><p>上一步读取消息并在链表的处理器上做了处理后，还需要将处理结果写到缓存区</p><p>对应时序图如下<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200923104858044_1778958568.png" alt="写消息到缓冲区"></p><p>在自定义的处理器<code>HttpLastServerHandler</code>中，调用<code>ChannelOutboundInvoker#write(java.lang.Object)</code>开始发送消息，同样来到<code>AbstractChannelHandlerContext#write(java.lang.Object, boolean, io.netty.channel.ChannelPromise)</code>。由于当前事件是出站事件，出站事件是往链表前继节点方向传递的，故调用<code>findContextOutbound</code>逐个获取前驱节点处理器，并选择性调用<code>invokeWriteAndFlush</code>或者<code>invokeWrite</code>将消息发送出去</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flush<span class="token punctuation">,</span> ChannelPromise promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ObjectUtil<span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNotValidPromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// cancelled</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> AbstractChannelHandlerContext next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span>flush <span class="token operator">?</span>            <span class="token punctuation">(</span>MASK_WRITE <span class="token operator">|</span> MASK_FLUSH<span class="token punctuation">)</span> <span class="token operator">:</span> MASK_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Object m <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    EventExecutor executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span><span class="token function">invokeWriteAndFlush</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            next<span class="token punctuation">.</span><span class="token function">invokeWrite</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> AbstractWriteTask task<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>            task <span class="token operator">=</span> WriteAndFlushTask<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>            task <span class="token operator">=</span> WriteTask<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> task<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span>            <span class="token comment" spellcheck="true">// and put it back in the Recycler for re-use later.</span>            <span class="token comment" spellcheck="true">//</span>            <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/8343.</span>            task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于出站事件涉及到编码器处理，故这里针对消息的处理是在<code>HttpResponseEncoder</code>中进行，此时会调用<code>MessageToMessageEncoder#write</code>。处理过程如下</p><ul><li><p>判断当前消息<code>msg</code>是否应处理，即消息类型是否属于<code>HttpObject</code>、<code>ByteBuf</code>、<code>FileRegion</code>，并且不属于<code>HttpRequest</code></p><ul><li>满足则进行下一步<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">acceptOutboundMessage</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">acceptOutboundMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">HttpRequest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">acceptOutboundMessage</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      <span class="token keyword">return</span> msg <span class="token keyword">instanceof</span> <span class="token class-name">HttpObject</span> <span class="token operator">||</span> msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span> <span class="token operator">||</span> msg <span class="token keyword">instanceof</span> <span class="token class-name">FileRegion</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li>不满足则直接调用<code>write</code>方法将消息发送到缓冲区<pre class=" language-java"><code class="language-java">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acceptOutboundMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li></ul></li><li><p>创建<code>CodecOutputList</code>实例，调用<code>HttpObjectEncoder#encode</code>方法将消息编码并组装成一个个<code>ByteBuf</code>赋给它，后再将消息对象<code>msg</code>进行释放</p></li></ul><pre class=" language-java"><code class="language-java">CodecOutputList out <span class="token operator">=</span> null<span class="token punctuation">;</span>out <span class="token operator">=</span> CodecOutputList<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>I cast <span class="token operator">=</span> <span class="token punctuation">(</span>I<span class="token punctuation">)</span> msg<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">encode</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cast<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>cast<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    out<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EncoderException</span><span class="token punctuation">(</span>            StringUtil<span class="token punctuation">.</span><span class="token function">simpleClassName</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" must produce at least one message."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>如果<code>CodecOutputList</code>集合不为空，并且长度为1，则直接调用<code>write</code>方法将消息发送到缓冲区，否则逐个遍历发送</li></ul><p>在遍历过程中，源码提到了，检查是否可以使用voidPromise进行额外的写操作以减少GC压力。这里暂时不多讲。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> sizeMinusOne <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sizeMinusOne <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sizeMinusOne <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>promise <span class="token operator">==</span> ctx<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">writeVoidPromise</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">writePromiseCombiner</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> out<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    out<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="执行职责链的读取完成事件（出站）"><a href="#执行职责链的读取完成事件（出站）" class="headerlink" title="执行职责链的读取完成事件（出站）"></a>执行职责链的读取完成事件（出站）</h3><p>当执行了读取消息事件<code>pipeline.fireChannelRead</code>后，将要触发读取完成事件，传递于<code>channelReadComplete</code>。</p><pre class=" language-java"><code class="language-java">allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>和前面的传播类似，往链表后继节点方向逐个调用处理器的<code>channelReadComplete</code>，处理读取成功后的执行事项。在示例代码中，<code>HttpLastServerHandler</code>、<code>HttpFirstServerHandler</code>都实现了该方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中会调用<code>DefaultChannelPipeline#flush</code>，使用<code>tail</code>节点来冲刷缓冲区中所有未决的消息</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> ChannelPipeline <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    tail<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看下冲刷缓冲区的时序图<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200923131202669_381560922.png" alt="冲刷缓冲区"></p><p>这里又涉及到一次冲刷的事件传播，传播过程就不说了，这里主要看最后两步</p><ul><li><p>如果已经冲刷，或者缓冲区没有数据，则直接退出冲刷流程</p></li><li><p>如果通道<code>Channel</code>处于非激活状态，则调用<code>failFlushed</code>将所有待处理的数据标记为失败，并且退出冲刷流程</p></li><li><p>调用<code>doWrite()</code>执行冲刷流程，当出现异常时，直接调用<code>close()</code>就可使所有待冲刷的消息失败</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">flush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>inFlush0<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">final</span> ChannelOutboundBuffer outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">==</span> null <span class="token operator">||</span> outboundBuffer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  inFlush0 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NotYetConnectedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span><span class="token function">newClosedChannelException</span><span class="token punctuation">(</span>initialCloseCause<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>          inFlush0 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token function">doWrite</span><span class="token punctuation">(</span>outboundBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token keyword">instanceof</span> <span class="token class-name">IOException</span> <span class="token operator">&amp;&amp;</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAutoClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          initialCloseCause <span class="token operator">=</span> t<span class="token punctuation">;</span>          <span class="token function">close</span><span class="token punctuation">(</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">newClosedChannelException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>              initialCloseCause <span class="token operator">=</span> t<span class="token punctuation">;</span>              <span class="token function">close</span><span class="token punctuation">(</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t2<span class="token punctuation">,</span> <span class="token function">newClosedChannelException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      inFlush0 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="随处可见的EventLoop"><a href="#随处可见的EventLoop" class="headerlink" title="随处可见的EventLoop"></a>随处可见的EventLoop</h3><p>在一次请求链路中，I/O线程和业务线程无缝地在做各种切换，Selector的轮询机制，会将感兴趣的事件封装成任务放置任务队列中执行。Netty中保证了，如果非I/O线程执行的操作，会将操作逻辑放置线程池中使用，从而保证了I/O线程的可利用性。</p><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>在<code>ChannelHandlerContext</code>中带有<code>fire***</code>的方法，一旦被调用，意味着触发了一次事件传播。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（十一）ChannelPipeline与ChannelHandler源码剖析</title>
      <link href="/2021/06/02/netty-wa-jue-ji-shi-yi-channelpipeline-yu-channelhandler-yuan-ma-pou-xi/"/>
      <url>/2021/06/02/netty-wa-jue-ji-shi-yi-channelpipeline-yu-channelhandler-yuan-ma-pou-xi/</url>
      
        <content type="html"><![CDATA[<p>前面几篇<code>EventLoop</code>的底层原理，了解了事件循环执行器的创建和执行过程，接下来我们开始来深入了解Netty的数据管道<code>ChannelPipeline</code>和I/O事件处理器<code>ChannelHandler</code>，以及它们的工作原理。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在分析之前，我们要先明确两点：</p><ol><li>Netty中涉及大量的<code>inEventLoop()</code>的判断，即判断当前是否是I/O线程，是则直接操作，否则需要异步操作；</li><li>Netty中提供了事件传播机制，分别是入站事件、出站事件，入站是往链表后继节点的方向传播，出站则相反。</li></ol><p>如下图所示，<code>ChannelHandler</code>的工作机制类似于Servlet中的Filter机制，采用一种类似职责链模式的方式，数据管道<code>ChannelPipeline</code>作为编排管理容器，内部持有一组I/O处理器<code>ChannelHandler</code>双向链表，I/O处理器通过每个处理器上下文<code>ChannelHandlerContext</code>和管道交互。消息在管道中传递，I/O处理器列表会按序逐个拦截并处理消息，故我们可以很灵活地穿插一个新的拦截处理器到管道中且不会影响其他的。<br><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200928130354128_683761039.png" alt="channelHandler"></p><h2 id="什么是Channel"><a href="#什么是Channel" class="headerlink" title="什么是Channel"></a>什么是Channel</h2><p><code>Channel</code>是Netty提供用于关联网络socket或者具有I/O功能的组件。它提供了诸如读就绪、写就绪、连接就绪、绑定就绪等的操作。</p><p>作为一个接口，它还继承了<code>ChannelOutboundInvoker</code>出站调用者接口，主要提供了如下功能</p><ul><li>通道的当前状态</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Channel是否已打开，且以后可能会激活</span><span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Channel是否已注册到EventLoop上</span><span class="token keyword">boolean</span> <span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Channel是否处于激活状态，且已连接</span><span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当且仅当I/O线程立即执行请求的写操作时，返回true</span><span class="token keyword">boolean</span> <span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>通道的配置信息</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Channel所注册的EventLoop</span>EventLoop <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Channel配置项</span>ChannelConfig <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Channel绑定的本地地址</span>SocketAddress <span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Channel绑定的远程地址</span>SocketAddress <span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取直到isWritable()返回false为止，可以写入的字节数，在返回false之前大于0，返回false则为0</span><span class="token keyword">long</span> <span class="token function">bytesBeforeUnwritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取必须从底层缓冲区中耗尽多少字节数，直到isWritable()返回true为止</span><span class="token keyword">long</span> <span class="token function">bytesBeforeWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回分配到的ChannelPipeline</span>ChannelPipeline <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回分配到的ByteBufAllocator，用于分配ByteBuf</span>ByteBufAllocator <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>通道支持的I/O操作</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 绑定操作。绑定到指定的localAddress，并在操作完成后通知</span>ChannelFuture <span class="token function">bind</span><span class="token punctuation">(</span>SocketAddress localAddress<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 连接操作。连接到指定的remoteAddress，并在操作完成后通知</span>ChannelFuture <span class="token function">connect</span><span class="token punctuation">(</span>SocketAddress remoteAddress<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 取消连接操作。请求与远程方断开连接，并在操作完成后通知</span>ChannelFuture <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 关闭Channel操作</span>ChannelFuture <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读取操作。请求从Channel读取数据到第一个入站缓冲区，并触发ChannelInboundHandler#channelRead，当数据已读取时则触发ChannelInboundHandler#channelReadComplete</span>ChannelOutboundInvoker <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写操作。请求通过当前ChannelHandlerContext，来经过ChannelPipeline写入消息。此方法不会冲刷消息，故还需要调用flush()</span>ChannelFuture <span class="token function">write</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 冲刷操作。请求通过当前ChannelOutboundInvoker，来冲刷所有未决消息</span>ChannelOutboundInvoker <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写操作和冲刷操作的结合</span>ChannelFuture <span class="token function">writeAndFlush</span><span class="token punctuation">(</span>Object msg<span class="token punctuation">,</span> ChannelPromise promise<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>源码中也提到了，Netty中涉及I/O操作的均是异步操作，这意味着任意的I/O操作都会立即返回，并且会通过执行I/O操作所返回的<code>ChannelFuture</code>实例获取操作结果，以此来实现。</p><blockquote><p>为什么Netty是一个异步事件驱动的框架?<br>从I/O模型上看，它采用了NIO，即同步非阻塞的方式（当然也有其他的实现方式，如异步非阻塞）。但是何为异步事件驱动，即所有的I/O操作均是异步的，每次执行都会立即返回，且返回的一个是<code>ChannelFuture</code>实例，可得知这一次I/O操作的成功与否。</p></blockquote><h2 id="什么是ChannelHandler"><a href="#什么是ChannelHandler" class="headerlink" title="什么是ChannelHandler"></a>什么是ChannelHandler</h2><blockquote><p>贴一下源码注释：<br>Handles an I/O event or intercepts an I/O operation, and forwards it to its next handler in its.</p></blockquote><p><code>ChannelHandler</code>是在<code>Channel</code>的生命周期一系列操作中的处理器。</p><p>让我们回顾一下，在通过Netty实现的API项目中，我们都用到了<code>ChannelHandler</code>来处理、转发消息</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// do something...</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而<code>ChannelHandler</code>是在每一次I/O事件进来时调用<code>addLast</code>按序添加到管道中，<code>addLast</code>是通过更新链表的指针位置来添加的。</p><pre class=" language-java"><code class="language-java">ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrap    <span class="token comment" spellcheck="true">// 绑定两个组</span>    <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 创建NioServerSocketChannel实例</span>    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 添加处理器Handler</span>    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 为通道Channel进行初始化配置</span>            ChannelPipeline pipeline <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">HttpServerHandler</span><span class="token punctuation">(</span>controllerAdapter<span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="什么是ChannelHandlerContext"><a href="#什么是ChannelHandlerContext" class="headerlink" title="什么是ChannelHandlerContext"></a>什么是ChannelHandlerContext</h2><p>上面说了，它主要是使<code>ChannelHandler</code>和<code>ChannelPipeline</code>、其他的<code>ChannelHandler</code>进行交互。</p><p>这里主要讲下它的抽象实现类<code>AbstractChannelHandlerContext</code>，作为双向链表中的某个节点结构，它内部维护了前驱和后继节点，为<code>ChannelHandlerContext</code>提供了很多默认实现。其中，比较重要的知识点是管理<code>ChannelContext</code>的状态，用<code>volatile</code>关键字标识的<code>handlerState</code>，状态类型主要有</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始状态</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INIT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ChannelHandler#handlerAdded即将被调用</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ADD_PENDING <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ChannelHandler#handlerAdded已经被调用完成</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ADD_COMPLETE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ChannelHandler#handlerRemoved已经被调用完成</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> REMOVE_COMPLETE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>对于状态的切换，在后面的工作原理会提到。</p><p>接下来再分析下类图和源码</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>先看下类图，最顶层接口<code>ChannelHandler</code>，其直接实现子类有出入站I/O处理器、和一个<strong>适配者处理器</strong>实现，而基于它们，Netty又分别封装了出入站的<strong>适配器处理器</strong>实现，通过适配器模式实现了更丰富的消息处理和转发的功能。</p><p><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200928130549089_382264287.png" alt="类图"></p><h3 id="基层接口ChannelHandler"><a href="#基层接口ChannelHandler" class="headerlink" title="基层接口ChannelHandler"></a>基层接口<code>ChannelHandler</code></h3><p>用于处理I/O事件或者拦截I/O操作，处理后转发到下一个Handler。<br>它提供了一个处理器上下文<code>ChannelHandlerContext</code>，通过上下文对象与<code>ChannelPipeline</code>进行交互，故它可以在上游或下游传递事件，动态地更改管道或存储信息。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将ChannelHandler添加到上下文中，并可以处理事件后调用</span><span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将ChannelHandler从上下文中移除时，并不再处理事件后调用</span><span class="token keyword">void</span> <span class="token function">handlerRemoved</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 触发了Throwable的处理，已被弃用，Netty建议通过实现ChannelInboundHandler接口去处理</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 带有此注解的ChannelHandler实例被认为可共享实例，可被添加多多个数据管道`ChannelPipeline`中</span><span class="token comment" spellcheck="true">// 若没指定注解，则必须创建一个新实例</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">Sharable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// no value</span><span class="token punctuation">}</span></code></pre><h3 id="入站处理器接口ChannelInboundHandler"><a href="#入站处理器接口ChannelInboundHandler" class="headerlink" title="入站处理器接口ChannelInboundHandler"></a>入站处理器接口<code>ChannelInboundHandler</code></h3><p>实现了基层接口<code>ChannelHandler</code>，提供了入站I/O操作的各种channel状态更改后的回调方法处理。<br>如channel注册、取消注册、激活、停用并结束生命周期、已读、读完最后一条消息，其中还支持触发用户事件的处理、Channel写状态被改变的处理、常信息的处理。</p><p><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200928130619354_1594054888.png" alt="入站"></p><h3 id="出站处理器接口ChannelOutboundHandler"><a href="#出站处理器接口ChannelOutboundHandler" class="headerlink" title="出站处理器接口ChannelOutboundHandler"></a>出站处理器接口<code>ChannelOutboundHandler</code></h3><p>实现了基层接口<code>ChannelHandler</code>，提供了出站I/O操作的各种channel状态更改后的回调方法处理。<br>如channel绑定（到localAddress ）、连接（从localAddress 连接到remoteAddress）、取消连接、关闭、注销（从当前已注册的EventLoop）、读、写（通过<code>ChannelPipeline</code>刷新到<code>Channel</code>上，即Channel.flush()会被调用）、刷新。</p><p><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/20200928130646184_523572845.png" alt="出站"></p><h3 id="入站处理器适配器类ChannelInboundHandlerAdapter"><a href="#入站处理器适配器类ChannelInboundHandlerAdapter" class="headerlink" title="入站处理器适配器类ChannelInboundHandlerAdapter"></a>入站处理器适配器类<code>ChannelInboundHandlerAdapter</code></h3><p> 入站处理器接口<code>ChannelInboundHandler</code>的抽象实现类，以下实现方法仅是将操作结果转发给下一个<code>ChannelHandler</code>，我们可以作为子类覆盖它的实现方式，如Netty自带的<code>SimpleChannelInboundHandler</code>就覆盖了部分方法的实现。</p><p>在实现方法的处理上，仅仅将各个channel状态的回调进行转发到<code>ChannelPipeline</code>中的下一个处理器</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Skip</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRegistered</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ......</span></code></pre><p>其中，<code>@Skip</code>注解的方法，被认定为<code>ChannelPipeline</code>直接跳过不会调用它，而只能在<code>ChannelHandler</code>下使用，很有意思的是，源码中还提到，区别于JDK的元注解<code>@Inherited</code>（使它所修饰的注解具有继承性）会将特性传递至子类，一旦子类覆盖了方法实现，则不再跳过。具体的拦截处理是在<code>io.netty.channel.ChannelHandlerMask</code>中进行，有兴趣的盆友可以看看。</p><blockquote><p>元注解，meta-annotation，即可以注解到注解类型上的注解，JDK提供了四种元注解：@Target、@Retention、@Documented、@Inherited。</p></blockquote><h3 id="入站处理器简单抽象实现类SimpleChannelInboundHandler"><a href="#入站处理器简单抽象实现类SimpleChannelInboundHandler" class="headerlink" title="入站处理器简单抽象实现类SimpleChannelInboundHandler"></a>入站处理器简单抽象实现类<code>SimpleChannelInboundHandler</code></h3><p>继承了<code>ChannelInboundHandlerAdapter</code>，主要对<code>channelRead</code>方法的实现进行覆盖</p><ul><li>提供了泛型处理<br>  即允许显示地处理特定的类型的消息，比如可以指定处理类型为<code>String</code>的消息，或者指定<code>FullHttpRequest</code>的消息，一次性获取所有的请求内容，而不用涉及到对不同请求过程的处理（如HttpReuqrst、HttpContent）。</li><li>自动释放消息<br>  对于指定类型的消息，在执行完后默认会调用<code>ReferenceCountUtil#release</code>释放消息内容，故当需要将消息传递给下个处理器时，应调用<code>ReferenceCountUtil#retain</code></li></ul><p>看下具体的代码</p><p>默认创建的实例，会标识为消息自动清除，如果不想自动清除的话，可以调用第二个方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">SimpleChannelInboundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token function">SimpleChannelInboundHandler</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> autoRelease<span class="token punctuation">)</span> <span class="token punctuation">{</span>    matcher <span class="token operator">=</span> TypeParameterMatcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SimpleChannelInboundHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>autoRelease <span class="token operator">=</span> autoRelease<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的覆盖目的，主要在于检测消息类型是否匹配指定类型，还有支持自动释放消息，作为一个抽象类，只提供了一个抽象方法<code>channelRead0</code>，给子类进行消息处理。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> release <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acceptInboundMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            I imsg <span class="token operator">=</span> <span class="token punctuation">(</span>I<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>            <span class="token function">channelRead0</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> imsg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            release <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>autoRelease <span class="token operator">&amp;&amp;</span> release<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> I msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span></code></pre><h3 id="出站处理器适配器类ChannelOutboundHandlerAdapter"><a href="#出站处理器适配器类ChannelOutboundHandlerAdapter" class="headerlink" title="出站处理器适配器类ChannelOutboundHandlerAdapter"></a>出站处理器适配器类<code>ChannelOutboundHandlerAdapter</code></h3><p>出站处理器接口<code>ChannelOutboundHandler</code>的抽象实现类，以下实现方法仅是将操作结果转发给下一个<code>ChannelHandler</code>，我们可以作为子类覆盖它的实现方式，如Netty自带的<code>SimpleChannelInboundHandler</code>就覆盖了部分方法的实现。</p><p>在实现方法的处理上，也是仅仅将各个channel状态的回调进行转发到<code>ChannelPipeline</code>中的下一个处理器</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Skip</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bind</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> SocketAddress localAddress<span class="token punctuation">,</span>        ChannelPromise promise<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ......</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算线程池最佳线程数</title>
      <link href="/2021/02/21/ji-suan-xian-cheng-chi-zui-jia-xian-cheng-shu/"/>
      <url>/2021/02/21/ji-suan-xian-cheng-chi-zui-jia-xian-cheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="计算线程池最佳线程数"><a href="#计算线程池最佳线程数" class="headerlink" title="计算线程池最佳线程数"></a>计算线程池最佳线程数</h1><p>先看一道题目</p><blockquote><p>假设要求一个系统的TPS（Transaction Per Second或者Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s。那么问题转化为：</p><p>如何设计线程池大小，使得可以在1s内处理完20个Transaction？</p><p>计算过程很简单，每个线程的处理能力为0.25TPS，那么要达到20TPS，显然需要20/0.25=80个线程。</p></blockquote><p>这个理论上成立的，但是实际情况中，一个系统最快的部分是CPU，所以决定一个系统吞吐量上限的是CPU。增强CPU处理能力，可以提高系统吞吐量上限。在考虑时需要把CPU吞吐量加进去。</p><p>在《Java Concurrency in Practice》一书中，给出了估算线程池大小的公式</p><ul><li><p>Nthreads = Ncpu x Ucpu x (1 + W/C)，其中</p></li><li><p>Ncpu = CPU核心数</p></li><li><p>Ucpu = CPU使用率，0~1</p></li><li><p>W/C = 等待时间与计算时间的比率</p></li></ul><p>即线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。这就可以划分成两种任务类型：</p><ul><li><p>IO密集型：一般情况下，如果存在IO，那么肯定W/C &gt; 1（阻塞耗时一般都是计算耗时的很多倍），但是需要考虑系统内存有限（每开启一个线程都需要内存空间），这里需要在服务器上测试具体多少个线程数适合（CPU占比、线程数、总耗时、内存消耗）。如果不想去测试，保守点取1即可，Nthreads = Ncpu x (1 + 1) = 2Ncpu。这样设置一般都OK。</p></li><li><p>计算密集型：假设没有等待W = 0，则W/C = 0。 Nthreads = Ncpu。</p></li></ul><p>原文地址：<a href="https://www.cnblogs.com/warehouse/p/10810338.html" target="_blank" rel="noopener">https://www.cnblogs.com/warehouse/p/10810338.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次线程池引发的bug</title>
      <link href="/2021/01/16/ji-lu-yi-ci-xian-cheng-chi-yin-fa-de-bug/"/>
      <url>/2021/01/16/ji-lu-yi-ci-xian-cheng-chi-yin-fa-de-bug/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一次线程池引发的bug"><a href="#记录一次线程池引发的bug" class="headerlink" title="记录一次线程池引发的bug"></a>记录一次线程池引发的bug</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li><p>系统中存在多数的调度任务执行</p></li><li><p>项目使用的微服务架构是Spring Cloud，系统中服务间调用通过token来鉴权，即在header上添加token。于是就用上个了<code>Threadlocal</code>来管理token</p><p>  关于跨线程token授权，可以看下<br>  <a href="https://chenyongjun.vip/articles/83" target="_blank" rel="noopener">Spring Cloud 之 Hystrix 跨线程传递数据</a><br>  <a href="http://www.itmuch.com/spring-cloud-sum/hystrix-threadlocal/" target="_blank" rel="noopener">Hystrix传播ThreadLocal对象</a></p></li></ul><h3 id="最早的版本"><a href="#最早的版本" class="headerlink" title="最早的版本"></a>最早的版本</h3><p>原来的调度任务是通过@Schedule + @Async 来控制。<br>@Schedule线程池默认单线程，即在同一个项目中，一个任务在运行，另一个任务则需要排队等待<br>@Async实现了AsyncConfigurer，自定义了一套线程池策略，其中设置了拒绝策略是当任务添加到线程池被拒绝时，会在线程池当前运行的线程中执行被拒绝的任务。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span><span class="token string">"taskExecutor"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IThreadPoolTaskExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolTaskExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ConfigBean configBean<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">IThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// config something...</span>        <span class="token comment" spellcheck="true">// 设置拒绝策略</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Future<span class="token operator">&lt;</span>T<span class="token operator">></span> future <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>                    <span class="token keyword">new</span> <span class="token class-name">ICallable</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> MDC<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>MdcConstant<span class="token punctuation">.</span>REQUEST_ID_KEY<span class="token punctuation">)</span><span class="token punctuation">,</span> configBean<span class="token punctuation">.</span><span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> future<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意，这里就有两个问题</p><ul><li>@Schedule是单一线程池，系统中有多个调度任务执行时，不友好；</li><li>@Async的拒绝策略为线程池的所在线程执行拒绝任务，而@Schedule又是单一线程池，当系统中有多个调度任务在运行，某些情况就会出现@Async的线程池很容易就满了（因为一个调度任务中还有多个延时任务），导致线程池的所在线程在不断的执行任务。</li></ul><p>而线上真实场景出现的问题就是，在某个时刻经常有些任务卡住，大概十几分钟，最长半个小时，在业务对于时效性比较敏感的前提下，这种问题是不允许存在的。</p><h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><p>同事对其做了改进，直接通过@Schedule来控制，去掉@Async异步线程池的控制<br>@Schedule实现了任务调度接口，配置了线程池数量为10个</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> TaskScheduler <span class="token function">taskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ThreadPoolTaskScheduler scheduler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 理论上并发线程最大数量为@Schedule的数量，目前@Schedule为8</span>    scheduler<span class="token punctuation">.</span><span class="token function">setPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    scheduler<span class="token punctuation">.</span><span class="token function">setThreadFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"schedule-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> scheduler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上修改，放到生产，确实修复了第一版的拉取卡住问题。</p><p>然而在做后续的需求时，发现了更大的隐藏bug。。。</p><h3 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h3><p>笔者主动尝试重构了某个模块，并在今天打算接入业务系统，刚好就要接入到调度任务中。<br>于是笔者按照版本二的思路，正常接入并放至测试环境，却出现问题了，经常出现服务间鉴权失败报401</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0bug/20210112192012959_920877117.png" alt=""></p><p>而在同个调度任务中，其他未改动的service则正常跑。</p><h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>在开头也提到了，系统服务间调用是通过传递token来鉴权的，当未传递token时则会返回401的异常。代码原作者，还实现了一套自定义的并发策略来传递token，避免因为Hystrix的隔离策略导致获取不到线程副本中的token。详细可查看开头的链接。</p><p>笔者一开始整理的可能性如下</p><ul><li>代码里面涉及了多线程</li><li>由于项目后续也接入了XXL-JOB来管理调度任务，初步怀疑XXL-JOB导致的问题</li><li>Hystrix隔离策略导致的问题，比如隔离策略为<code>THREAD</code>时，没办法拿到<code>ThreadLocal</code>的值（未真正验证过，网友所述）</li></ul><p>根据以上可能性逐一排查</p><ul><li>代码中不存在多线程版本，排除</li><li>将XXL-JOB去掉，继续使用@Schedule，还是会触发，排除</li><li>隔离策略，由于对它了解的比较少，故参考了不少的文献后，决定排除。因为同样用一套代码，为什么任务中原有的逻辑都没问题，新改动的代码就有问题</li></ul><p>再次梳理，其实这次的问题，肯定是出现在线程的问题上，排除了Hystrix线程的问题，故肯定是在其他线程的问题，现有线程池有一个@Schedule，还有一个@Async线程池，但是据同事所说已经去掉了@Async注解。</p><p>这时，突然在看原有逻辑的代码中，发现了<code>@Async</code>的注解，在调用的方法实现上添加的。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Async</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span></code></pre><p>而笔者的代码是按版本二的逻辑实现的，即只使用了<code>@Schedule</code>线程池，故大胆猜测<code>@Async</code>能够修复问题，确实如此！</p><p>有结果就可以反推问题，列出细节</p><ul><li>两个线程池<ul><li>调度线程池使用@Schedule（10个线程），或者接入XXL-JOB的话，只有一个线程</li><li>@Async 异步线程池（8个线程），拒绝策略是由调度线程执行任务</li></ul></li><li>调度线程池中维护着线程副本</li><li>线程副本存放token，用于服务调用鉴权</li><li>代码中清除线程副本涉及的位置很多</li></ul><p>本地进行debug测试，在前几次拿到的线程副本如下，都不为空，并且可以观察下线程名<br><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0bug/20210112171309338_1959893546.png" alt=""></p><p>原来在threadlocalmap里是有副本信息的，再debug几轮就没了，如下图所示<br><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0bug/20210112170539343_940782680.png" alt=""></p><p>基于以上，基本可以确定是因为线程策略的选择，导致线程副本被清空。</p><p>具体的清空地方如下，实现了<code>Callable</code>接口，并重写了<code>call</code>方法，<br>其中先获取主线程传递进来的线程副本token，再将token设置到当前线程的线程副本中（用于后续的调用，比如项目里是在<code>RequestInterceptor</code>的实现类中获取并设置header，再去进行Feign调用），当执行完任务后，当前线程会将线程副本的token清除掉。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ICallable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">;</span>    <span class="token keyword">private</span> String requestId<span class="token punctuation">;</span>    <span class="token keyword">private</span> String token<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ICallable</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">,</span> String requestId<span class="token punctuation">,</span> String token<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>requestId <span class="token operator">=</span> requestId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>token <span class="token operator">=</span> token<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> T <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>requestId <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>MdcConstant<span class="token punctuation">.</span>REQUEST_ID_KEY<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">;</span>            FeignHolder<span class="token punctuation">.</span>REQUEST_ID<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>requestId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            FeignHolder<span class="token punctuation">.</span>TOKEN<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> task<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>requestId <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                MDC<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>MdcConstant<span class="token punctuation">.</span>REQUEST_ID_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>                FeignHolder<span class="token punctuation">.</span>REQUEST_ID<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>FeignHolder<span class="token punctuation">.</span>TOKEN<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                FeignHolder<span class="token punctuation">.</span>TOKEN<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>至于在哪用，</p><p>前面提到了异步线程池的实现类，其中就实例化了一个<code>Callable</code>实现类，并提交</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Future<span class="token operator">&lt;</span>T<span class="token operator">></span> future <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">ICallable</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> MDC<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>MdcConstant<span class="token punctuation">.</span>REQUEST_ID_KEY<span class="token punctuation">)</span><span class="token punctuation">,</span> hioSystemConfigBean<span class="token punctuation">.</span><span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> future<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        taskum<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>taskum<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">20000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            taskum<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>taskum<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            failedTaskumNum<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>failedTaskumNum<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>前面也提到了自定义并发策略，其中也实例化了一个<code>Callable</code>实现类来传递token</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IHystrixConcurrencyStrategy</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixConcurrencyStrategy</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">IHystrixConcurrencyStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HystrixPlugins<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HystrixPlugins<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerConcurrencyStrategy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">wrapCallable</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ICallable</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> MDC<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>MdcConstant<span class="token punctuation">.</span>REQUEST_ID_KEY<span class="token punctuation">)</span><span class="token punctuation">,</span> FeignHolder<span class="token punctuation">.</span>TOKEN<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>当前使用调度线程池（10个），异步线程池（3个）（本地由于资源有限，故将异步线程池设置小点）</p><ol><li>调度任务的第一步是先给当前调度线程设置线程副本，即设置token</li><li>顺利的话，异步线程池不紧张，项目正常进行，每个异步线程执行完任务后，接着执行<code>ICallable</code>的<code>call</code>方法，将当前线程的副本token清除</li><li>突然遇到异步线程池满了，调度线程接替执行，接着执行<code>ICallable</code>的<code>call</code>方法，在调度线程将token清除了</li><li>后续的任务，在执行<code>ICallable#call</code>时，无法再通过调度线程获取token，即后续链路中token 都为null，故服务调用就会报401</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>原作者，将服务调用都通过这一套鉴权体系管理起来，链路大致如下<br><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0bug/20210112211346033_650083725.png" alt="hystrix_chain"></p><ul><li>用户调用接口时，若涉及服务调用，<code>Hystrix</code>会通过<code>FutureTask</code>提交任务，故在<code>run</code>的时候，就会来到<code>ICallable#call</code>，并将token传递到执行线程作为线程副本</li><li>系统调用接口时，若涉及服务调用<ul><li>若使用异步线程池，则通过自定义异步线程池类，来<code>submit</code>任务，在<code>run</code>的时候，就会来到<code>ICallable#call</code>，并将token传递到执行线程作为线程副本</li><li>若使用主线程（或调度线程），<code>Hystrix</code>会通过<code>FutureTask</code>提交任务，故在<code>run</code>的时候，就会来到<code>ICallable#call</code>，并将token传递到执行线程作为线程副本</li></ul></li></ul><p>如果使用的都是异步线程池的话，则不会有token被清除导致不能用的问题，因为它每次传入<code>ICallable</code>对象的token都是从配置读取的，但是调度线程的token终究还是被清除了。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>同个调度任务中，服务调用的相关代码，均使用同一套异步线程池，保证服务调用不存在于调度线程。<br>缺点：治标不治本，调度线程的token仍然有机会被清除。当调度任务中添加新的服务调用代码，开发者无法感知到有这个bug，将其置于调度线程调用。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>同个调度任务中，按需使用异步注解<code>@Async</code>，且更改异步线程池的拒绝策略，为非调度线程执行。<br>优点：可对任务中的子任务进行分类，较为延时的使用异步线程池。拒绝时则排队等待</p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>同个调度任务中，涉及代码都不用异步注解<code>@Async</code>，可直接在最外层使用<code>@Schedule</code>线程池，自定义配置管理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次排查问题比较久，主要问题在于</p><ul><li>项目日志没有加线程名标记，不清晰</li><li>在未知答案的前提下，本地调试不容易发现问题</li><li>对于线程池的策略选择不合理，当配置了拒绝策略为线程池所在线程执行时，极容易导致很多问题，比如主线程卡住，线程的副本”变脏“、”丢失“等等</li><li>对于Spring cloud的了解不够深，导致将大部分时间花在了排除<code>Hystrix</code>隔离策略、<code>Feign</code>并发策略上</li><li>版本二中，同事未发现该问题，以为只有一个@Scheudle线程池，也因此排除了这种可能性</li></ul>]]></content>
      
      
      <categories>
          
          <category> BUG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何查看JAVA的汇编指令</title>
      <link href="/2020/11/10/ru-he-cha-kan-java-de-hui-bian-zhi-ling/"/>
      <url>/2020/11/10/ru-he-cha-kan-java-de-hui-bian-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="如何查看JAVA的汇编指令"><a href="#如何查看JAVA的汇编指令" class="headerlink" title="如何查看JAVA的汇编指令"></a>如何查看JAVA的汇编指令</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常开发时，我们接触最多的就是java代码，进阶会去接触的，就是编译生成的字节码。然而在某些时候我们需要研究JDK更底层的实现时，字节码无法满足我们的需求，于是再进阶去接触汇编指令。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>JDK本身支持查看汇编指令，但是我们要使用的话，需要做些操作。首先从<a href="https://github.com/evolvedmicrobe/benchmarks/blob/master/hsdis-amd64.dylib" target="_blank" rel="noopener">https://github.com/evolvedmicrobe/benchmarks/blob/master/hsdis-amd64.dylib</a>下载<code>hsdis-amd64.dylib</code>，接着将它放置到jdk目录下的<code>jre/lib</code>目录下。</p><pre class=" language-shell"><code class="language-shell"># 找到jdk安装路径/usr/libexec/java_home -V#cd /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/jre/libmv /Downloads/hsdis-amd64.dylib ./</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li><p>通过命令</p><pre class=" language-shell"><code class="language-shell">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly ***.class</code></pre></li><li><p>通过idea配置</p></li></ul><p><img src="/images/Tool/20201110160906767_2012683595.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP+Transactional源码解析</title>
      <link href="/2020/09/11/springaop-transactional-yuan-ma-jie-xi/"/>
      <url>/2020/09/11/springaop-transactional-yuan-ma-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP-Transactional源码解析"><a href="#Spring-AOP-Transactional源码解析" class="headerlink" title="Spring AOP + Transactional源码解析"></a>Spring AOP + Transactional源码解析</h1><p>Spring AOP应用于多数场景</p><ul><li>缓存</li><li>权限</li><li>懒加载</li><li>日志</li><li>事务</li><li>。。。</li></ul><p>这一篇将通过AOP源码的实现层面，结合事务的传播机制，来理解AOP是如何管理事务的。</p><h2 id="生成AopProxy代理"><a href="#生成AopProxy代理" class="headerlink" title="生成AopProxy代理"></a>生成AopProxy代理</h2><p>Spring在启动期间，会将待注入的类注入到容器中，期间它会判断该类是否需要被代理，是的话将会创建该类实例的代理对象，代码片段如下<br>方法位于<code>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object cacheKey <span class="token operator">=</span> <span class="token function">getCacheKey</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyProxyReferences<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span> <span class="token operator">!=</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">wrapIfNecessary</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> bean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先看一下生成代理对象的时序图<br><img src="/images/SpringAOP/20200827145310512_991703414.png" alt="createProxy"></p><h3 id="检测是否要代理bean（AbstractAutoProxyCreator-wrapIfNecessary）"><a href="#检测是否要代理bean（AbstractAutoProxyCreator-wrapIfNecessary）" class="headerlink" title="检测是否要代理bean（AbstractAutoProxyCreator#wrapIfNecessary）"></a>检测是否要代理bean（AbstractAutoProxyCreator#wrapIfNecessary）</h3><ul><li>检查是否有必要包装一下Bean，即是否需要往bean上添加代理对象，具体的检测逻辑如下</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> List<span class="token operator">&lt;</span>Advisor<span class="token operator">></span> <span class="token function">findEligibleAdvisors</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取要在自动代理中使用的候选顾问（增强器，由Advisor和Advice组成）列表</span>    List<span class="token operator">&lt;</span>Advisor<span class="token operator">></span> candidateAdvisors <span class="token operator">=</span> <span class="token function">findCandidateAdvisors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 过滤得到合格的候选顾问列表</span>    List<span class="token operator">&lt;</span>Advisor<span class="token operator">></span> eligibleAdvisors <span class="token operator">=</span> <span class="token function">findAdvisorsThatCanApply</span><span class="token punctuation">(</span>candidateAdvisors<span class="token punctuation">,</span> beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">extendAdvisors</span><span class="token punctuation">(</span>eligibleAdvisors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>eligibleAdvisors<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eligibleAdvisors <span class="token operator">=</span> <span class="token function">sortAdvisors</span><span class="token punctuation">(</span>eligibleAdvisors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> eligibleAdvisors<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>检测返回的可用的增强器（<code>Advisor</code>和<code>Advice</code>）列表后，如果列表不为null，则将其作为被代理的bean的状态缓存起来，并且开始创建代理对象<pre class=" language-java"><code class="language-java">Object<span class="token punctuation">[</span><span class="token punctuation">]</span> specificInterceptors <span class="token operator">=</span> <span class="token function">getAdvicesAndAdvisorsForBean</span><span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>specificInterceptors <span class="token operator">!=</span> DO_NOT_PROXY<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 缓存当前bean的代理状态</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>advisedBeans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>  Object proxy <span class="token operator">=</span> <span class="token function">createProxy</span><span class="token punctuation">(</span>          bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> specificInterceptors<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SingletonTargetSource</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 缓存代理类实例</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>proxyTypes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> proxy<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> proxy<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p>创建代理工厂，通过工厂创建bean的代理对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">createProxy</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> String beanName<span class="token punctuation">,</span>        <span class="token annotation punctuation">@Nullable</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> specificInterceptors<span class="token punctuation">,</span> TargetSource targetSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">ConfigurableListableBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AutoProxyUtils<span class="token punctuation">.</span><span class="token function">exposeTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建代理工厂，并且复制当前实例的相关属性</span>    ProxyFactory proxyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">copyFrom</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否设置直接代理目标类，而不是目标类接口</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proxyFactory<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldProxyTargetClass</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            proxyFactory<span class="token punctuation">.</span><span class="token function">setProxyTargetClass</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">evaluateProxyInterfaces</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">,</span> proxyFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 根据可用的增强器列表构建真正适用于该bean的增强器列表</span>    Advisor<span class="token punctuation">[</span><span class="token punctuation">]</span> advisors <span class="token operator">=</span> <span class="token function">buildAdvisors</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> specificInterceptors<span class="token punctuation">)</span><span class="token punctuation">;</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">addAdvisors</span><span class="token punctuation">(</span>advisors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置目标代理类</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">setTargetSource</span><span class="token punctuation">(</span>targetSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">customizeProxyFactory</span><span class="token punctuation">(</span>proxyFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    proxyFactory<span class="token punctuation">.</span><span class="token function">setFrozen</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>freezeProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">advisorsPreFiltered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        proxyFactory<span class="token punctuation">.</span><span class="token function">setPreFiltered</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token function">getProxyClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="代理工厂选取合适的AOP代理（ProxyFactory-getProxy）"><a href="#代理工厂选取合适的AOP代理（ProxyFactory-getProxy）" class="headerlink" title="代理工厂选取合适的AOP代理（ProxyFactory#getProxy）"></a>代理工厂选取合适的AOP代理（ProxyFactory#getProxy）</h3><p>上面创建的工厂代理类，配置了相应的属性后，将选取合适的AOP代理，并且生成代理对象</p><h3 id="创建AOP代理"><a href="#创建AOP代理" class="headerlink" title="创建AOP代理"></a>创建AOP代理</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果代理未激活，则激活该代理配置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">activate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取aop代理工厂类，并创建aop代理</span>    <span class="token keyword">return</span> <span class="token function">getAopProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Spring内置的aop代理有两种：JDK和Cglib。之前创建的代理工厂在下面创建方法作为形参</p><ul><li>使用JDK动态代理<ul><li>proxyTargetClass（是否直接代理目标类）为false </li><li>指定的目标类为接口类型</li><li>当且仅当使用<code>newProxyInstance</code>或<code>getProxyClass</code>动态将目标类生成代理类时</li></ul></li><li>使用Cglib代理<ul><li>proxyTargetClass（是否直接代理目标类）为true </li><li>指定的目标类不为接口类型</li><li>未使用<code>newProxyInstance</code>或<code>getProxyClass</code>动态将目标类生成代理类时</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> AopProxy <span class="token function">createAopProxy</span><span class="token punctuation">(</span>AdvisedSupport config<span class="token punctuation">)</span> <span class="token keyword">throws</span> AopConfigException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span>                    <span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> Proxy<span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>在Spring5中，AOP默认还是用JDK动态代理，如果被代理类未实现接口才使用Cglib代理</li><li>而在Springboot2.x中，AOP已默认使用Cglib代理<br>  即被代理类有没有实现接口，它都使用Cglib代理</li></ul><p>那如何更改为JDK代理呢？在Springboot中都是依靠自动装配来实现的，在启动过程中会加载各种配置，其中就涉及了AOP相关的配置，通过<code>spring.factories</code>可知相关配置代码在<code>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</code>。<br>从代码得知，Springboot2.x默认使用Cglib代理在于配置了<code>spring.aop.proxy-target-class=true</code>，故要切为JDK代理可配置<code>spring.aop.proxy-target-class=false</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.aop"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"auto"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>Advice<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AspectJAutoProxyingConfiguration</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token punctuation">(</span>proxyTargetClass <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.aop"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"proxy-target-class"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"false"</span><span class="token punctuation">,</span>                matchIfMissing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">JdkDynamicAutoProxyConfiguration</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token punctuation">(</span>proxyTargetClass <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.aop"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"proxy-target-class"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">,</span>                matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CglibAutoProxyConfiguration</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnMissingClass</span><span class="token punctuation">(</span><span class="token string">"org.aspectj.weaver.Advice"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.aop"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"proxy-target-class"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">,</span>            matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassProxyingConfiguration</span> <span class="token punctuation">{</span>        <span class="token function">ClassProxyingConfiguration</span><span class="token punctuation">(</span>BeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">BeanDefinitionRegistry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                BeanDefinitionRegistry registry <span class="token operator">=</span> <span class="token punctuation">(</span>BeanDefinitionRegistry<span class="token punctuation">)</span> beanFactory<span class="token punctuation">;</span>                AopConfigUtils<span class="token punctuation">.</span><span class="token function">registerAutoProxyCreatorIfNecessary</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>                AopConfigUtils<span class="token punctuation">.</span><span class="token function">forceAutoProxyCreatorToUseClassProxying</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="使用类加载器创建代理对象"><a href="#使用类加载器创建代理对象" class="headerlink" title="使用类加载器创建代理对象"></a>使用类加载器创建代理对象</h3><p>类加载器一般使用应用类加载器<code>AppClassLoader</code>，也可以自己实现了自定义加载器。</p><h4 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h4><p><img src="/images/SpringAOP/20200827145333136_1411722303.png" alt="createProxyInstance"></p><p>Cglib代理是委托给<code>CglibAopProxy</code>去创建的，创建过程如下</p><ul><li>获得目标类<code>rootClass</code></li><li>如果目标类已经被代理，则获取它的父类作为目标类</li><li>验证目标类，检查是否需要写日志</li><li>创建Enhancer对象（即代理增强器，类比于jdk自带的Proxy），准备创建代理类<ul><li>设置目标类为代理增强器父类</li><li>设置要实现的接口，有则使用目标类的接口，默认还会实现<code>SpringProxy</code>，<code>Advised</code>接口</li><li>覆盖命名策略，一般生成的代理类都是有对应的命名策略，在spring中，命名规范是：目标类名+<code>$$EnhancerBySpringCGLIB</code></li><li>设置生成字节码的策略，默认使用<code>DefaultGeneratorStrategy</code>，Spring中用了<code>GeneratorStrategy</code>的另一种实现<code>ClassLoaderAwareGeneratorStrategy</code></li><li>设置回调过滤器,根据被拦截的方法执行不同的处理逻辑。<code>CallbackFilter#accpet</code>在实际调用中,会根据被拦截的方法返回对应的索引，在<code>Callback</code>中会根据索引值拿到对应的回调处理逻辑</li></ul></li><li>创建目标类的代理类和目标类的代理类实例<ul><li>创建代理类<code>proxyClass</code></li><li>创建代理类实例<code>proxyInstance</code></li><li>设置回调组<code>Callbacks</code>，和<code>CallbackFilter</code>结合使用，回调组中有一个通用回调处理器<code>DynamicAdvisedInterceptor</code>，其<code>intercept()</code>是拦截的首入口。</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> rootClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>rootClass <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"Target class must be available for creating a CGLIB proxy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> proxySuperClass <span class="token operator">=</span> rootClass<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span>CGLIB_CLASS_SEPARATOR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            proxySuperClass <span class="token operator">=</span> rootClass<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span>        <span class="token function">validateClassIfNecessary</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token function">createEnhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            enhancer<span class="token punctuation">.</span><span class="token function">setClassLoader</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoader <span class="token keyword">instanceof</span> <span class="token class-name">SmartClassLoader</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>SmartClassLoader<span class="token punctuation">)</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isClassReloadable</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>proxySuperClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setInterfaces</span><span class="token punctuation">(</span>AopProxyUtils<span class="token punctuation">.</span><span class="token function">completeProxiedInterfaces</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setNamingPolicy</span><span class="token punctuation">(</span>SpringNamingPolicy<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassLoaderAwareGeneratorStrategy</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Callback<span class="token punctuation">[</span><span class="token punctuation">]</span> callbacks <span class="token operator">=</span> <span class="token function">getCallbacks</span><span class="token punctuation">(</span>rootClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>callbacks<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> types<span class="token punctuation">.</span>length<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            types<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> callbacks<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallbackFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProxyCallbackFilter</span><span class="token punctuation">(</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getConfigurationOnlyCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fixedInterceptorMap<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fixedInterceptorOffset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallbackTypes</span><span class="token punctuation">(</span>types<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">createProxyClassAndInstance</span><span class="token punctuation">(</span>enhancer<span class="token punctuation">,</span> callbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CodeGenerationException</span> <span class="token operator">|</span> IllegalArgumentException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"Could not generate CGLIB subclass of "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">": Common causes of this problem include using a final class or a non-visible class"</span><span class="token punctuation">,</span>                ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"Unexpected AOP exception"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h4><p><img src="/images/SpringAOP/20200827171028608_1306162524.png" alt="createJdkProxy"></p><p>JDK代理是委托给<code>JdkDynamicAopProxy</code>去创建的，创建过程如下</p><ul><li>设置要实现的接口，有则使用目标类的接口，默认还会实现<code>SpringProxy</code>，<code>Advised</code>接口</li><li>查找目标类是否定义了<code>equals</code>和<code>hashcode</code>，是的话分别标记<code>equalsDefined</code>为true，<code>hashCodeDefined</code>为true</li><li>调用<code>Proxy.newProxyInstance</code>生成目标类的代理类实例</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> proxiedInterfaces <span class="token operator">=</span> AopProxyUtils<span class="token punctuation">.</span><span class="token function">completeProxiedInterfaces</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">findDefinedEqualsAndHashCodeMethods</span><span class="token punctuation">(</span>proxiedInterfaces<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> proxiedInterfaces<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h2><p>在Spring中，事务机制与AOP做了结合，通过AOP封装了事务管理的代码，接下来将会通过AOP理解事务的传播机制。</p><h3 id="Propagation七种传播机制"><a href="#Propagation七种传播机制" class="headerlink" title="Propagation七种传播机制"></a>Propagation七种传播机制</h3><p>相关枚举在<code>org.springframework.transaction.annotation.Propagation</code>中</p><table><thead><tr><th>机制</th><th>说明</th><th>场景</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>若线程上下文中存在事务则加入，<strong>不存在</strong>则创建一个新事务</td><td>最常使用，因为它是Spring缺省的传播机制</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>若线程上下文中存在事务则加入，<strong>不存在</strong>则以非事务的模式执行</td><td>-（使用场景较少）</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>若线程上下文中存在事务则加入，<strong>不存在</strong>则抛出异常</td><td>常用于检测调用代码的上下文是否存在事务，提醒必须以事务运行</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>若线程上下文中存在事务则暂时挂起****，并创建一个新事务，执行完后才恢复其他上下文事务</td><td>常用于内层事务异常会导致回滚时，外层事务（一般）不会被回滚</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>若线程上下文中存在事务则<strong>挂起</strong>，并以非事务的模式执行，执行完才恢复上下文事务</td><td>常用于减少事务范围，同时避免内层事务异常而导致不必要的全局回滚的场景</td></tr><tr><td>PROPAGATION_NEVER</td><td>若线程上下文中存在事务，则<strong>抛出异常</strong></td><td>-（使用场景较少）</td></tr><tr><td>PROPAGATION_NESTED</td><td>若线程上下文中存在则<strong>嵌套事务</strong>执行，不存在则创建一个新事务。<br>它仅支持“在特定的事务管理器<code>DataSourceTransactionManager</code>上，以及使用jdbc3.0驱动程序”的使用，其提供了一个“save point”的父子事务的概念，在进入子事务之前建立一个“save point”，当子事务回滚时会先滚到“save point”，而父事务可以选择性回滚。</td><td>-（使用场景较少）</td></tr></tbody></table><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>关于传播机制，在上面已经做了描述，然而事实真的如以上描述一般的简单吗，接下来模拟做些测试用例，看看结论。</p><p>首先，先清楚两个点</p><ul><li>Spring默认传播机制是<code>PROPAGATION_REQUIRED</code></li><li><code>@Transactional</code>中默认回滚异常是<code>RuntimeException</code>，但是p3c建议我们显示的rollback</li></ul><h4 id="场景1：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出Runtime异常"><a href="#场景1：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出Runtime异常" class="headerlink" title="场景1：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出Runtime异常"></a>场景1：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出Runtime异常</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出Runtime异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="场景2：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出Runtime异常但是进行了异常捕获"><a href="#场景2：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出Runtime异常但是进行了异常捕获" class="headerlink" title="场景2：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出Runtime异常但是进行了异常捕获"></a>场景2：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出Runtime异常但是进行了异常捕获</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannelV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannelV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出Runtime异常并捕获"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上是在内层事务捕获，同样考虑一下在外层事务捕获的结果</p><h4 id="场景3：两个service-A-B-A方法调用B方法且都开启了事务，B方法抛出Runtime异常但是进行了异常捕获，且B方法事务指定了隔离级别为Propagation-REQUIRES-NEW"><a href="#场景3：两个service-A-B-A方法调用B方法且都开启了事务，B方法抛出Runtime异常但是进行了异常捕获，且B方法事务指定了隔离级别为Propagation-REQUIRES-NEW" class="headerlink" title="场景3：两个service A/B, A方法调用B方法且都开启了事务，B方法抛出Runtime异常但是进行了异常捕获，且B方法事务指定了隔离级别为Propagation.REQUIRES_NEW"></a>场景3：两个service A/B, A方法调用B方法且都开启了事务，B方法抛出Runtime异常但是进行了异常捕获，且B方法事务指定了隔离级别为Propagation.REQUIRES_NEW</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannelV3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannelV3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        userChannelMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>UserChannel<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"WX"</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出Runtime异常并捕获，但是我设置了隔离级别为新建事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上是在内层事务捕获，同样考虑一下在外层事务捕获的结果</p><h4 id="场景4：两个service-A-B-A方法调用B方法且都开启了事务，B方法抛出Runtime异常，且B方法事务指定了隔离级别为Propagation-REQUIRES-NEW"><a href="#场景4：两个service-A-B-A方法调用B方法且都开启了事务，B方法抛出Runtime异常，且B方法事务指定了隔离级别为Propagation-REQUIRES-NEW" class="headerlink" title="场景4：两个service A/B, A方法调用B方法且都开启了事务，B方法抛出Runtime异常，且B方法事务指定了隔离级别为Propagation.REQUIRES_NEW"></a>场景4：两个service A/B, A方法调用B方法且都开启了事务，B方法抛出Runtime异常，且B方法事务指定了隔离级别为Propagation.REQUIRES_NEW</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannelV4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannelV4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出Runtime异常，但是我设置了隔离级别为新建事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="场景5：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出自定义异常-非Runtime"><a href="#场景5：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出自定义异常-非Runtime" class="headerlink" title="场景5：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出自定义异常(非Runtime)"></a>场景5：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出自定义异常(非Runtime)</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> RuntimeException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CustomException <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannelV5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> RuntimeException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannelV5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CustomException <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出自定义异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上指定回滚异常为RuntimeException，要是设置为Exception，会是什么结果呢？</p><h4 id="场景6：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出自定义异常-非Runtime-但是进行了异常捕获"><a href="#场景6：两个service-A-B-A方法调用B方法且都开启了事务（默认级别Propagation-REQUIRED），B方法抛出自定义异常-非Runtime-但是进行了异常捕获" class="headerlink" title="场景6：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出自定义异常(非Runtime)但是进行了异常捕获"></a>场景6：两个service A/B, A方法调用B方法且都开启了事务（默认级别Propagation.REQUIRED），B方法抛出自定义异常(非Runtime)但是进行了异常捕获</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> RuntimeException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">addUserChannelV6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> RuntimeException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserChannelV6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        userChannelMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>UserChannel<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"WX"</span><span class="token punctuation">,</span> <span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装抛出自定义异常并捕获"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CustomException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上指定回滚异常为RuntimeException，要是设置为Exception，会是什么结果呢？</p><h4 id="场景7：service-A-a方法调用内部方法b且都开启了事务（默认级别Propagation-REQUIRED），b方法抛出Runtime异常"><a href="#场景7：service-A-a方法调用内部方法b且都开启了事务（默认级别Propagation-REQUIRED），b方法抛出Runtime异常" class="headerlink" title="场景7：service A, a方法调用内部方法b且都开启了事务（默认级别Propagation.REQUIRED），b方法抛出Runtime异常"></a>场景7：service A, a方法调用内部方法b且都开启了事务（默认级别Propagation.REQUIRED），b方法抛出Runtime异常</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在同个service内假装抛出异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="场景8：service-A-a方法调用内部方法b且都开启了事务（默认级别Propagation-REQUIRED），b方法抛出Runtime异常，且c方法事务指定了隔离级别为Propagation-REQUIRES-NEW"><a href="#场景8：service-A-a方法调用内部方法b且都开启了事务（默认级别Propagation-REQUIRED），b方法抛出Runtime异常，且c方法事务指定了隔离级别为Propagation-REQUIRES-NEW" class="headerlink" title="场景8：service A, a方法调用内部方法b且都开启了事务（默认级别Propagation.REQUIRED），b方法抛出Runtime异常，且c方法事务指定了隔离级别为Propagation.REQUIRES_NEW"></a>场景8：service A, a方法调用内部方法b且都开启了事务（默认级别Propagation.REQUIRED），b方法抛出Runtime异常，且c方法事务指定了隔离级别为Propagation.REQUIRES_NEW</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exceptionV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在同个service内假装抛出异常，但是我设置了隔离级别为新建事务，也会回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="AopProxy代理事务的操作过程"><a href="#AopProxy代理事务的操作过程" class="headerlink" title="AopProxy代理事务的操作过程"></a>AopProxy代理事务的操作过程</h2><p>上面提供了8个场景，在获取测试结果之前，先看下AOP代理事务的操作流程</p><h3 id="Cglib代理过程"><a href="#Cglib代理过程" class="headerlink" title="Cglib代理过程"></a>Cglib代理过程</h3><p>同样，Cglib代理过程也是委托给<code>CglibAopProxy</code>去执行的，那结合上面创建代理对象的流程，我们如何得知代理执行的入口和代理流程呢？</p><p>在Cglib代理对象的创建过程中设置的回调组<code>Callbacks</code>中，回调类如下</p><pre class=" language-java"><code class="language-java">Callback aopInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicAdvisedInterceptor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">)</span><span class="token punctuation">;</span>Callback<span class="token punctuation">[</span><span class="token punctuation">]</span> mainCallbacks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>        aopInterceptor<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// for normal advice</span>        targetInterceptor<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// invoke target without considering advice, if optimized</span>        <span class="token keyword">new</span> <span class="token class-name">SerializableNoOp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// no override for methods mapped to this</span>        targetDispatcher<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>advisedDispatcher<span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">EqualsInterceptor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">HashCodeInterceptor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>advised<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>结合前面提到的，它一般和<code>CallbackFilter</code>结合使用，<code>CglibAopProxy#accpet</code>在实际调用中,会根据被拦截的方法返回对应的索引，在<code>Callback</code>中会根据索引值拿到对应的回调处理逻辑，其实<code>CglibAopProxy</code>中已经声明了对应静态不可变的成员变量</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> AOP_PROXY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INVOKE_TARGET <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NO_OVERRIDE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DISPATCH_TARGET <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DISPATCH_ADVISED <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INVOKE_EQUALS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INVOKE_HASHCODE <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span></code></pre><p>在<code>org.springframework.cglib.proxy.Enhancer#emitMethods</code>中，会遍历被代理类的方法，并且设置切入点，初始默认会返回<code>AOP_PROXY</code>，即回调处理逻辑将在通用AOP回调<code>DynamicAdvisedInterceptor#intercept</code>中进行，具体看源码即可</p><p>好了，知道了代理的入口，再整理下代理流程</p><ul><li>调用方法<code>method</code>，首先拦截于<code>DynamicAdvisedInterceptor#intercept</code>；</li><li>获取目标类实例<code>targetClass</code>，根据<code>method</code> + <code>targetClass</code>从代理配置管理器<code>AdvisedSupport</code>中获取拦截器（Advice通知）链条<code>chain</code>；</li><li>创建一个Cglib方法调用对象<code>CglibMethodInvocation</code>，执行调用方法<code>proceed</code>，准备调用拦截器链条</li><li><code>CglibMethodInvocation</code>中维护着当前拦截器索引<code>currentInterceptorIndex</code>，当它小于拦截器链条长度时，会自增并依次作为索引条件获取指定拦截器，并执行它的切入点<code>TransactionInterceptor#invoke()</code>，从名字可以看出是一个事务操作的拦截器，当自增到等于拦截器链条长度时，开始真正调用被代理方法；</li><li>接下来会执行<code>TransactionAspectSupport#invokeWithinTransaction</code>，在被代理方法前先开启事务，接着回调到上一步，循环执行拦截器；</li></ul><p><img src="/images/SpringAOP/20200828124511456_281569522.png" alt="Cglib代理过程"></p><h4 id="事务执行过程"><a href="#事务执行过程" class="headerlink" title="事务执行过程"></a>事务执行过程</h4><blockquote><p>在Spring事务执行中，它提供了抽象事务管理器类<code>AbstractPlatformTransactionManager</code>来处理通用的事务处理流程，而它的子类将做具体的实现，如事务开始，事务提交、事务回滚等，如<code>DataSourceTransactionManager</code>、<code>JpaTransactionManager</code>等。</p></blockquote><p>上面代理执行过程中，在事务拦截器阶段，将会执行一段事务操作，其中最核心的过程和代码片段如下</p><ul><li>开启事务</li><li>执行被代理的业务方法</li><li>异常则回滚事务</li><li>提交事务</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> TransactionAttribute txAttr <span class="token operator">=</span> <span class="token punctuation">(</span>tas <span class="token operator">!=</span> null <span class="token operator">?</span> tas<span class="token punctuation">.</span><span class="token function">getTransactionAttribute</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>txAttr <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>ptm <span class="token keyword">instanceof</span> <span class="token class-name">CallbackPreferringPlatformTransactionManager</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    TransactionInfo txInfo <span class="token operator">=</span> <span class="token function">createTransactionIfNecessary</span><span class="token punctuation">(</span>ptm<span class="token punctuation">,</span> txAttr<span class="token punctuation">,</span> joinpointIdentification<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object retVal<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        retVal <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceedWithInvocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">completeTransactionAfterThrowing</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">cleanupTransactionInfo</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token function">commitTransactionAfterReturning</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> retVal<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行过程很清晰，值得注意的是，在<code>completeTransactionAfterThrowing</code>中，并不一定直接回滚，如果发现当前异常非指定的rollback异常，则会直接<code>commit()</code>，再将异常抛到外部，你觉得此 <code>commit()</code>真的会成功吗？看下面场景5的结果吧！</p><p>再看下回滚事务的代码，位于抽象事务管理器<code>AbstractPlatformTransactionManager#processRollback</code>，有下面几种回滚原因</p><ul><li><p>原因一：如果事务设置了“save point”，即使用了<code>PROPAGATION_NESTED</code>嵌套事务的传播机制，则回滚到“save point”</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Rolling back transaction to savepoint"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  status<span class="token punctuation">.</span><span class="token function">rollbackToHeldSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>原因二：如果事务是新开事务（单一事务也算），则直接让该事务回滚</p><pre class=" language-java"><code class="language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Initiating transaction rollback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">doRollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>原因三：如果当前事务有回滚标志，或者当前事务开启了全局事务回滚</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isLocalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isGlobalRollbackOnParticipationFailure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Participating transaction failed - marking existing transaction as rollback-only"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">doSetRollbackOnly</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Participating transaction failed - letting transaction originator decide on rollback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>原因四：以上几种都属于上述步骤的第三步：异常则回滚事务，即在<code>commit()</code>之前就导致的异常回滚，而当在请求<code>commit()</code>时检测到全局事务被标记了<code>rollback-only</code>，这是一种不期望的行为，也会导致回滚</p></li></ul><p><code>commit()</code>过程的回滚代码，位于<code>AbstractPlatformTransactionManager#commit</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shouldCommitOnGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> defStatus<span class="token punctuation">.</span><span class="token function">isGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defStatus<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Global transaction is marked as rollback-only but transactional code requested commit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">processRollback</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在<code>AbstractPlatformTransactionManager#processRollback</code>中，会直接打印出错误信息：不期望的回滚异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>unexpectedRollback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnexpectedRollbackException</span><span class="token punctuation">(</span>            <span class="token string">"Transaction rolled back because it has been marked as rollback-only"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于这里使用的具体实现是<code>DataSourceTransactionManager</code>，故实际的回滚操作<code>doRollback</code>、<code>doSetRollbackOnly</code>将会在其中操作。</p><h2 id="结合代理操作过程得出实践场景结果"><a href="#结合代理操作过程得出实践场景结果" class="headerlink" title="结合代理操作过程得出实践场景结果"></a>结合代理操作过程得出实践场景结果</h2><h3 id="场景1（默认级别Propagation-REQUIRED）"><a href="#场景1（默认级别Propagation-REQUIRED）" class="headerlink" title="场景1（默认级别Propagation.REQUIRED）"></a>场景1（默认级别Propagation.REQUIRED）</h3><ul><li><p>结果：A/B都会回滚（从上一步分析得知，这里属于原因三的回滚行为）</p></li><li><p>总结：A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，则B方法会回滚，而因为和A方法处于同一事务，也导致A方法会回滚。</p></li></ul><h3 id="场景2（默认级别Propagation-REQUIRED）"><a href="#场景2（默认级别Propagation-REQUIRED）" class="headerlink" title="场景2（默认级别Propagation.REQUIRED）"></a>场景2（默认级别Propagation.REQUIRED）</h3><ul><li><p>结果：</p><ul><li>在A方法捕获：A、B会回滚（从上一步分析得知，这里属于原因四的回滚行为）</li><li>在B方法捕获：A、B不会回滚</li></ul></li><li><p>总结：</p><ul><li>A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，并在外层A方法捕获，则B方法会回滚，而因为和A方法的同一事务，也导致A方法会回滚（不管A方法是否有做捕获操作），此时会抛出”Transaction rolled back because it has been marked as rollback-only”</li><li>A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，并在内层捕获，则B方法不会回滚，A方法也不会回滚</li></ul></li></ul><h3 id="场景3（A：默认级别Propagation-REQUIRED，B：Propagation-REQUIRES-NEW）"><a href="#场景3（A：默认级别Propagation-REQUIRED，B：Propagation-REQUIRES-NEW）" class="headerlink" title="场景3（A：默认级别Propagation.REQUIRED，B：Propagation.REQUIRES_NEW）"></a>场景3（A：默认级别Propagation.REQUIRED，B：Propagation.REQUIRES_NEW）</h3><ul><li><p>结果：</p><ul><li>A方法一定不会回滚</li><li>在A方法捕获：B会回滚（从上一步分析得知，这里属于原因二的回滚行为）</li><li>在B方法捕获：B不会回滚</li></ul></li><li><p>总结：</p><ul><li>A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，并在外层A方法捕获，则B方法会回滚，但是因为和A方法不是同一事务，所以A方法不会回滚</li><li>A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，并在内层B方法捕获，则B方法不会回滚，A方法也不会回滚</li></ul></li></ul><h3 id="场景4（A：默认级别Propagation-REQUIRED，B：Propagation-REQUIRES-NEW）"><a href="#场景4（A：默认级别Propagation-REQUIRED，B：Propagation-REQUIRES-NEW）" class="headerlink" title="场景4（A：默认级别Propagation.REQUIRED，B：Propagation.REQUIRES_NEW）"></a>场景4（A：默认级别Propagation.REQUIRED，B：Propagation.REQUIRES_NEW）</h3><ul><li>结果：A/B方法都会回滚（从上一步分析得知，这里B方法的回滚属于原因二的回滚行为）</li></ul><p>可能有些人会有疑问，我已经将B方法设置为开启事务，怎么还会导致A方法回滚呢？<br>很简单，从A方法看起，它指定回滚的异常是<code>Exception</code>，而B方法抛出了NPE异常后又没有捕获，所以尽管B方法开启了新的事务，但是是由A发起的且抛出NPE异常，所以A方法也回滚了。<br>故可以换另一种角度，当A方法指定回滚异常是<code>RuntimeException</code>，而B方法回滚异常为非Runtime异常，此时可以发现A方法并不会回滚！并且B方法指定回滚异常也为<code>RuntimeException</code>，则B方法也不会回滚！</p><ul><li>总结：A类方法调用B类方法，且都开启事务，若B类方法抛出Runtime异常，则A、B方法都会回滚</li></ul><h3 id="场景5（默认级别Propagation-REQUIRED）"><a href="#场景5（默认级别Propagation-REQUIRED）" class="headerlink" title="场景5（默认级别Propagation.REQUIRED）"></a>场景5（默认级别Propagation.REQUIRED）</h3><ul><li>结果：两个方法同时指定回滚异常为RuntimeException，才不会回滚，否则都会回滚</li></ul><p>在上面事务执行过程中，讲到了当前异常非rollback异常时会直接<code>commit()</code>，而此次<code>commit()</code>会不会成功呢？答案是不一定！<br>如果A/B都在同个事务中，并且内层B方法指定异常为<code>RuntimeException</code>，而抛出异常为自定义异常，则会<code>commit()</code>，由于没有捕获异常，故无论外层A方法指定什么异常，A/B方法的业务操作都会一起被回滚！（从上一步分析得知，这里的回滚属于原因二的回滚行为）；那怎样才能让此次<code>commit()</code>成功呢，只要在内层B方法中进行捕获即可</p><ul><li>总结：<ul><li>A类方法(回滚异常为Exception)调用B类方法(回滚异常为RuntimeException)，且都开启事务，若B类方法抛出自定义异常(非Runtime)，则A、B都会回滚;</li><li>A类方法(回滚异常为Exception)调用B类方法(回滚异常为Exception)，且都开启事务，若B类方法抛出自定义异常(非Runtime)，则A、B都会回滚;</li><li>A类方法(回滚异常为RuntimeException)调用B类方法(回滚异常为Exception)，且都开启事务，若B类方法抛出自定义异常(非Runtime)，则A、B都会回滚;</li><li>A类方法(回滚异常为RuntimeException)调用B类方法(回滚异常为RuntimeException)，且都开启事务，若B类方法抛出自定义异常(非Runtime)，则B会回滚，A不会回滚</li></ul></li></ul><h3 id="场景6（默认级别Propagation-REQUIRED）"><a href="#场景6（默认级别Propagation-REQUIRED）" class="headerlink" title="场景6（默认级别Propagation.REQUIRED）"></a>场景6（默认级别Propagation.REQUIRED）</h3><ul><li>结果：不会回滚</li><li>总结：A类方法调用B类方法，且都开启事务，若B类方法抛出自定义异常并且捕获，则不会回滚</li></ul><h3 id="场景7（默认级别Propagation-REQUIRED）"><a href="#场景7（默认级别Propagation-REQUIRED）" class="headerlink" title="场景7（默认级别Propagation.REQUIRED）"></a>场景7（默认级别Propagation.REQUIRED）</h3><ul><li>结果：会回滚（从上一步分析得知，这里的回滚属于原因二的回滚行为）</li><li>总结：在同个类中a方法调用b方法，b方法不会开启新事务，即不会用到事务的传播机制</li></ul><h3 id="场景8（默认级别Propagation-REQUIRED）"><a href="#场景8（默认级别Propagation-REQUIRED）" class="headerlink" title="场景8（默认级别Propagation.REQUIRED）"></a>场景8（默认级别Propagation.REQUIRED）</h3><ul><li>结果：会回滚（从上一步分析得知，这里的回滚属于原因二的回滚行为）</li><li>总结：在同个类中a方法调用b方法，b方法无论设置什么都不会开启新事务，即不会用到事务的传播机制</li></ul><h2 id="事务管理范围"><a href="#事务管理范围" class="headerlink" title="事务管理范围"></a>事务管理范围</h2><p>前面讲了事务的传播机制，但是还有一点需要我们注意，即事务管理范围，也和我们日常开发息息相关，这里简单谈一下事务嵌套调用的情况。</p><p>假设serviceA/B，A方法开启了事务，B方法没有开启事务，此时A方法内部调用了B方法，那你认为A方法的事务是在调用B方法之前还是之后关闭？</p><p>看看栗子</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addUserV9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userChannelService<span class="token punctuation">.</span><span class="token function">pretendDelayAndError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserChannelServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserChannelService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pretendDelayAndError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"假装延时操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"在不同service内假装一个延时操作，并抛出Runtime异常，会回滚"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>得出结果</p><pre><code>Creating a new SqlSessionRegistering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7bac686b]JDBC Connection [HikariProxyConnection@1750490055 wrapping com.mysql.cj.jdbc.ConnectionImpl@37baddde] will be managed by Spring==&gt;  Preparing: SELECT user_id,create_time,name,age FROM user WHERE user_id=? ==&gt; Parameters: 1(Integer)&lt;==    Columns: user_id, create_time, name, age&lt;==        Row: 1, null, jerry, 22&lt;==      Total: 1Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7bac686b]假装延时操作Transaction synchronization deregistering SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7bac686b]Transaction synchronization closing SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7bac686b]java.lang.NullPointerException: 在不同service内假装一个延时操作，并抛出Runtime异常，会回滚</code></pre><p>可以看到，在调用B方法之前，事务开始释放，但是此时sqlSession还未关闭占用着，在调用完B方法后，才真正关闭事务中的sqlsession</p><p>业务中极易出现这种问题，进而发现数据库连接资源不够用。那怎么解决上述问题呢？</p><p>答案是service方法尽量不要嵌套调用，需要嵌套调用的可以放到外层，如控制层，或者接口调用。</p>]]></content>
      
      
      <categories>
          
          <category> SpringAOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码挖掘机（五）特性之多级缓存</title>
      <link href="/2020/08/15/mybatis-yuan-ma-wa-jue-ji-wu-te-xing-zhi-duo-ji-huan-cun/"/>
      <url>/2020/08/15/mybatis-yuan-ma-wa-jue-ji-wu-te-xing-zhi-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>Mybatis内置了一级缓存和二级缓存优化功能，默认开启一级缓存优化。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存默认开启，它有两个选项：SESSION（仅在一个事务内生效）、STATEMENT（仅在一个statement内生效，相当于没有一级缓存），默认是SESSION级别，作用区间SESSION大于STATEMENT。若要更改级别，可以做如下配置</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>Spring</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localCacheScope<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SESSION<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>Springboot</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span><span class="token key atrule">configuration</span><span class="token punctuation">:</span>  <span class="token key atrule">local-cache-scope</span><span class="token punctuation">:</span> STATEMENT</code></pre></li></ul><p>假设一级缓存设置为SESSION级别，在一次事务中，若用户多次查询条件完全相同的SQL，Mybatis在第二次查询时，会优先命中一级缓存，避免直接对数据库重复查询，以提高性能。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200814212637977_782334693.png" alt="只开启一级缓存"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>以上时序图逻辑在前面已经讲过了，这里只讲关于一级缓存的部分。<br>可以看到，关于缓存的部分，都集中在Executor内完成的，先看下关于缓存的方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建缓存key值</span>CacheKey <span class="token function">createCacheKey</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// key值是否存在缓存</span><span class="token keyword">boolean</span> <span class="token function">isCached</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> CacheKey key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 清除本地缓存</span><span class="token keyword">void</span> <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在一级缓存的操作中，主要涉及<code>BaseExecutor</code>和<code>Cache</code>两个类，</p><p>##<br><code>BaseExecutor</code>是<code>Executor</code>的抽象类，提供了一些基础实现和抽象类，具体的操作一般委派给子类执行</p><p>在执行阶段，所有子类的构造函数都会默认调用<code>BaseExecutor</code>的构造函数，此时默认创建的缓存实现是<code>PerpetualCache</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">BaseExecutor</span><span class="token punctuation">(</span>Configuration configuration<span class="token punctuation">,</span> Transaction transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>transaction <span class="token operator">=</span> transaction<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>deferredLoads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentLinkedQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>localCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerpetualCache</span><span class="token punctuation">(</span><span class="token string">"LocalCache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>localOutputParameterCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerpetualCache</span><span class="token punctuation">(</span><span class="token string">"LocalOutputParameterCache"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>closed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>configuration <span class="token operator">=</span> configuration<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>回看时序图，<code>Sqlsession</code> 将查询操作委派给了执行器Executor，如果只开启了一级缓存的话，会直接执行<code>BaseExecutor#query()</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    BoundSql boundSql <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getBoundSql</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>    CacheKey key <span class="token operator">=</span> <span class="token function">createCacheKey</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="生成key"><a href="#生成key" class="headerlink" title="生成key"></a>生成key</h4><p><code>createCacheKey</code>适用于一级和二级缓存，了解一下生成key 的逻辑，最终的cachekey主要由mapper方法全限定名、sql分页、sql语句、方法入参、环境id组成，每次调用<code>update()</code>都会将属性值放入成员变量<code>updateList</code>，用于后续校验key值<br>，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> CacheKey <span class="token function">createCacheKey</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorException</span><span class="token punctuation">(</span><span class="token string">"Executor was closed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    CacheKey cacheKey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CacheKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据mapper方法的全限定名更新cachekey</span>    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据sql分页信息更新cachekey</span>    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>rowBounds<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>rowBounds<span class="token punctuation">.</span><span class="token function">getLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据sql语句更新cachekey</span>    cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>boundSql<span class="token punctuation">.</span><span class="token function">getSql</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ......</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ParameterMapping parameterMapping <span class="token operator">:</span> parameterMappings<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterMapping<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ParameterMode<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ......</span>        <span class="token comment" spellcheck="true">// 根据参数更新cachekey</span>        cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 根据环境id更新cachekey</span>      cacheKey<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cacheKey<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="判断缓存是否相等"><a href="#判断缓存是否相等" class="headerlink" title="判断缓存是否相等"></a>判断缓存是否相等</h4><p><code>CacheKey</code>内部重写了<code>hashcode()</code>、<code>equals()</code>、<code>toString()</code>、<code>clone()</code>，这里只看一下<code>equals()</code>，<code>CacheKey</code>作为key值，如何判断两个<code>CacheKey</code>相等呢？</p><p>可以看到，相等的条件是：两个CacheKey中由createCacheKey中组成的<code>updateList()</code>中每一个都相等的话，则认定为相等。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">CacheKey</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将对象强转为CacheKey</span>    <span class="token keyword">final</span> CacheKey cacheKey <span class="token operator">=</span> <span class="token punctuation">(</span>CacheKey<span class="token punctuation">)</span> object<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hashcode <span class="token operator">!=</span> cacheKey<span class="token punctuation">.</span>hashcode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>checksum <span class="token operator">!=</span> cacheKey<span class="token punctuation">.</span>checksum<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">!=</span> cacheKey<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> updateList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Object thisObject <span class="token operator">=</span> updateList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      Object thatObject <span class="token operator">=</span> cacheKey<span class="token punctuation">.</span>updateList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ArrayUtil<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>thisObject<span class="token punctuation">,</span> thatObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="设置缓存"><a href="#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h4><p>先对当前key设置一个占位符，接着执行数据库查询操作，删除占位符，再接着设置执行数据到缓存，这个缓存仅在session内生效</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">queryFromDatabase</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> CacheKey key<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">;</span>    localCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> EXECUTION_PLACEHOLDER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      list <span class="token operator">=</span> <span class="token function">doQuery</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      localCache<span class="token punctuation">.</span><span class="token function">removeObject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    localCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前执行的是存储过程，则设置缓存到localOutputParameterCache</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getStatementType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> StatementType<span class="token punctuation">.</span>CALLABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>      localOutputParameterCache<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4><p>在查询得出结果后，如果当前一级缓存级别是STATEMENT，则立马将其清理掉</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> CacheKey key<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>configuration<span class="token punctuation">.</span><span class="token function">getLocalCacheScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> LocalCacheScope<span class="token punctuation">.</span>STATEMENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// issue #482</span>        <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>否则在<code>SqlSession.commit()</code>前清理掉</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> required<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorException</span><span class="token punctuation">(</span><span class="token string">"Cannot commit, transaction is already closed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">flushStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>required<span class="token punctuation">)</span> <span class="token punctuation">{</span>      transaction<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h4><p>在执行更新语句的时候，就会触发刷新缓存的操作</p><p>在更新前先清除缓存</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resource</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">activity</span><span class="token punctuation">(</span><span class="token string">"executing an update"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closed<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorException</span><span class="token punctuation">(</span><span class="token string">"Executor was closed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">clearLocalCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">doUpdate</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着通过<code>RoutingStatementHandler</code>委派给<code>PreparedStatementHandler</code>进行更新操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span>Statement statement<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    PreparedStatement ps <span class="token operator">=</span> <span class="token punctuation">(</span>PreparedStatement<span class="token punctuation">)</span> statement<span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rows <span class="token operator">=</span> ps<span class="token punctuation">.</span><span class="token function">getUpdateCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object parameterObject <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getParameterObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    KeyGenerator keyGenerator <span class="token operator">=</span> mappedStatement<span class="token punctuation">.</span><span class="token function">getKeyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    keyGenerator<span class="token punctuation">.</span><span class="token function">processAfter</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> mappedStatement<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rows<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Cache的实现"><a href="#Cache的实现" class="headerlink" title="Cache的实现"></a>Cache的实现</h4><p>一级缓存cache的实现是<code>org.apache.ibatis.cache.impl.PerpetualCache</code>，它本质上就是一个<code>HashMap</code>。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存默认关闭，若开启了默认先走二级缓存，再走一级缓存</p><p>一级缓存的缓存范围在SESSION级别，而<strong>二级缓存的缓存范围在于一个<code>namespace</code></strong>。 </p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><ul><li><p>Spring</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>Springboot</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span><span class="token key atrule">configuration</span><span class="token punctuation">:</span>  <span class="token key atrule">cache-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre></li></ul><p>在需要开启二级缓存的mapper.xml上，添加缓存节点配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.github.qjerry.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><p>了解下cache节点的属性，参考官网<a href="https://mybatis.org/mybatis-3/sqlmap-xml.html" target="_blank" rel="noopener">官网</a></p><ul><li><p>type：缓存类型，mybatis中默认是<code>org.apache.ibatis.cache.impl.PerpetualCache</code></p></li><li><p>eviction：逐出策略，默认LRU</p><ul><li>LRU，最近最少使用，删除最长时间未使用的对象</li><li>FIFO，先进先出，按照对象进入缓存的顺序来删除对象</li><li>SOFT，软引用，移除基于垃圾回收器状态和软引用规则删除对象</li><li>WEAK，弱引用，根据垃圾回收器状态和弱引用规则更积极地删除对象</li></ul></li><li><p>flushInterval：自动刷新缓存时间间隔，一般结合<code>ScheduledCache</code>使用，默认为null</p></li><li><p>size：最多存放的引用对象个数，对于LRUCache而言，默认是1024</p></li><li><p>readOnly：是否可读写，默认为false，即可读写。</p><ul><li>若设置为false（可读写），则在写入时进行序列化操作，在读取时进行反序列化操作，保证在读取时对缓存对象（可理解为副本）的修改，不会影响到缓存中的对象</li><li>若设置为true（仅可读），则不会有序列化操作，读取的是缓存的引用，此时对缓存对象引用的修改，会直接影响到其他地方读取缓存的操作，并发下不安全<br>故默认为可读写</li></ul></li><li><p>blocking：缓存命中释放锁，缓存未命中一直阻塞直到数据库获得结果，一般结合<code>BlockingCache</code>使用，默认为false</p></li></ul><p>默认空配置的话，则代表</p><ul><li>所有select语句被缓存，所有update语句被刷新</li><li>逐出策略采用LRU算法</li><li>不会自动刷新缓存</li><li>仅存放最多1024个引用对象</li><li>支持读写缓存</li><li>默认不阻塞</li></ul><p>这里有两点要注意</p><ul><li>以上配置都完成后，Mybatis-plus封装的查询方法，默认不会走二级缓存，需要额外配置</li><li>以上配置都完成后，若在同一事务内，不会走二级缓存，（开启了一级缓存则会走一级缓存）</li></ul><h3 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h3><p>先查询二级缓存，再查询一级缓存，否则查询数据库</p><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200815135902238_59044885.png" alt="开启二级缓存"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在二级缓存的操作中，主要涉及<code>CachingExecutor</code>、<code>BaseExecutor</code>和<code>Cache</code>三个类，一级缓存中，SqlSession都是直接调用<code>BaseExecutor</code>来做查询及缓存基础实现的，而在二级缓存中，<code>BaseExecutor</code>委派给了<code>CachingExecutor</code>，做二级缓存的实现</p><p>先看一下<code>CachingExecutor</code>主要的<code>query()</code>，先获取二级缓存的实现类，若不为空的话判断是否要刷新缓存，是否要使用二级缓存，再去实际调用底层的查询方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> CacheKey key<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span>      <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    Cache cache <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">flushCacheIfRequired</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">isUseCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> resultHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureNoOutParams</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        List<span class="token operator">&lt;</span>E<span class="token operator">></span> list <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">)</span> tcm<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          list <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>          tcm<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// issue #578 and #116</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> delegate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里可以看到，进入<code>query()</code>，入参有一个<code>MappedStatement</code>对象，它对应着一个mapper.xml，即一个命名空间<code>namespace</code>，故我们可以得出一个结论，二级缓存只适用于单个命名空间。</p><h4 id="生成key-1"><a href="#生成key-1" class="headerlink" title="生成key"></a>生成key</h4><p>和一级缓存的生成规则一样。</p><h4 id="强制刷新缓存、二次确认是否要使用二级缓存"><a href="#强制刷新缓存、二次确认是否要使用二级缓存" class="headerlink" title="强制刷新缓存、二次确认是否要使用二级缓存"></a>强制刷新缓存、二次确认是否要使用二级缓存</h4><p>若在<code>&lt;select&gt;</code>节点中配置了<code>flushCache</code>为true，则代表要强制刷新缓存，适用于更新操作后缓存中的旧数据不兼容导致脏数据的场景</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flushCacheIfRequired</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Cache cache <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ms<span class="token punctuation">.</span><span class="token function">isFlushCacheRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      tcm<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>若在<code>&lt;select&gt;</code>节点中配置了<code>useCache</code>为false，则不使用二级缓存，直接操作数据库</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">isUseCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> resultHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="委派模式设置待定缓存"><a href="#委派模式设置待定缓存" class="headerlink" title="委派模式设置待定缓存"></a>委派模式设置待定缓存</h4><p>默认情况下，开启了二级缓存后，在MappedStatement.Builder#cache打下断点，可以看到，此时缓存的组成如下图所示，利用了装饰器+委派模式，层层委派到最后一层即HashMap，来操作和获取缓存，注意，此时的缓存设置为待定缓存放在<code>TransactionalCache.entriesToAddOnCommit</code>中，实际设置是在<code>commit()</code>的时候</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    entriesToAddOnCommit<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中每个缓存实现都有对应的功能</p><ul><li>SynchronizedCache：同步缓存，在每个缓存操作方法上都上了<code>synchronized</code>锁</li><li>LoggingCache：记录日志，即开启了debug级别时，如果命中了缓存则将命中率输出</li><li>SerializedCache：序列化缓存，在缓存写入进行<code>serialize</code>，在缓存读取进行<code>deserialize</code></li><li>LruCache：lru算法，内部通过Map实现的<code>keyMap</code>，在每次设置缓存时用来记录缓存key值，如果此时存在需要丢弃的缓存标志<code>eldestKey</code>，则进行丢弃操作</li><li>PerpetualCache：最基础的缓存，通过HashMap实现</li></ul><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200815102913387_1650593310.png" alt="缓存装饰器"></p><p>最完整的缓存委派链为：<code>BlockingCache——&gt;SynchronizedCache——&gt;LoggineCache——&gt;SerializedCache——&gt;ScheduledCache——&gt;LruCache/FifoCache/SoftCache/WeakCache——&gt;PerpetualCache</code></p><h4 id="提交并设置缓存"><a href="#提交并设置缓存" class="headerlink" title="提交并设置缓存"></a>提交并设置缓存</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clearOnCommit<span class="token punctuation">)</span> <span class="token punctuation">{</span>      delegate<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">flushPendingEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在SqlSession提交的过程中，会调用<code>flushPendingEntries()</code>来刷新pending中的缓存对象，即存储在<code>TransactionalCache.entriesToAddOnCommit</code>中的key-value，接着将缓存对象一一通过委派模式，最终存储到最底层的缓存实现<code>PerpetualCache.cache</code>中，下一次获取缓存也是通过委派模式从<code>PerpetualCache.cache</code>中获取。</p><p>时序图如下<br><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200815162715539_2049243719.png" alt="提交操作"></p><p>回顾前文提到的“若在同一事务内，不会走二级缓存”，这里就给出答案了！<br>由于同一事务内，<code>SqlSession</code>不会在执行第一次查询操作后马上<code>commit()</code>，而上面提到了真正意义上的二级缓存设置是在<code>commit()</code>操作中，故无法实现二级缓存！</p><h4 id="清除缓存-1"><a href="#清除缓存-1" class="headerlink" title="清除缓存"></a>清除缓存</h4><p>和一级缓存的清除规则一样。</p><h4 id="刷新缓存-1"><a href="#刷新缓存-1" class="headerlink" title="刷新缓存"></a>刷新缓存</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token function">flushCacheIfRequired</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> delegate<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在执行更新语句的时候，默认会调用<code>flushCacheIfRequired()</code>删除二级缓存，除非在<code>&lt;insert&gt;</code>等节点中配置了<code>flushCache</code>为false，则不会删除二级缓存。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flushCacheIfRequired</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Cache cache <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ms<span class="token punctuation">.</span><span class="token function">isFlushCacheRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      tcm<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Mybatis-plus二级缓存"><a href="#Mybatis-plus二级缓存" class="headerlink" title="Mybatis-plus二级缓存"></a>Mybatis-plus二级缓存</h3><p>Mybatis-plus提供了多种内置方法来操作数据库，但是以上的二级环境配置方式对于内置方法是无法起作用的，它提供了另一种处理：添加注解</p><ul><li>添加配置<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span><span class="token key atrule">configuration</span><span class="token punctuation">:</span>  <span class="token key atrule">cache-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre></li><li>在mapper类上添加<code>@CacheNamespace</code>注解<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@CacheNamespace</span><span class="token punctuation">(</span>implementation <span class="token operator">=</span> PerpetualCache<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> eviction <span class="token operator">=</span> LruCache<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li>在mapper.xml上添加<cache-ref>节点，命名空间为以上添加了<code>@CacheNamespace</code>注解的mapper类<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>cache<span class="token operator">-</span>ref namespace<span class="token operator">=</span><span class="token string">"com.github.qjerry.mapper.UserMapper"</span><span class="token operator">/</span><span class="token operator">></span></code></pre></li></ul><h2 id="二级缓存优化"><a href="#二级缓存优化" class="headerlink" title="二级缓存优化"></a>二级缓存优化</h2><p>由于一级和二级缓存都作用于本地，这对于分布式服务架构来说，在某些场景下无疑是不适用的。比如服务A查询了一次数据，服务B开始修改同一份数据后，服务A再次以相同条件查询相同数据，此时会读缓存而不会读到最新数据。故实际使用时需要使用一些中间件如redis，来实现自定义缓存对象。</p><p>同时也可以基于Spring提供的缓存机制来实现，之前写过几篇《Spring缓存挖掘机》系列，就是基于Spring的缓存机制，实现了本地 + redis分布式缓存，具体可以看下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一级缓存中，默认开启SESSION级别</li><li>二级缓存中，Mybatis需要在mapper.xml中配置<code>&lt;cache /&gt;</code>，而对于Mybatis-plus的内置方法默认不支持二级缓存，需要显示开启<code>@CacheNamespace</code>注解，和mapper.xml中通过<code>&lt;cache-ref&gt;</code>来关联注解mapper类</li><li>二级缓存中，多个namespace中，需要通过<code>&lt;cache-ref&gt;</code>来关联，才能共享二级缓存</li><li>一级缓存作用在事务范围内，二级缓存作用在单个命名空间范围内</li><li>单服务架构中，建议开启一级缓存，提升性能</li><li>微服务架构中，不建议开启一级缓存，会造成脏数据，对于二级缓存，可以改成redis来重写缓存实现，否则也不建议开启</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码挖掘机（四）特性之动态代理</title>
      <link href="/2020/08/15/mybatis-yuan-ma-wa-jue-ji-si-te-xing-zhi-dong-tai-dai-li/"/>
      <url>/2020/08/15/mybatis-yuan-ma-wa-jue-ji-si-te-xing-zhi-dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h3><p>Mybatis中使用<code>MapperProxyFactory</code>作为Mapper工厂代理类，为每个mapper类生成了代理类对象<code>MapperProxy</code>。</p><h4 id="工厂类MapperProxyFactory"><a href="#工厂类MapperProxyFactory" class="headerlink" title="工厂类MapperProxyFactory"></a>工厂类MapperProxyFactory</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperProxyFactory</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> mapperInterface<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Method<span class="token punctuation">,</span> MapperMethodInvoker<span class="token operator">></span> methodCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">MapperProxyFactory</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> mapperInterface<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mapperInterface <span class="token operator">=</span> mapperInterface<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getMapperInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mapperInterface<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>Method<span class="token punctuation">,</span> MapperMethodInvoker<span class="token operator">></span> <span class="token function">getMethodCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> methodCache<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>  <span class="token keyword">protected</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>MapperProxy<span class="token operator">&lt;</span>T<span class="token operator">></span> mapperProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>mapperInterface<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> mapperInterface <span class="token punctuation">}</span><span class="token punctuation">,</span> mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>SqlSession sqlSession<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> MapperProxy<span class="token operator">&lt;</span>T<span class="token operator">></span> mapperProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperProxy</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> mapperInterface<span class="token punctuation">,</span> methodCache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">newInstance</span><span class="token punctuation">(</span>mapperProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>程序是怎么调度<code>MapperProxyFactory</code>这个工厂类的呢，回顾一下Mybatis构建阶段，在构建<code>XMLMapperBuilder</code>的时候，调用<code>MapperRegistry</code>注册了mapper，在<code>org.apache.ibatis.binding.MapperRegistry#addMapper</code>方法中，其中每次注册一个mapper都会给不可变成员变量<code>knownMappers</code>添加一个Entry，key为mapper的class类对象，value为mapper代理工厂<code>MapperProxyFactory</code>。</p><p>在后续Spring项目启动，加载每个bean时，将会调用<code>org.apache.ibatis.binding.MapperRegistry#getMapper</code>方法，根据Class对象从<code>knownMappers</code>中获取mapper代理工厂<code>MapperProxyFactory</code>，并用于动态创建代理实例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getMapper</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">,</span> SqlSession sqlSession<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> MapperProxyFactory<span class="token operator">&lt;</span>T<span class="token operator">></span> mapperProxyFactory <span class="token operator">=</span> <span class="token punctuation">(</span>MapperProxyFactory<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> knownMappers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapperProxyFactory <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Type "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">" is not known to the MapperRegistry."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//</span>      <span class="token keyword">return</span> mapperProxyFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Error getting mapper instance. Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="代理类MapperProxy"><a href="#代理类MapperProxy" class="headerlink" title="代理类MapperProxy"></a>代理类MapperProxy</h4><p><code>MapperProxy</code>实现了<code>InvocationHandler</code>接口，具体的作用是什么呢？</p><p>当我们调用一个mapper接口方法的时候，Mybatis会先将mapper方法代理给<code>MapperProxy</code>，通过<code>invoke()</code>将方法包装成了<code>MapperMethod</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> SqlSession sqlSession<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    <span class="token keyword">return</span> mapperMethod<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为什么mapper方法和mapper.xml文件能够映射成功，就是<code>MapperMethod</code>协助串联的，它拿到mapper方法的全限定名和方法参数，去匹配mapper.xml中的namespace和对应的XNode节点。</p><p>程序一直执行到这里，会根据全限定名从configuration中获取映射的MappedStatement对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      MappedStatement ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> executor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> Executor<span class="token punctuation">.</span>NO_RESULT_HANDLER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> ExceptionFactory<span class="token punctuation">.</span><span class="token function">wrapException</span><span class="token punctuation">(</span><span class="token string">"Error querying database.  Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着从MappedStatement映射对象中获得BoundSql对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> BoundSql <span class="token function">getBoundSql</span><span class="token punctuation">(</span>Object parameterObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    BoundSql boundSql <span class="token operator">=</span> sqlSource<span class="token punctuation">.</span><span class="token function">getBoundSql</span><span class="token punctuation">(</span>parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>ParameterMapping<span class="token operator">></span> parameterMappings <span class="token operator">=</span> boundSql<span class="token punctuation">.</span><span class="token function">getParameterMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parameterMappings <span class="token operator">==</span> null <span class="token operator">||</span> parameterMappings<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      boundSql <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BoundSql</span><span class="token punctuation">(</span>configuration<span class="token punctuation">,</span> boundSql<span class="token punctuation">.</span><span class="token function">getSql</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parameterMap<span class="token punctuation">.</span><span class="token function">getParameterMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// check for nested result maps in parameter mappings (issue #30)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ParameterMapping pm <span class="token operator">:</span> boundSql<span class="token punctuation">.</span><span class="token function">getParameterMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      String rmId <span class="token operator">=</span> pm<span class="token punctuation">.</span><span class="token function">getResultMapId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>rmId <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ResultMap rm <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getResultMap</span><span class="token punctuation">(</span>rmId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          hasNestedResultMaps <span class="token operator">|=</span> rm<span class="token punctuation">.</span><span class="token function">hasNestedResultMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> boundSql<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="SqlSessionInterceptor"><a href="#SqlSessionInterceptor" class="headerlink" title="SqlSessionInterceptor"></a>SqlSessionInterceptor</h3><p>作为Mybatis和Spring的胶水层，每次在调用<code>SqlSession</code>的方法时，会先给<code>SqlSessionInterceptor</code>代理执行。在执行SqlSession的方法前，先创建一个真正意义上用来执行的SqlSession，接着才开始调用<code>SqlSession</code>的方法，执行完后提交此次执行请求。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      SqlSession sqlSession <span class="token operator">=</span> <span class="token function">getSqlSession</span><span class="token punctuation">(</span>SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">,</span>          SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>executorType<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSqlSessionTransactional</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// force commit even on non-dirty sessions because some databases require</span>          <span class="token comment" spellcheck="true">// a commit/rollback before calling close()</span>          sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Throwable unwrapped <span class="token operator">=</span> <span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> unwrapped <span class="token keyword">instanceof</span> <span class="token class-name">PersistenceException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>          sqlSession <span class="token operator">=</span> null<span class="token punctuation">;</span>          Throwable translated <span class="token operator">=</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator              <span class="token punctuation">.</span><span class="token function">translateExceptionIfPossible</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PersistenceException<span class="token punctuation">)</span> unwrapped<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>translated <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            unwrapped <span class="token operator">=</span> translated<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> unwrapped<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSession <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Cglib动态代理和Javassist动态代理"><a href="#Cglib动态代理和Javassist动态代理" class="headerlink" title="Cglib动态代理和Javassist动态代理"></a>Cglib动态代理和Javassist动态代理</h2><p>Mybatis使用这两者实现了懒加载机制。</p><p>在上一篇《Mybatis源码挖掘机（二）执行阶段》中讲到，在执行sql语句并获得结果集的时候，Mybatis会对结果集进行处理<code>DefaultResultSetHandler#handleResultSets</code>，转换成<code>List&lt;Object&gt;</code>，在其中就用到了懒加载机制。</p><p>在处理链路中，最后会来到以下方法，创建返回结果集</p><p>判断当前结果<code>resultObject</code>是否为空，当前结果类型中是否有嵌套结果（嵌套结果集可以看下面延迟加载的描述），有的话再轮询结果集的每个属性，判断是否开启了懒加载机制。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">createResultObject</span><span class="token punctuation">(</span>ResultSetWrapper rsw<span class="token punctuation">,</span> ResultMap resultMap<span class="token punctuation">,</span> ResultLoaderMap lazyLoader<span class="token punctuation">,</span> String columnPrefix<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>useConstructorMappings <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// reset previous mapping result</span>    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> constructorArgTypes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> constructorArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object resultObject <span class="token operator">=</span> <span class="token function">createResultObject</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">,</span> columnPrefix<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resultObject <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasTypeHandlerForResultObject</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> List<span class="token operator">&lt;</span>ResultMapping<span class="token operator">></span> propertyMappings <span class="token operator">=</span> resultMap<span class="token punctuation">.</span><span class="token function">getPropertyResultMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>ResultMapping propertyMapping <span class="token operator">:</span> propertyMappings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>propertyMapping<span class="token punctuation">.</span><span class="token function">getNestedQueryId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> propertyMapping<span class="token punctuation">.</span><span class="token function">isLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          resultObject <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>resultObject<span class="token punctuation">,</span> lazyLoader<span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> objectFactory<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>useConstructorMappings <span class="token operator">=</span> resultObject <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>constructorArgTypes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// set current mapping result</span>    <span class="token keyword">return</span> resultObject<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>这里用到了<code>ProxyFactory</code>代理工厂类，它有两个方法，<code>setProperties</code>默认是空方法，<code>createProxy</code>即创建代理对象，在上面的代码块中，就使用了<code>createProxy</code>创建了内嵌结果集的代理对象<code>resultObject</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>  <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">setProperties</span><span class="token punctuation">(</span>Properties properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// NOP</span>  <span class="token punctuation">}</span>  Object <span class="token function">createProxy</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> ResultLoaderMap lazyLoader<span class="token punctuation">,</span> Configuration configuration<span class="token punctuation">,</span> ObjectFactory objectFactory<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> constructorArgTypes<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>ProxyFactory</code>有两个实现类，默认的实现类是<code>JavassistProxyFactory</code></p><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200813173847388_1773920990.png" alt="ProxyFactory子类"></p><p>若要指定<code>CglibProxyFactory</code>，则需要添加cglib的lib包，并且在配置文件中配置proxyFactory</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>proxyFactory<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CGLIB<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h3 id="CglibProxyFactory"><a href="#CglibProxyFactory" class="headerlink" title="CglibProxyFactory"></a>CglibProxyFactory</h3><p>基于cglib动态代理模式，继承父类生成动态代理（子）类，看一下创建代理类的方法</p><h4 id="依赖资源检查"><a href="#依赖资源检查" class="headerlink" title="依赖资源检查"></a>依赖资源检查</h4><p>Mybatis中会开启代理实现依赖检查，若资源目录未找到该依赖，则直接报错，cglib需要手动添加依赖</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CglibProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      Resources<span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span><span class="token string">"net.sf.cglib.proxy.Enhancer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath."</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>Cglib 实际上也用到静态内部类<code>EnhancedResultObjectProxyImpl</code>的<code>createProxy()</code>方法</p><ul><li>先创建一个回调对象callback，用于在目标类的方法调用中，拦截对目标方法的调用，拦截方法就是代理入口<code>intercept()</code>，</li><li>生成一个目标对象的增强型代理对象<code>enhanced</code></li><li>将目标对象的属性拷贝到增强型的代理对象<code>enhanced</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">createProxy</span><span class="token punctuation">(</span>Object target<span class="token punctuation">,</span> ResultLoaderMap lazyLoader<span class="token punctuation">,</span> Configuration configuration<span class="token punctuation">,</span> ObjectFactory objectFactory<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> constructorArgTypes<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> constructorArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> type <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 带入目标类type，懒加载属性集合lazyLoader，Configuration对象、构造方法参数类型组constructorArgTypes，构造方法参数值组constructorArgs</span>      EnhancedResultObjectProxyImpl callback <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnhancedResultObjectProxyImpl</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> lazyLoader<span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> objectFactory<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>      Object enhanced <span class="token operator">=</span> <span class="token function">crateProxy</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>      PropertyCopier<span class="token punctuation">.</span><span class="token function">copyBeanProperties</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> target<span class="token punctuation">,</span> enhanced<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> enhanced<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="代理入口"><a href="#代理入口" class="headerlink" title="代理入口"></a>代理入口</h4><p>详细看上一篇《Mybatis源码挖掘机（三）特性之延迟加载》的<strong>原理</strong>部分，就是调用了代理方法<code>invoke()</code>去实现懒加载机制</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object enhanced<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ......</span><span class="token punctuation">}</span></code></pre><h3 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h3><p>基于javassist方式，直接修改class文件的字节码格式，看一下创建代理类的方法，实际上用到静态内部类<code>EnhancedResultObjectProxyImpl</code>的<code>createProxy()</code>方法。</p><h4 id="依赖资源检查-1"><a href="#依赖资源检查-1" class="headerlink" title="依赖资源检查"></a>依赖资源检查</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">JavassistProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      Resources<span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span><span class="token string">"javassist.util.proxy.ProxyFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Cannot enable lazy loading because Javassist is not available. Add Javassist to your classpath."</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="创建代理对象-1"><a href="#创建代理对象-1" class="headerlink" title="创建代理对象"></a>创建代理对象</h4><p>和cglib逻辑一样</p><h4 id="代理入口-1"><a href="#代理入口-1" class="headerlink" title="代理入口"></a>代理入口</h4><p>详细看上一篇《Mybatis源码挖掘机（三）特性之延迟加载》的<strong>原理</strong>部分，这里就是调用了代理方法<code>invoke()</code>去实现懒加载机制</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object enhanced<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Method methodProxy<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ......</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码挖掘机（三）特性之延迟加载</title>
      <link href="/2020/08/15/mybatis-yuan-ma-wa-jue-ji-san-te-xing-zhi-yan-chi-jia-zai/"/>
      <url>/2020/08/15/mybatis-yuan-ma-wa-jue-ji-san-te-xing-zhi-yan-chi-jia-zai/</url>
      
        <content type="html"><![CDATA[<p>分为直接加载，侵入式加载，深度加载，懒惰级别依次上升</p><p>懒加载通常用于在获得结果集后的处理，前提如下</p><ul><li>开启懒加载开关，全局开启或者mapper.xml局部开启</li><li>查询结果必须是嵌套结果集，其中内嵌结果集使用<code>association</code>标签(一对一关联)、<code>collection</code>标签(一对多关联) 配置</li></ul><h2 id="全局开启懒加载"><a href="#全局开启懒加载" class="headerlink" title="全局开启懒加载"></a>全局开启懒加载</h2><h3 id="Spring-XML配置"><a href="#Spring-XML配置" class="headerlink" title="Spring XML配置"></a>Spring XML配置</h3><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- &lt;setting name="aggressiveLazyLoading" value="false"/> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h3 id="Springboot-配置文件"><a href="#Springboot-配置文件" class="headerlink" title="Springboot 配置文件"></a>Springboot 配置文件</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">lazy-loading-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true">#    aggressive-lazy-loading: true</span></code></pre><p>注意以上两个属性</p><ul><li><code>lazyLoadingEnabled</code>：懒加载的总开关</li><li><code>aggressiveLazyLoading</code><br>true代表侵入式开关开启，当访问结果集的任一属性则会开始查询<br>false代表深度延迟开关开启，当直接访问内嵌结果集时，才开始查询</li></ul><h2 id="局部开启懒加载"><a href="#局部开启懒加载" class="headerlink" title="局部开启懒加载"></a>局部开启懒加载</h2><p>在结果集映射中的<code>association</code>节点 或 <code>collection</code>节点 配置<code>fetchType</code>属性，属性值有</p><ul><li><code>eager</code>：饥饿加载，即执行完主语句后马上执行嵌套语句</li><li><code>lazy</code>：深度延迟加载<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userDetail<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.UserDetail<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.UserDetailMapper.selectByPrimaryKey<span class="token punctuation">"</span></span> <span class="token attr-name">fetchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>假设开启<strong>深度延迟加载</strong>，即直接访问内嵌结果集时，才开始查询</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">lazy-loading-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">aggressive-lazy-loading</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre><h3 id="结果集映射"><a href="#结果集映射" class="headerlink" title="结果集映射"></a>结果集映射</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserResultMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.UserBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INTEGER<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userDetail<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.UserDetail<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx.UserDetailMapper.selectByPrimaryKey<span class="token punctuation">"</span></span> <span class="token attr-name">fetchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span></code></pre><h3 id="SQL-mapper"><a href="#SQL-mapper" class="headerlink" title="SQL mapper"></a>SQL mapper</h3><pre class=" language-java"><code class="language-java">UserBean <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span> Integer userId<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserResultMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select user_id, name from User where id = #{userId};<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UserBean userBean <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"休息一下"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userBean<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"再休息一下"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userBean<span class="token punctuation">.</span><span class="token function">getUserDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>测试输出</p><pre><code>----------------- 2020-08-13 16:27:33 DEBUG c.a.d.a.m.O.selectById - ==&gt;  Preparing: select id, name from user where id = ?;----------------- 2020-08-13 16:27:33 DEBUG c.a.d.a.m.O.selectById - ==&gt; Parameters: 1(Integer)----------------- 2020-08-13 16:27:34 DEBUG c.a.d.a.m.O.selectById - &lt;==      Total: 1休息一下1再休息一下----------------- 2020-08-13 16:27:44 DEBUG c.a.d.a.m.O.selectByPrimaryKey - ==&gt;  Preparing: select id, address, phone, create_time from user_detail where user_id = ?----------------- 2020-08-13 16:27:44 DEBUG c.a.d.a.m.O.selectByPrimaryKey - ==&gt; Parameters: 1(Integer)----------------- 2020-08-13 16:27:46 DEBUG c.a.d.a.m.O.selectByPrimaryKey - &lt;==      Total: 1</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Mybatis的懒加载机制是在动态代理模式中处理的，对于开启了懒加载的实体属性，则需要启用动态代理进行预处理和懒加载操作<br>代码在<code>DefaultResultSetHandler#createResultObject()</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>ResultMapping propertyMapping <span class="token operator">:</span> propertyMappings<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>propertyMapping<span class="token punctuation">.</span><span class="token function">getNestedQueryId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> propertyMapping<span class="token punctuation">.</span><span class="token function">isLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      resultObject <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>resultObject<span class="token punctuation">,</span> lazyLoader<span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> objectFactory<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在代理模式中，要注意的是，Mybatis支持序列化与反序列化，那么怎么能够保证序列化和反序列化的对象还能够支持懒加载？<br>Mybatis在代理中做了兼容处理</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object enhanced<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Method methodProxy<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      <span class="token keyword">final</span> String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 如果当前正在调用writeReplace，则说明在进行序列化，对于代理对象进行序列化是不合理的，需要做的是返回一个原始对象出去</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>WRITE_REPLACE_METHOD<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object original<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 创建一个新的原始对象</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>constructorArgTypes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              original <span class="token operator">=</span> objectFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              original <span class="token operator">=</span> objectFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 复制属性到新的原始对象中</span>            PropertyCopier<span class="token punctuation">.</span><span class="token function">copyBeanProperties</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> enhanced<span class="token punctuation">,</span> original<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果存在懒加载对象，则返回一个新的代理对象</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JavassistSerialStateHolder</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> lazyLoader<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> objectFactory<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 直接返回新的原始对象</span>              <span class="token keyword">return</span> original<span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当前没进行序列化操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>FINALIZE_METHOD<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 如果存在懒加载对象，并且非finalize方法（用于清除对象操作）</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>aggressive <span class="token operator">||</span> lazyLoadTriggerMethods<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果aggressiveLazyLoading设置为true，或者是hashcode、equals、clone、toString的方法，则会触发获取整个实体对象</span>                lazyLoader<span class="token punctuation">.</span><span class="token function">loadAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>PropertyNamer<span class="token punctuation">.</span><span class="token function">isSetter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用set方法设置属性值，此时需要从懒加载器中移除该参数，预防重新执行懒加载</span>                <span class="token keyword">final</span> String property <span class="token operator">=</span> PropertyNamer<span class="token punctuation">.</span><span class="token function">methodToProperty</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                lazyLoader<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>PropertyNamer<span class="token punctuation">.</span><span class="token function">isGetter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用get方法获取属性值，判断是否懒加载，是的话则进行懒加载逻辑，实际上是去执行SQL查询</span>                <span class="token keyword">final</span> String property <span class="token operator">=</span> PropertyNamer<span class="token punctuation">.</span><span class="token function">methodToProperty</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">.</span><span class="token function">hasLoader</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  lazyLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>enhanced<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> ExceptionUtil<span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码中，<code>lazyLoader.loadAll()</code>和<code>lazyLoader.load()</code>，最近会重新调用执行器查询方法Executor.selectList()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    Executor localExecutor <span class="token operator">=</span> executor<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>creatorThreadId <span class="token operator">||</span> localExecutor<span class="token punctuation">.</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      localExecutor <span class="token operator">=</span> <span class="token function">newExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> localExecutor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>mappedStatement<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> RowBounds<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">,</span> Executor<span class="token punctuation">.</span>NO_RESULT_HANDLER<span class="token punctuation">,</span> cacheKey<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>localExecutor <span class="token operator">!=</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        localExecutor<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码挖掘机（二）执行阶段</title>
      <link href="/2020/08/15/mybatis-yuan-ma-wa-jue-ji-er-zhi-xing-jie-duan/"/>
      <url>/2020/08/15/mybatis-yuan-ma-wa-jue-ji-er-zhi-xing-jie-duan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下面基于mybatis-spring讲解其执行阶段</p></blockquote><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><blockquote><p>SQL语言分为数据查询语言（DQL）、数据操作语言（DML）、事务处理语言（TPL）、数据控制语言（DCL）、数据定义语言（DDL）、指针控制语言（CCL）。</p></blockquote><h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><p>Mybatis执行阶段有一些关键组件，在这里先梳理一下</p><ul><li>SqlSession：Mybatis核心执行入口，默认实现为DefaultSqlSession，mybatis-spring中也被实现为SqlSessionTemplate。该接口提供了很多SQL调用方法。</li><li>Configuration：保存构建阶段的结果，也负责在执行阶段初始化需要的变量</li><li>MappedStatement：配置好映射的SQL语句</li><li>BoundSql：SQL的抽象，存放执行SQL的内容</li><li>Executor：SQL执行器，其抽象类BaseExecutor 有多个实现</li><li>StatementHandler：处理SQL语句的管理器接口</li><li>Statement：JDK中提供的执行数据库操作的重要接口，发送SQL命令到数据库中，并从数据库中获得数据</li><li>ResultSetHandler：处理结果集的管理器接口</li></ul><h2 id="关键接口及默认实现初始化"><a href="#关键接口及默认实现初始化" class="headerlink" title="关键接口及默认实现初始化"></a>关键接口及默认实现初始化</h2><h3 id="SQLSession"><a href="#SQLSession" class="headerlink" title="SQLSession"></a>SQLSession</h3><p>作为mybatis最核心的接口，封装了<code>selectOne()</code>、<code>selectList()</code>等的DQL方法，<code>insert()</code>、<code>update()</code>等的DML方法和<code>commit()</code>等的TPL方法。<br>它的实例化用到了工厂类<code>SqlSessionFactory</code>，默认实现类是DefaultSqlSessionFactory。另一个子类是SqlSessionManager，它利用Threadlocal和代理拦截，保障了线程安全、支持自动重连的SqlSession。</p><p>在集成mybaits-spring的应用中，程序启动时会先创建一个<code>SqlSessionTemplate</code>，它实现了SqlSession接口，故我们可以使用它来替代DefaultSqlSession 对数据库的操作，这是mybatis和spring实现结合的重要机制。而在实际执行SQL语句时，我们会在<code>SqlSessionInterceptor</code>中创建一个真正使用的SqlSession，此时真正意义上去调用JDBC接口获取数据。</p><h2 id="DQL语句执行"><a href="#DQL语句执行" class="headerlink" title="DQL语句执行"></a>DQL语句执行</h2><p>这里以SqlSession#selectList()作为例子分析Mybatis的一次查询过程<br>需要注意的下面讲述都是基于mybatis-spring实现</p><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200809230855352_1751396532.png" alt="DefaultResultSetHandler"></p><h3 id="程序执行查询入口SqlSessionTemplate-selectList"><a href="#程序执行查询入口SqlSessionTemplate-selectList" class="headerlink" title="程序执行查询入口SqlSessionTemplate#selectList"></a>程序执行查询入口SqlSessionTemplate#selectList</h3><blockquote><p>在原生Mybatis中，默认的查询入口是DefaultSqlSession#selectList()，而在mybatis-spring中，使用SqlSessionTemplate模板类实现了SqlSession的功能。<br>Spring使用动态代理为SqlSession添加SqlSessionInterceptor拦截功能，实现了Mybatis事务与Spring的集成。</p></blockquote><p>从上面时序图可以看出，执行具体的mapper方法时</p><ul><li>首先通过mapper代理类MapperProxy 进行代理，代理逻辑<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果是Object类的方法，则直接反射调用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">cachedInvoker</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> sqlSession<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> ExceptionUtil<span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>接着通过反射调用：MapperMethod#execute()</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PlainMethodInvoker</span> <span class="token keyword">implements</span> <span class="token class-name">MapperMethodInvoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> MapperMethod mapperMethod<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">PlainMethodInvoker</span><span class="token punctuation">(</span>MapperMethod mapperMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>mapperMethod <span class="token operator">=</span> mapperMethod<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> SqlSession sqlSession<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      <span class="token keyword">return</span> mapperMethod<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>根据不同的语句类型调用相应的处理逻辑：MapperMethod#execute</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">execute</span><span class="token punctuation">(</span>SqlSession sqlSession<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Object result<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> SELECT<span class="token operator">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsVoid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> method<span class="token punctuation">.</span><span class="token function">hasResultHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">executeWithResultHandler</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>          result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsMany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          result <span class="token operator">=</span> <span class="token function">executeForMany</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          result <span class="token operator">=</span> <span class="token function">executeForMap</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsCursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          result <span class="token operator">=</span> <span class="token function">executeForCursor</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          Object param <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">convertArgsToSqlCommandParam</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>          result <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">returnsOptional</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// ....</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>最终调用底层的SqlSession的DQL语句真正执行：<code>SqlSessionTemplate#selectList</code></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> Object parameter<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionProxy<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>statement<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在<code>SqlSessionTemplate</code>初始化时，调用了<code>newProxyInstance()</code>方法，完成了<code>sqlSessionProxy</code>代理类<code>SqlSessionInterceptor</code>的实例化操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">SqlSessionTemplate</span><span class="token punctuation">(</span>SqlSessionFactory sqlSessionFactory<span class="token punctuation">,</span> ExecutorType executorType<span class="token punctuation">,</span>      PersistenceExceptionTranslator exceptionTranslator<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">notNull</span><span class="token punctuation">(</span>sqlSessionFactory<span class="token punctuation">,</span> <span class="token string">"Property 'sqlSessionFactory' is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">notNull</span><span class="token punctuation">(</span>executorType<span class="token punctuation">,</span> <span class="token string">"Property 'executorType' is required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>executorType <span class="token operator">=</span> executorType<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator <span class="token operator">=</span> exceptionTranslator<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 代理类SqlSessionInterceptor实例化操作</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionProxy <span class="token operator">=</span> <span class="token punctuation">(</span>SqlSession<span class="token punctuation">)</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span>SqlSessionFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> SqlSession<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而<code>sqlSessionProxy</code>本质上就是<code>SqlSession</code>，定义了方法拦截器，每当调用<code>SqlSession</code>方法时，会先代理给<code>SqlSessionInterceptor</code>执行<code>invoke()</code>，此时会创建一个真正意义上的Sqlession，大概的执行内容大致是创建session，执行sql，提交等过程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 创建一个session</span>      SqlSession sqlSession <span class="token operator">=</span> <span class="token function">getSqlSession</span><span class="token punctuation">(</span>SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">,</span>          SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>executorType<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSqlSessionTransactional</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// force commit even on non-dirty sessions because some databases require</span>          <span class="token comment" spellcheck="true">// a commit/rollback before calling close()</span>          sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Throwable unwrapped <span class="token operator">=</span> <span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> unwrapped <span class="token keyword">instanceof</span> <span class="token class-name">PersistenceException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>          sqlSession <span class="token operator">=</span> null<span class="token punctuation">;</span>          Throwable translated <span class="token operator">=</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>exceptionTranslator              <span class="token punctuation">.</span><span class="token function">translateExceptionIfPossible</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PersistenceException<span class="token punctuation">)</span> unwrapped<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>translated <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            unwrapped <span class="token operator">=</span> translated<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> unwrapped<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sqlSession <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">closeSqlSession</span><span class="token punctuation">(</span>sqlSession<span class="token punctuation">,</span> SqlSessionTemplate<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="SQL执行真正入口：Mybatis与Spring结合的胶水层"><a href="#SQL执行真正入口：Mybatis与Spring结合的胶水层" class="headerlink" title="SQL执行真正入口：Mybatis与Spring结合的胶水层"></a>SQL执行真正入口：Mybatis与Spring结合的胶水层</h3><p>在前面通过<code>SqlSessionInterceptor</code>代理执行操作，封装了创建session，执行sql，提交等。其中执行sql是反射调用了<code>DefaultSqlSession#selectList</code></p><p><code>DefaultSqlSession</code>中的<code>selectList</code>做了两件事</p><ul><li>使用<code>statement</code>作为key值，从<code>configuration</code>中维护的映射关系<code>mappedStatements</code>中获得映射的<code>MappedStatement</code>执行对象</li><li>调用Executor#query()准备执行</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      MappedStatement ms <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span>statement<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> executor<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> <span class="token function">wrapCollection</span><span class="token punctuation">(</span>parameter<span class="token punctuation">)</span><span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> Executor<span class="token punctuation">.</span>NO_RESULT_HANDLER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> ExceptionFactory<span class="token punctuation">.</span><span class="token function">wrapException</span><span class="token punctuation">(</span><span class="token string">"Error querying database.  Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在执行真正查询入口前，会调用<code>configuration.getMappedStatement</code>获得执行对象，其中会再次校验是否有在构建阶段出现异常而保存的各种处理器，如异常的缓存引用、异常的statement、异常的mapper方法、异常的结果集映射等等，最终保证<code>mappedStatement</code>执行对象的正确性，如果仍无法解决异常，将会触发快速失败。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">buildAllStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">parsePendingResultMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>incompleteCacheRefs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>incompleteCacheRefs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        incompleteCacheRefs<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">.</span><span class="token function">resolveCacheRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>incompleteStatements<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>incompleteStatements<span class="token punctuation">)</span> <span class="token punctuation">{</span>        incompleteStatements<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          x<span class="token punctuation">.</span><span class="token function">parseStatementNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>incompleteMethods<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>incompleteMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>        incompleteMethods<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>          x<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h3 id="执行器查询：Executor-query"><a href="#执行器查询：Executor-query" class="headerlink" title="执行器查询：Executor#query()"></a>执行器查询：Executor#query()</h3><p>这里的<code>Executor</code>不等同于jdk自带的<code>Executor</code>，可以理解为它就是mybatis提供的执行器接口，封装了常用的query()、update()接口等。</p><p><code>Executor</code>中有两种<code>query()</code>的重载方法，<code>DefaultSqlSession</code>开始调用<code>Executor</code>查询方法时，</p><h4 id="首先进入的是第一层query"><a href="#首先进入的是第一层query" class="headerlink" title="首先进入的是第一层query()"></a>首先进入的是第一层query()</h4><p>通过<code>MappedStatement</code>获取<code>BoundSql</code>对象，再生成当次调用的<code>CacheKey</code>对象，最终将两者传入第二层<code>query()</code></p><p>需要注意的是，<code>CacheKey</code>中，mybatis重写了<code>equals()</code>和<code>hashCode()</code>，作用在于后续的缓存处理</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    BoundSql boundSql <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getBoundSql</span><span class="token punctuation">(</span>parameterObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    CacheKey key <span class="token operator">=</span> <span class="token function">createCacheKey</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="进入第二层核心query"><a href="#进入第二层核心query" class="headerlink" title="进入第二层核心query()"></a>进入第二层核心query()</h4><p>核心在于内部做了本地缓存处理</p><p>前面提到了，生成了一个重写了<code>equals()</code>和<code>hashCode()</code>的Cachekey对象，在这里作为缓存key值判断缓存是否已存在结果集，如果存在则返回，否则直接从数据库查询数据，并触发写缓存操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameterObject<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> CacheKey key<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span>      <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    Cache cache <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">flushCacheIfRequired</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">isUseCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> resultHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureNoOutParams</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        List<span class="token operator">&lt;</span>E<span class="token operator">></span> list <span class="token operator">=</span> <span class="token punctuation">(</span>List<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">)</span> tcm<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 调度抽象父类的query</span>          list <span class="token operator">=</span> delegate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>          tcm<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// issue #578 and #116</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 最终调度抽象父类的query</span>    <span class="token keyword">return</span> delegate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>ms<span class="token punctuation">,</span> parameterObject<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> key<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="进入最后一层doQuery"><a href="#进入最后一层doQuery" class="headerlink" title="进入最后一层doQuery()"></a>进入最后一层doQuery()</h4><p>这一层的工作包括：创建执行语句处理器；连接数据库；获得执行语句对象；调用JDBC接口操作数据库</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">doQuery</span><span class="token punctuation">(</span>MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    Statement stmt <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      Configuration configuration <span class="token operator">=</span> ms<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      StatementHandler handler <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">newStatementHandler</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>      stmt <span class="token operator">=</span> <span class="token function">prepareStatement</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> ms<span class="token punctuation">.</span><span class="token function">getStatementLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> handler<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>stmt<span class="token punctuation">,</span> resultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      <span class="token function">closeStatement</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>创建执行语句处理器：<code>Configuration#newStatementHandler</code><br>开头<strong>关键组件</strong>讲到，<code>StatementHandler</code>是用于处理SQL语句的管理器接口，创建了<code>StatementHandler</code>对象后，通过<code>prepareStatement</code>生成了执行对象Statement</li></ul><p>调用<code>configuration.newStatementHandler</code>，会创建一个<code>RoutingStatementHandler</code>对象，根据<code>MappedStatement</code>对象中已设置的执行类型<code>statementType</code>（默认是PREPARED，除非在mapper.xml的每个方法中手动定义了statementType），来选定最终返回的具体创建的<code>StatementHandler</code>对象，一般是返回预编译的SQL处理器<code>PreparedStatementHandler</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">RoutingStatementHandler</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">,</span> MappedStatement ms<span class="token punctuation">,</span> Object parameter<span class="token punctuation">,</span> RowBounds rowBounds<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">,</span> BoundSql boundSql<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>ms<span class="token punctuation">.</span><span class="token function">getStatementType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 执行简单SQL</span>      <span class="token keyword">case</span> STATEMENT<span class="token operator">:</span>        delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleStatementHandler</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行预编译SQL</span>      <span class="token keyword">case</span> PREPARED<span class="token operator">:</span>        delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PreparedStatementHandler</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 执行存储过程</span>      <span class="token keyword">case</span> CALLABLE<span class="token operator">:</span>        delegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallableStatementHandler</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> boundSql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutorException</span><span class="token punctuation">(</span><span class="token string">"Unknown statement type: "</span> <span class="token operator">+</span> ms<span class="token punctuation">.</span><span class="token function">getStatementType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>预处理Statement，准备执行环境：<code>SimpleExecutor#prepareStatement</code></li></ul><p>连接数据库，获得执行语句对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Statement <span class="token function">prepareStatement</span><span class="token punctuation">(</span>StatementHandler handler<span class="token punctuation">,</span> Log statementLog<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    Statement stmt<span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> <span class="token function">getConnection</span><span class="token punctuation">(</span>statementLog<span class="token punctuation">)</span><span class="token punctuation">;</span>    stmt <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> transaction<span class="token punctuation">.</span><span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    handler<span class="token punctuation">.</span><span class="token function">parameterize</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> stmt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="JDBC执行语句：PreparedStatementHandler-query"><a href="#JDBC执行语句：PreparedStatementHandler-query" class="headerlink" title="JDBC执行语句：PreparedStatementHandler#query()"></a>JDBC执行语句：PreparedStatementHandler#query()</h3><p>这里不同于之前各种重载的<code>query()</code>，开始真正发起对JDBC接口的调用。<br>获取已准备好的statement ，发送SQL命令到数据库中执行，最终调用<code>ResultHandler#handleResultSets()</code>方法处理结果集</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">query</span><span class="token punctuation">(</span>Statement statement<span class="token punctuation">,</span> ResultHandler resultHandler<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    PreparedStatement ps <span class="token operator">=</span> <span class="token punctuation">(</span>PreparedStatement<span class="token punctuation">)</span> statement<span class="token punctuation">;</span>    ps<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> resultSetHandler<span class="token punctuation">.</span><span class="token function">handleResultSets</span><span class="token punctuation">(</span>ps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="结果集处理：DefaultResultSetHandler-handleResultSets"><a href="#结果集处理：DefaultResultSetHandler-handleResultSets" class="headerlink" title="结果集处理：DefaultResultSetHandler#handleResultSets()"></a>结果集处理：DefaultResultSetHandler#handleResultSets()</h3><ul><li>先声明了一个待返回的最终结果集对象<code>multipleResults</code></li><li>获得结果集包装对象<code>ResultSetWrapper</code>，代表一行结果集的包装数据，同时也作为后续遍历过程的临时变量。</li><li>先处理<code>mappedStatement</code>，将其添加到<code>multipleResults</code>中</li><li>再处理ResultSets</li></ul><p>在<code>handleResultSet</code>处理结果集中，Mybatis会根据懒加载配置，针对结果集进行懒加载操作，这里使用了cglib或javasit动态代理，在下一章节再讲解</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token function">handleResultSets</span><span class="token punctuation">(</span>Statement stmt<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">activity</span><span class="token punctuation">(</span><span class="token string">"handling results"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span>mappedStatement<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> multipleResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> resultSetCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ResultSetWrapper rsw <span class="token operator">=</span> <span class="token function">getFirstResultSet</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>ResultMap<span class="token operator">></span> resultMaps <span class="token operator">=</span> mappedStatement<span class="token punctuation">.</span><span class="token function">getResultMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> resultMapCount <span class="token operator">=</span> resultMaps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">validateResultMapsCount</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMapCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rsw <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> resultMapCount <span class="token operator">></span> resultSetCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ResultMap resultMap <span class="token operator">=</span> resultMaps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>resultSetCount<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">handleResultSet</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> multipleResults<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      rsw <span class="token operator">=</span> <span class="token function">getNextResultSet</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">cleanUpAfterHandlingResultSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      resultSetCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> resultSets <span class="token operator">=</span> mappedStatement<span class="token punctuation">.</span><span class="token function">getResultSets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resultSets <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>rsw <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> resultSetCount <span class="token operator">&lt;</span> resultSets<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ResultMapping parentMapping <span class="token operator">=</span> nextResultMaps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>resultSets<span class="token punctuation">[</span>resultSetCount<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parentMapping <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          String nestedResultMapId <span class="token operator">=</span> parentMapping<span class="token punctuation">.</span><span class="token function">getNestedResultMapId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          ResultMap resultMap <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getResultMap</span><span class="token punctuation">(</span>nestedResultMapId<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">handleResultSet</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> null<span class="token punctuation">,</span> parentMapping<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        rsw <span class="token operator">=</span> <span class="token function">getNextResultSet</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">cleanUpAfterHandlingResultSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        resultSetCount<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">collapseSingleResultList</span><span class="token punctuation">(</span>multipleResults<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis源码挖掘机（一）构建阶段</title>
      <link href="/2020/08/15/mybatis-yuan-ma-wa-jue-ji-yi-gou-jian-jie-duan/"/>
      <url>/2020/08/15/mybatis-yuan-ma-wa-jue-ji-yi-gou-jian-jie-duan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>构建阶段主要在于创建SqlSessionFactory实例，这里基于mybatis-spring讲解，其封装了Mybatis的内部实现。</p></blockquote><h2 id="mybatis版本"><a href="#mybatis版本" class="headerlink" title="mybatis版本"></a>mybatis版本</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.2.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="构建关键时序图"><a href="#构建关键时序图" class="headerlink" title="构建关键时序图"></a>构建关键时序图</h2><p>mybaits-spring是基于XML文件配置的，不同于mybatis自身的构建逻辑（指定SqlSessionFactoryBuilder创建SqlSessionFactory），它是Spring指定SqlSessionFactoryBean来创建SqlSessionFactory。</p><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200806154954125_1870888292.png" alt="beanE"></p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionFactoryBean</span>    <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>SqlSessionFactory<span class="token operator">></span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqlSessionFactoryBean</span>    <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token operator">&lt;</span>SqlSessionFactory<span class="token operator">></span><span class="token punctuation">,</span> InitializingBean<span class="token punctuation">,</span> ApplicationListener<span class="token operator">&lt;</span>ApplicationEvent<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>实现了Spring提供的FactoryBean泛型接口，查看源码可知，Spring最终创建的bean并不是SqlSessionFactoryBean本身，而是泛型类型的bean，即SqlSessionFactory，通过getObject()返回</li><li>实现了InitializingBean接口，通过afterPropertiesSet()执行初始化动作，这个初始化是重点</li><li>实现了ApplicationListener接口，即监听器功能，如果配置开启了fail-fast（快速失败）的检测，则会在最后针对Configuration进行检查，确保所有映射的语句都被完全加载，缓存中的语句没有未处理的语句节点，否则“快速失败”！<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>failFast <span class="token operator">&amp;&amp;</span> event <span class="token keyword">instanceof</span> <span class="token class-name">ContextRefreshedEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// fail-fast -> check all statements are completed</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sqlSessionFactory<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMappedStatementNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote><p>初始化里比较核心的方法是创建SqlSessionFactory，在此之前做了很多的准备工作</p></blockquote><p>那么程序启动时如何进行初始化动作呢，在Spring时代，首当其冲的就是XML配置文件，通过配置文件指定要初始化的bean。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>指定初始化的数据源dataSource和SqlSessionFactoryBean</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span>    <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactorydataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 这里可以设置很多属性，具体对应看下SqlSessionFactoryBean中的成员变量 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapperLocations<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:mapper/*.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h3 id="创建Configuration"><a href="#创建Configuration" class="headerlink" title="创建Configuration"></a>创建Configuration</h3><ul><li>如果配置了<code>Configuration</code>属性<blockquote><p>引自<a href="http://mybatis.org/spring/zh/factorybean.html" target="_blank" rel="noopener">mybatis-spring</a><br>自 1.3.0 版本开始，新增的 configuration 属性能够在没有对应的 MyBatis XML 配置文件的情况下，直接设置 Configuration 实例</p></blockquote></li></ul><p>配置如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span>    <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactorydataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>configuration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.ibatis.session.Configuration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapUnderscoreToCamelCase<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>源码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    targetConfiguration <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>targetConfiguration<span class="token punctuation">.</span><span class="token function">getVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        targetConfiguration<span class="token punctuation">.</span><span class="token function">setVariables</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        targetConfiguration<span class="token punctuation">.</span><span class="token function">getVariables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>如果配置了configLocation属性，即指定了MyBatis的XML配置文件路径，则创建一个XMLConfigBuilder实例<blockquote><p>configLocation属性，指定 MyBatis 的 XML 配置文件路径</p></blockquote></li></ul><p>配置如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span>    <span class="token attr-name">init-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>init<span class="token punctuation">"</span></span> <span class="token attr-name">destroy-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>close<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactorydataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>configLocation<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:mapperConfig.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>mapperConfig.xml 即Mybatis的XML配置文件，大致格式如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--    &lt;setting name="cacheEnabled" value="true"/>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><p>Configuratiion配置文件的XML文件格式定义为mybatis-3-config.dtd。文件被放置在<code>org.apache.ibatis.builder.xml</code>中，规定了配置文件中允许配置的内容</p><p>源码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configLocation <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    xmlConfigBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLConfigBuilder</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configLocation<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>    targetConfiguration <span class="token operator">=</span> xmlConfigBuilder<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>以上两个属性都未配置，使用默认的mybatis配置形式，创建Configuration实例</li></ul><p>配置在上面已经贴了</p><p>源码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">else</span> <span class="token punctuation">{</span>    LOGGER<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    targetConfiguration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configurationProperties<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>targetConfiguration<span class="token operator">:</span><span class="token operator">:</span>setVariables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意，configuration和configLocation不能同时配置，否则会抛错</p><h3 id="初始化XMLConfigBuilder"><a href="#初始化XMLConfigBuilder" class="headerlink" title="初始化XMLConfigBuilder"></a>初始化XMLConfigBuilder</h3><blockquote><p>上面提到了当指定Mybatis的XML配置文件，mybatis-spring 会进行解析处理，进而获得Configuration</p></blockquote><p><img src="/images/Mybatis%E6%8C%96%E6%8E%98%E6%9C%BA/20200807003703983_1794462618.png" alt="createDocument"></p><p>构造函数如下，传入一个配置文件的文件流、环境值和参数</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">XMLConfigBuilder</span><span class="token punctuation">(</span>InputStream inputStream<span class="token punctuation">,</span> String environment<span class="token punctuation">,</span> Properties props<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">XPathParser</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> props<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">XMLMapperEntityResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> environment<span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>文件流最终会被构建成XPathParser，XPathParser是Mybatis 对JDK自带的DOM工具的封装，在初始化的过程中，主要调用了createDocument 生成了文档</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">XPathParser</span><span class="token punctuation">(</span>InputStream inputStream<span class="token punctuation">,</span> <span class="token keyword">boolean</span> validation<span class="token punctuation">,</span> Properties variables<span class="token punctuation">,</span> EntityResolver entityResolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">commonConstructor</span><span class="token punctuation">(</span>validation<span class="token punctuation">,</span> variables<span class="token punctuation">,</span> entityResolver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>document <span class="token operator">=</span> <span class="token function">createDocument</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputSource</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="添加附加属性"><a href="#添加附加属性" class="headerlink" title="添加附加属性"></a>添加附加属性</h3><blockquote><p>Xml配置里支持添加很多属性，其中dataSource是必须配置的，且configuration和configLocation不能同时配置</p></blockquote><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactorydataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>KEY<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>VALUE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><h4 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h4><p>指定数据源</p><h4 id="typeAliasesPackage"><a href="#typeAliasesPackage" class="headerlink" title="typeAliasesPackage"></a>typeAliasesPackage</h4><p>配置给指定包名中的类注册别名，之后便可以使用别名而不是全限定名</p><h4 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h4><p>配置指定类注册别名</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>配置拦截器，配置顺序会影响执行顺序</p><h4 id="typeHandlersPackage"><a href="#typeHandlersPackage" class="headerlink" title="typeHandlersPackage"></a>typeHandlersPackage</h4><p>配置指定类型处理器包名，将包名下的类注册为对应的TypeHandler</p><h4 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h4><p>配置类型处理器数组，将它们注册为对应的TypeHandler</p><h3 id="配置environment元素id值（可选）"><a href="#配置environment元素id值（可选）" class="headerlink" title="配置environment元素id值（可选）"></a>配置environment元素id值（可选）</h3><blockquote><p>当配置为空时，则使用默认值“default”。具体有什么作用，后面揭晓。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> String environment <span class="token operator">=</span> SqlSessionFactoryBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>targetConfiguration<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Environment</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">,</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>transactionFactory <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">SpringManagedTransactionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>transactionFactory<span class="token punctuation">,</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="解析Mybatis配置文件（如果指定），构建Configuration配置"><a href="#解析Mybatis配置文件（如果指定），构建Configuration配置" class="headerlink" title="解析Mybatis配置文件（如果指定），构建Configuration配置"></a>解析Mybatis配置文件（如果指定），构建Configuration配置</h3><blockquote><p>当配置了configLocation属性，即指定了MyBatis的XML配置文件路径后，在这一步会去解析XML配置，将配置文件初始化到Configuration对象中 </p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>xmlConfigBuilder <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        xmlConfigBuilder<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LOGGER<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Parsed configuration file: '"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configLocation <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NestedIOException</span><span class="token punctuation">(</span><span class="token string">"Failed to parse config resource: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configLocation<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        ErrorContext<span class="token punctuation">.</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在调用<code>parse()</code>解析配置文件时，其中经常会调用evalNode()方法，来获取解析好的document对象中对应元素的DOM节点</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> XNode <span class="token function">evalNode</span><span class="token punctuation">(</span>Object root<span class="token punctuation">,</span> String expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token punctuation">)</span> <span class="token function">evaluate</span><span class="token punctuation">(</span>expression<span class="token punctuation">,</span> root<span class="token punctuation">,</span> XPathConstants<span class="token punctuation">.</span>NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">XNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> variables<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先获取根节点 <code>configuration</code> 元素，再调用parseConfiguration完成整个解析操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">parseConfiguration</span><span class="token punctuation">(</span>XNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 首先加载属性配置</span>      <span class="token function">propertiesElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 检查settings元素中的properties元素中的key值在Configuration中是否有对应的set()方法</span>      Properties settings <span class="token operator">=</span> <span class="token function">settingsAsProperties</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"settings"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载vfs自定义实现，如果在settings元素中设置了“vfsImpl”则会加载value值对应的类</span>      <span class="token comment" spellcheck="true">// Mybatis在根据别名加载类时会使用VFS</span>      <span class="token function">loadCustomVfs</span><span class="token punctuation">(</span>settings<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">loadCustomLogImpl</span><span class="token punctuation">(</span>settings<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载别名处理器</span>      <span class="token function">typeAliasesElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"typeAliases"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载自定义拦截器</span>      <span class="token function">pluginElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"plugins"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载结果集对象工厂</span>      <span class="token function">objectFactoryElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"objectFactory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">objectWrapperFactoryElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"objectWrapperFactory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">reflectorFactoryElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"reflectorFactory"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 设置全局配置属性，将settings元素的子节点对应的key-value对象设置到Conguration对象中</span>      <span class="token function">settingsElement</span><span class="token punctuation">(</span>settings<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载环境标志</span>      <span class="token function">environmentsElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"environments"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载数据库厂商标志</span>      <span class="token function">databaseIdProviderElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"databaseIdProvider"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载类型处理器</span>      <span class="token function">typeHandlerElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"typeHandlers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载SQL Mapper</span>      <span class="token function">mapperElement</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"mappers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BuilderException</span><span class="token punctuation">(</span><span class="token string">"Error parsing SQL Mapper Configuration. Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="加载全局参数设置settingsElement"><a href="#加载全局参数设置settingsElement" class="headerlink" title="加载全局参数设置settingsElement"></a>加载全局参数设置settingsElement</h4><blockquote><p>在settingsAsProperties()中将settings元素下的所有properties子节点存储返回，接着在将所有properties子节点设置到Configuration对象中。</p></blockquote><p>配置模板如下</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--    &lt;setting name="cacheEnabled" value="true"/>--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!--    &lt;setting name="multipleResultSetsEnabled" value="true"/>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>autoMappingBehavior</td><td>结果集自动映射策略，默认PARTIAL（仅自动映射没有嵌套结果集映射的结果集），可选项有NONE（取消自动映射），FULL（自动映射所有复杂的结果集）</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td>自动映射时未知列的处理策略，默认NONE（不处理），可选项有WARNING（日志警告），FAILING（映射失败，抛异常）</td></tr><tr><td>cacheEnabled</td><td>开启二级缓存开关，默认true</td></tr><tr><td>proxyFactory</td><td>加载代理工厂，CGLIB或者JAVASSIST代理，默认后者</td></tr><tr><td>lazyLoadingEnabled</td><td>懒加载开关，默认false</td></tr><tr><td>aggressiveLazyLoading</td><td>积极、消极加载开关，默认false</td></tr><tr><td>multipleResultSetsEnabled</td><td>多结果集开关，默认true</td></tr><tr><td>useColumnLabel</td><td>列标签开关，不开启则使用别名代替字段名无效，默认true</td></tr><tr><td>useGeneratedKeys</td><td>JDBC自生成主键开关，默认false</td></tr><tr><td>defaultExecutorType</td><td>默认的执行器，默认SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>默认SQL执行超时时间</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>自动驼峰命名规则映射开关，默认false</td></tr><tr><td>localCacheScope</td><td>一级缓存，默认SESSION，即同一SESSION内查询相同sql会使用缓存；你服务架构可提高性能；微服务架构需要关闭一级缓存</td></tr><tr><td>lazyLoadTriggerMethods</td><td>equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td>设置动态SQL驱动器</td></tr><tr><td>defaultEnumTypeHandler</td><td>指定Enum默认类型处理器</td></tr><tr><td>callSettersOnNulls</td><td>当查询结果是空值时，是否调用setter()方法，默认false</td></tr><tr><td>useActualParamName</td><td>启用mapper方法参数作为SQL中的参数名称，默认true，此时方法参数上无需加上@Param注解！前提需基于jdk8（在之前编译为class文件后，参数名称被丢失了，而jdk8开始保留）</td></tr><tr><td>returnInstanceForEmptyRow</td><td>返回空实例开关，开启了则返回所有列是空时不返回null，默认false</td></tr><tr><td>logPrefix</td><td>加载日志名称的前缀</td></tr><tr><td>configurationFactory</td><td>加载配置工厂</td></tr></tbody></table><h4 id="加载类型处理器typeHandlerElement"><a href="#加载类型处理器typeHandlerElement" class="headerlink" title="加载类型处理器typeHandlerElement"></a>加载类型处理器typeHandlerElement</h4><blockquote><p>Mybatis中提供了多个类型处理器，在前面的Congiuration的附加属性配置中，只是定义了typeHandler的配置，在这里就要开始加载了。具体位置在<code>org.apache.ibatis.type</code></p></blockquote><p>配置模板如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandlers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeHandler</span> <span class="token attr-name">handler</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.ibatis.type.EnumTypeHandler<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeHandlers</span><span class="token punctuation">></span></span></code></pre><p>Mybatis中提供的类型处理器，都继承自抽象模板类<code>BaseTypeHandler</code>，它主要负责异常处理并进行空值判断，具体的类型转换交给派生类各自实现。故我们也可以自定义typeHandler。</p><h4 id="加载运行时环境配置environmentsElement"><a href="#加载运行时环境配置environmentsElement" class="headerlink" title="加载运行时环境配置environmentsElement"></a>加载运行时环境配置environmentsElement</h4><blockquote><p>在实际项目中，当一个应用需要区分不同环境不同mybatis配置时，则需要使用到Mybatis的environment配置</p></blockquote><p>配置模板如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 默认只有两个属性配置 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManger</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transactionManger</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>datasource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${driver}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${username}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${password}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>datasource</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span></code></pre><p>前面我们提到了在buildSqlSessionFactory中，可以配置environment属性，即id值，它的作用就是选取environments元素中指定id的environment，当配置为空时，则默认“default”。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">environmentsElement</span><span class="token punctuation">(</span>XNode context<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>environment <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取默认的环境值</span>        environment <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>XNode child <span class="token operator">:</span> context<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历环境配置列表，获取id</span>        String id <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断当前环境配置是否在构建buildSqlSessionFactory中时指定的id中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSpecifiedEnvironment</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 初始化环境配置对应的会话、数据源工厂、数据源和环境对象</span>          TransactionFactory txFactory <span class="token operator">=</span> <span class="token function">transactionManagerElement</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"transactionManager"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          DataSourceFactory dsFactory <span class="token operator">=</span> <span class="token function">dataSourceElement</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"dataSource"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          DataSource dataSource <span class="token operator">=</span> dsFactory<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Environment<span class="token punctuation">.</span>Builder environmentBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Environment<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>              <span class="token punctuation">.</span><span class="token function">transactionFactory</span><span class="token punctuation">(</span>txFactory<span class="token punctuation">)</span>              <span class="token punctuation">.</span><span class="token function">dataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>          configuration<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span>environmentBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="解析Mapper配置-mapperElement"><a href="#解析Mapper配置-mapperElement" class="headerlink" title="解析Mapper配置 mapperElement()"></a>解析Mapper配置 mapperElement()</h4><ul><li>指定包名，包名内的符合条件的mapper接口定义会注册到mybatis<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxx<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre></li><li>指定多个mapper，其中resource、url、class三个属性互斥<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 使用相对于类路径的资源引用 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx/xxxMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 使用完全限定资源定位符（URL） --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file:///xxx/xxxMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 使用映射器接口实现类的完全限定类名 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx.xxxMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre></li></ul><h3 id="构建XMLMapperBuilder，扫描mapper文件"><a href="#构建XMLMapperBuilder，扫描mapper文件" class="headerlink" title="构建XMLMapperBuilder，扫描mapper文件"></a>构建XMLMapperBuilder，扫描mapper文件</h3><p>其中parse()方法完成了单个mapper的解析和加载工作，外层一个for循环逐个遍历mapper文件</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断mapper是否被重复加载</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>configuration<span class="token punctuation">.</span><span class="token function">isResourceLoaded</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 从mapper根节点开始解析mapper.xml文件</span>      <span class="token function">configurationElement</span><span class="token punctuation">(</span>parser<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"/mapper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      configuration<span class="token punctuation">.</span><span class="token function">addLoadedResource</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 绑定mapper类和mapper方法</span>      <span class="token function">bindMapperForNamespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 在解析加载失败时重试加载（同步操作，仅一次）</span>    <span class="token function">parsePendingResultMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">parsePendingCacheRefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">parsePendingStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SQL Mapping加载步骤</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">configurationElement</span><span class="token punctuation">(</span>XNode context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 加载命名空间namespace，必须指定</span>      String namespace <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"namespace"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>namespace <span class="token operator">==</span> null <span class="token operator">||</span> namespace<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BuilderException</span><span class="token punctuation">(</span><span class="token string">"Mapper's namespace cannot be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      builderAssistant<span class="token punctuation">.</span><span class="token function">setCurrentNamespace</span><span class="token punctuation">(</span>namespace<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载缓存引用配置</span>      <span class="token function">cacheRefElement</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"cache-ref"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载缓存配置</span>      <span class="token function">cacheElement</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNode</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载请求参数</span>      <span class="token function">parameterMapElement</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNodes</span><span class="token punctuation">(</span><span class="token string">"/mapper/parameterMap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载结果集映射</span>      <span class="token function">resultMapElements</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNodes</span><span class="token punctuation">(</span><span class="token string">"/mapper/resultMap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载SQL片段</span>      <span class="token function">sqlElement</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNodes</span><span class="token punctuation">(</span><span class="token string">"/mapper/sql"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 加载SQL语句</span>      <span class="token function">buildStatementFromContext</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">evalNodes</span><span class="token punctuation">(</span><span class="token string">"select|insert|update|delete"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BuilderException</span><span class="token punctuation">(</span><span class="token string">"Error parsing Mapper XML. The XML location is '"</span> <span class="token operator">+</span> resource <span class="token operator">+</span> <span class="token string">"'. Cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 <code>buildStatementFromContext</code>中，mybatis加载了mapper中带有select|insert|update|delete的节点，解析了每个节点上的属性和具体sql，其中有个属性执行类型<code>statementType</code>需要注意，在mybatis中默认为<code>StatementType.PREPARED</code>类型，代表它是一个预编译的sql，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parseStatementNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ......</span>    StatementType statementType <span class="token operator">=</span> StatementType<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"statementType"</span><span class="token punctuation">,</span> StatementType<span class="token punctuation">.</span>PREPARED<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ......</span>    builderAssistant<span class="token punctuation">.</span><span class="token function">addMappedStatement</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> sqlSource<span class="token punctuation">,</span> statementType<span class="token punctuation">,</span> sqlCommandType<span class="token punctuation">,</span>        fetchSize<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> parameterMap<span class="token punctuation">,</span> parameterTypeClass<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> resultTypeClass<span class="token punctuation">,</span>        resultSetTypeEnum<span class="token punctuation">,</span> flushCache<span class="token punctuation">,</span> useCache<span class="token punctuation">,</span> resultOrdered<span class="token punctuation">,</span>        keyGenerator<span class="token punctuation">,</span> keyProperty<span class="token punctuation">,</span> keyColumn<span class="token punctuation">,</span> databaseId<span class="token punctuation">,</span> langDriver<span class="token punctuation">,</span> resultSets<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然也可以手动指定执行类型，但是此时不能带有动态参数</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"get"</span> resultType<span class="token operator">=</span><span class="token string">"User"</span> statementType<span class="token operator">=</span><span class="token string">"STATEMENT"</span><span class="token operator">></span>    SELECT <span class="token operator">*</span> FROM user<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span></code></pre><p>这里需要注意，mapper的方法是不能重载的，因为其中存储mapperstatement时会根据方法的全限定名存储，存储时会做二次校验是否已经存在mapperstatement</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">" already contains value for "</span> <span class="token operator">+</span> key            <span class="token operator">+</span> <span class="token punctuation">(</span>conflictMessageProducer <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> conflictMessageProducer<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// ......</span>      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="根据命名空间获取mapper类并绑定"><a href="#根据命名空间获取mapper类并绑定" class="headerlink" title="根据命名空间获取mapper类并绑定"></a>根据命名空间获取mapper类并绑定</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">bindMapperForNamespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String namespace <span class="token operator">=</span> builderAssistant<span class="token punctuation">.</span><span class="token function">getCurrentNamespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>namespace <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> boundType <span class="token operator">=</span> null<span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        boundType <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">classForName</span><span class="token punctuation">(</span>namespace<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//ignore, bound type is not required</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>boundType <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>configuration<span class="token punctuation">.</span><span class="token function">hasMapper</span><span class="token punctuation">(</span>boundType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Spring可能不知道真实的资源文件名称，这里设置一个标志位防止重复从mapper接口加载资源</span>          configuration<span class="token punctuation">.</span><span class="token function">addLoadedResource</span><span class="token punctuation">(</span><span class="token string">"namespace:"</span> <span class="token operator">+</span> namespace<span class="token punctuation">)</span><span class="token punctuation">;</span>          configuration<span class="token punctuation">.</span><span class="token function">addMapper</span><span class="token punctuation">(</span>boundType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>调用<code>mapperRegistry</code>添加mapper</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> MapperRegistry mapperRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperRegistry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">addMapper</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注册mapper类</span>    mapperRegistry<span class="token punctuation">.</span><span class="token function">addMapper</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注册mapper的逻辑，封装了诸如，解析mapper方法，CacheNamespace注解、CacheNamespaceRef注解等</p><p>这里要注意<code>MapperRegistry</code>的不可变成员变量knownMappers，它是一个HashMap，key为mapper的class类对象，value为mapper代理工厂 <code>MapperProxyFactory</code>，它主要是用于后续的动态代理流程，用于获取mapper对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">addMapper</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasMapper</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BindingException</span><span class="token punctuation">(</span><span class="token string">"Type "</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">" is already known to the MapperRegistry."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">boolean</span> loadCompleted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        knownMappers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MapperProxyFactory</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// It's important that the type is added before the parser is run</span>        <span class="token comment" spellcheck="true">// otherwise the binding may automatically be attempted by the</span>        <span class="token comment" spellcheck="true">// mapper parser. If the type is already known, it won't try.</span>        MapperAnnotationBuilder parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MapperAnnotationBuilder</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>        parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        loadCompleted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loadCompleted<span class="token punctuation">)</span> <span class="token punctuation">{</span>          knownMappers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="加载缓存配置cacheElement"><a href="#加载缓存配置cacheElement" class="headerlink" title="加载缓存配置cacheElement"></a>加载缓存配置cacheElement</h4><p>Nybatis默认开启了一级缓存，但是要开启二级缓存的话，需要手动配置<br>先在Mybatis配置文件中配置</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>再在mapper.xml中配置</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置即声明当前namespace开启二级缓存 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 引用别的命名空间的cache配置，可选 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache-ref</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx/xxxMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>二级缓存Cache配置</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cacheElement</span><span class="token punctuation">(</span>XNode context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 缓存类型,默认PERPETUALCache</span>      String type <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token string">"PERPETUAL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> typeClass <span class="token operator">=</span> typeAliasRegistry<span class="token punctuation">.</span><span class="token function">resolveAlias</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 缓存回收策略，默认LRU</span>      String eviction <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getStringAttribute</span><span class="token punctuation">(</span><span class="token string">"eviction"</span><span class="token punctuation">,</span> <span class="token string">"LRU"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> evictionClass <span class="token operator">=</span> typeAliasRegistry<span class="token punctuation">.</span><span class="token function">resolveAlias</span><span class="token punctuation">(</span>eviction<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 自动刷新间隔，单位毫秒</span>      Long flushInterval <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getLongAttribute</span><span class="token punctuation">(</span><span class="token string">"flushInterval"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Integer size <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getIntAttribute</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 是否只读，默认false，若为true则需要对应的实体类能够序列化</span>      <span class="token keyword">boolean</span> readWrite <span class="token operator">=</span> <span class="token operator">!</span>context<span class="token punctuation">.</span><span class="token function">getBooleanAttribute</span><span class="token punctuation">(</span><span class="token string">"readOnly"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 缓存中无法找到key时，是否阻塞式获取直到有数据</span>      <span class="token keyword">boolean</span> blocking <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBooleanAttribute</span><span class="token punctuation">(</span><span class="token string">"blocking"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Properties props <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getChildrenAsProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      builderAssistant<span class="token punctuation">.</span><span class="token function">useNewCache</span><span class="token punctuation">(</span>typeClass<span class="token punctuation">,</span> evictionClass<span class="token punctuation">,</span> flushInterval<span class="token punctuation">,</span> size<span class="token punctuation">,</span> readWrite<span class="token punctuation">,</span> blocking<span class="token punctuation">,</span> props<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>目前支持的缓存回收策略有</p><ul><li>LRU，最近最少使用，删除最长时间未使用的对象</li><li>FIFO，先进先出，按照对象进入缓存的顺序来删除对象</li><li>SOFT，软引用，移除基于垃圾回收器状态和软引用规则删除对象</li><li>WEAK，弱引用，根据垃圾回收器状态和弱引用规则更积极地删除对象</li></ul><h4 id="加载SQL片段"><a href="#加载SQL片段" class="headerlink" title="加载SQL片段"></a>加载SQL片段</h4><p>SQL片段可以减少SQL中的重复语句，定义好的SQL片段可以在其他SQL中使用。<br>SQL片段可以使用databaseid属性进行划分，指定不同的数据库厂商的SQL方言</p><h3 id="构建DefaultSqlSessionFactory"><a href="#构建DefaultSqlSessionFactory" class="headerlink" title="构建DefaultSqlSessionFactory"></a>构建DefaultSqlSessionFactory</h3><blockquote><p>当初始化准备工作做完后，Configuration已被配置完毕，接着开始创建SqlSessionFactory实例</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> SqlSessionFactory <span class="token function">build</span><span class="token punctuation">(</span>Configuration config<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultSqlSessionFactory</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈(三)一致性哈希算法</title>
      <link href="/2020/08/02/lao-sheng-chang-tan-san-yi-zhi-xing-ha-xi-suan-fa/"/>
      <url>/2020/08/02/lao-sheng-chang-tan-san-yi-zhi-xing-ha-xi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>哈希算法，多应用于多数框架的底层实现，在JAVA中与其相关的有HashMap、HashTable等。</p><p>首先抛几个问题</p><ul><li>都知道Hashmap底层使用了hash（取模）算法，它与一致性hash算法有什么区别呢？</li><li>在分布式缓存中，hash算法起了很大的作用，它也是上述提到的取模算法吗？</li><li>取模法与一致性哈希算法有什么区别？</li></ul><h2 id="什么是哈希算法"><a href="#什么是哈希算法" class="headerlink" title="什么是哈希算法"></a>什么是哈希算法</h2><blockquote><p>hash即散列，哈希算法又称散列算法，将任意长度的二进制值映射为较短的固定长度的二进制值（哈希值），哈希值是一段数据唯一且极其紧凑的数值表示形式，常用于快速查找和加密算法。</p></blockquote><h2 id="传统取模法（以Hashmap为例）"><a href="#传统取模法（以Hashmap为例）" class="headerlink" title="传统取模法（以Hashmap为例）"></a>传统取模法（以Hashmap为例）</h2><blockquote><p>HashMap底层结构是数组+链表+红黑树。数组相当于一个bucket，在bucket这一层就用到了取模法。</p></blockquote><p>假设数组的长度为n，当一个Entry（key-value）加入时，先计算key的hash值，再通过 <code>（n -1）&amp; hash</code> 的位操作，得到bucket的下标。这里的位操作其实就是取模算法 <code>hash % n</code>的优化版。这时候问题来了，由于数组容量必定有限，当需要扩容（新增Node节点）时，Hashmap会rehash（重建hash表），可想而知重建会导致大量的key需要迁移并重新计算下标。 故Hashmap源码中提到了要合理设置初始长度和负载因子，以“内存换性能”的操作来避免rehash。</p><p>取模思路如下<br>假设数组初始长度n = 5，增加结点至n = 6，最终导致全部数据都需进行迁移，改变下标。</p><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731152435758_1941699246.jpg" alt="取模存储及查找"></p><p>换个角度思考，是否可以做到，在扩容的时候尽最大化地减少迁移的操作，并且保证原来的key仍在原来的位置（在分布式缓存系统中，这点尤为重要，否则容易引起缓存雪崩等情况）</p><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><blockquote><p>引自wiki<br>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对K/n 个关键字重新映射，其中K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p></blockquote><p>其实一致性哈希算法也是一种取模法，只不过不直接对服务器数量进行取模分发，而是对2^32进行取模，以此解决重新散列的问题。</p><p>实现原理大致如下</p><ul><li><p>构造由2^32个点位组成的环形hash空间</p></li><li><p>将服务器节点映射到hash空间</p></li><li><p>将存储对象映射到hash空间</p></li><li><p>将对象沿顺时针转动，碰到的第一个服务器节点，即当前对象应缓存的节点</p></li></ul><p>将上述原理概括成描述一致性哈希算法的规则：环形空间，节点映射，对象映射，顺时针相遇</p><p>它目前已经应用于<a href="https://github.com/papers-we-love/papers-we-love/blob/master/datastores/dynamo-amazons-highly-available-key-value-store.pdf" target="_blank" rel="noopener">AWS Dynamodb高可用 Nosql数据库</a>、<a href="https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients" target="_blank" rel="noopener">Memcached分布式缓存</a>、Nginx负载均衡等</p><h2 id="一致性哈希基于分布式缓存的应用"><a href="#一致性哈希基于分布式缓存的应用" class="headerlink" title="一致性哈希基于分布式缓存的应用"></a>一致性哈希基于分布式缓存的应用</h2><p>为什么说一致性哈希是一种特殊的哈希算法，可以借助分布式缓存的例子来说明。</p><p>假设现在有三个服务器节点A、B、C，三条待缓存的键值对数据a、b、c。</p><h3 id="初始节点"><a href="#初始节点" class="headerlink" title="初始节点"></a>初始节点</h3><ul><li>将三个服务器节点通过hash(ip地址) % 2^32 取模得到一个整数值（介于0 ~ 2^32），定位到环形空间上</li></ul><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731163639418_10607236.jpg" alt="服务器节点映射"></p><ul><li>将三个缓存对象通过hash(key) % 2^32 取模得到一个整数值（介于0 ~ 2^32），定位到环形空间上</li></ul><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731171432756_1761578491.png" alt="缓存数据对象映射"></p><ul><li>将缓存对象沿顺时针“转动”，当第一个遇到的服务器节点，就是缓存对象对应存储的节点</li></ul><p>如下图所示，缓存对象a在服务节点A上存储，缓存对象b在服务节点B上存储…</p><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731180418926_624189149.png" alt="缓存对象映射服务器节点"></p><h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h3><ul><li>假设此时节点B出现故障下线了，按照一致性哈希的规则中的“顺时针相遇”，缓存对象b应该与服务节点C相遇，存储位置变动，而其他节点按兵不动，不受影响</li></ul><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731180042941_566711142.png" alt="节点B故障"></p><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><ul><li>假设此时新增一个节点D，位于A与C之间，如下图，按照一致性哈希的规则中的“顺时针相遇”可知，所有缓存对象无需再次转动</li></ul><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731180751711_289411648.png" alt="新增节点D"></p><ul><li>假设此时新增一个节点E，位于A与B之间，如下图，按照一致性哈希的规则中的“顺时针相遇”可知，缓存对象b与服务节点E相遇，存储位置变动</li></ul><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731181540803_91107481.png" alt="新增节点E"></p><h2 id="hash环倾斜"><a href="#hash环倾斜" class="headerlink" title="hash环倾斜"></a>hash环倾斜</h2><blockquote><p>在描述基于分布式缓存的应用时，看似一切都很理想化。<br>但是会遇到一种情况，实际服务节点的映射位置可能比较极端，进而造成数据倾斜，这种情况会导致大多数的缓存对象都集中在一个节点，失去了哈希算法存在的意义。</p></blockquote><p><img src="/images/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/20200731182843005_87592856.png" alt="节点偏斜"></p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><blockquote><p>hash算法无法保证绝对的平衡，一致性哈希算法容易导致数据倾斜，故它又引入了“虚拟节点”，即实际节点在hash空间的复制节点，两者关系为1：n，虚拟节点在hash空间中以hash值排列</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一致性哈希算法，相较于常规的取模法，解决了增删节点导致的重新散列的问题，基于“环形空间，节点映射，对象映射，顺时针相遇”的规则，加上虚拟节点的引入，很大程度地解决了分布式系统的心结，故它常用于Nginx负载均衡、Dynamodb分布式数据库等。</p>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring缓存挖掘机（三）- 自定义缓存</title>
      <link href="/2020/07/15/spring-huan-cun-wa-jue-ji-3-zi-ding-yi-huan-cun/"/>
      <url>/2020/07/15/spring-huan-cun-wa-jue-ji-3-zi-ding-yi-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring缓存挖掘机（三）-自定义缓存"><a href="#Spring缓存挖掘机（三）-自定义缓存" class="headerlink" title="Spring缓存挖掘机（三）- 自定义缓存"></a>Spring缓存挖掘机（三）- 自定义缓存</h1><h2 id="如何实现多级缓存"><a href="#如何实现多级缓存" class="headerlink" title="如何实现多级缓存"></a>如何实现多级缓存</h2><p>参考上一篇的源码分析，Spring提供了缓存实现接口，并且又在support包中实现了几种缓存方案，但都仅支持单一缓存。<br>这时，我们可以把需要的几种缓存组件组装起来，新建一个缓存类Cache 和缓存处理器类CacheManager。<br>其中Cache类同样继承<code>AbstractValueAdaptingCache</code>，重写其方法，将几种缓存的功能实现封装起来<br>CacheManager类同样实现<code>CacheManager</code>，重写其方法，在创建缓存实例的地方，改为创建多种缓存实例。</p><h2 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractValueAdaptingCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SaasCache<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存名称     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存级别：1级读本地，2级读redis     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Integer cacheLevel<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> RedisCache rediscache<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> CaffeineCache caffeineCache<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *     * @param name     * @param cacheLevel     * @param allowNullValues     * @param caffeineCache 不传，则表示不存本地     * @param rediscache    不传，则表示不存redis     */</span>    <span class="token keyword">protected</span> <span class="token function">SaasCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer cacheLevel<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowNullValues<span class="token punctuation">,</span> CaffeineCache caffeineCache<span class="token punctuation">,</span> RedisCache rediscache<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>allowNullValues<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">=</span> cacheLevel<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>rediscache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"at least one cache!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>rediscache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"redis cache cannot be empty when setting cache level to 2!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"caffeine cache cannot be empty when setting cache level to 1!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>caffeineCache <span class="token operator">=</span> caffeineCache<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rediscache <span class="token operator">=</span> rediscache<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * spring 内部根据key获取缓存时用到     * @param key     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">lookup</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getNativeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> V <span class="token function">getIfPresent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_1</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_2</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            V v <span class="token operator">=</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                v <span class="token operator">=</span> callable<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ValueWrapper <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"setting key {}, value {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            caffeineCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rediscache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ValueWrapper <span class="token function">putIfAbsent</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Object o1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除指定key，当使用@CacheEvict注解后调用     * @see org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(java.util.Collection, boolean, java.lang.Object)     * @param key     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        caffeineCache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        rediscache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        caffeineCache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rediscache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 这里获取二级缓存有点区别，当获取不到二级缓存的时候，会尝试去获取一级缓存     */</span>    <span class="token keyword">private</span> V <span class="token function">getLevel_2</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> rediscache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            ValueWrapper valueWrapper <span class="token operator">=</span> rediscache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> valueWrapper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"query level_2 key: {}, value: {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_1</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> V <span class="token function">getLevel_1</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> caffeineCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            ValueWrapper valueWrapper <span class="token operator">=</span> caffeineCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> valueWrapper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"query level_1 key: {}, value: {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br /><h2 id="重新实现RedisCache"><a href="#重新实现RedisCache" class="headerlink" title="重新实现RedisCache"></a>重新实现RedisCache</h2><blockquote><p>重新实现的目的是为了使用它的构造函数，RedisCache默认的构造函数是protected的，自定义缓存管理器无法去加载redis缓存实例</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">public class SaasRedisCache extends RedisCache {    /**     * Create new {@link RedisCache}.     *     * @param name        must not be {@literal null}.     * @param cacheWriter must not be {@literal null}.     * @param cacheConfig must not be {@literal null}.     */    protected SaasRedisCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) {        super(name, cacheWriter, cacheConfig);    }}</code></pre><br /><h2 id="自定义缓存管理器"><a href="#自定义缓存管理器" class="headerlink" title="自定义缓存管理器"></a>自定义缓存管理器</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheManager</span> <span class="token keyword">implements</span> <span class="token class-name">CacheManager</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">SaasCacheManager</span><span class="token punctuation">(</span>RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>redisConnectionFactory <span class="token operator">=</span> redisConnectionFactory<span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames <span class="token operator">=</span> SaasCacheNameConfig<span class="token punctuation">.</span><span class="token function">getCacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缓存开启，缓存名称列表：{}"</span><span class="token punctuation">,</span> cacheNames<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setCacheNames</span><span class="token punctuation">(</span>cacheNames<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCacheNames</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">newCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> SaasCacheNameConfig<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Cache <span class="token function">newCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> SaasCacheNameData cacheExpire<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缓存名称：{}，缓存级别：{}，设置缓存时间：{}"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaasCache</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token function">newCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">newRedisCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br /><h2 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h2><blockquote><p>这里主要配置redis</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 193.112.7.209    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">10000</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">100</span>        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span></code></pre><pre class=" language-java"><code class="language-java">@<span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    RedisConnectionFactory redisConnectionFactory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaasCacheManager</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class DemoServiceImpl implements DemoService {    @Cacheable(value = SaasCacheConfig.cacheName, key = "#s1.concat(#s2)", sync = true)    @Override    public String getData(String s1, String s2, Integer i1) {        System.out.println("none cache, start to save...");        return "success";    }    @CacheEvict(value = SaasCacheConfig.cacheName, key = "#s1.concat(#s2)", beforeInvocation = false)    @Override    public void clearData(String s1, String s2, Integer i1) {        // empty list    }}</code></pre><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><pre class=" language-JAVA"><code class="language-JAVA">@Testpublic void demo() throws Exception {    demoService.clearData("1", "2", 3);    for(int i = 0; i < 10; i++) {        new Thread(() -> {            System.out.println(demoService.getData("1", "2", 3));        }).start();    }    Thread.sleep(10*1000);    demoService.clearData("1", "2", 3);    System.out.println(demoService.getData("1", "2", 3));}</code></pre><h3 id="测试结果打印"><a href="#测试结果打印" class="headerlink" title="测试结果打印"></a>测试结果打印</h3><pre><code>none cache, start to save...2020-07-16 11:48:59.442  INFO 21882 --- [       Thread-5] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.480  INFO 21882 --- [       Thread-6] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.496  INFO 21882 --- [       Thread-7] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.516  INFO 21882 --- [       Thread-8] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.535  INFO 21882 --- [       Thread-2] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.553  INFO 21882 --- [       Thread-4] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.571  INFO 21882 --- [      Thread-11] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.591  INFO 21882 --- [      Thread-10] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.607  INFO 21882 --- [       Thread-3] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.615  INFO 21882 --- [       Thread-9] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccessnone cache, start to save...2020-07-16 11:49:09.445  INFO 21882 --- [           main] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring缓存挖掘机（二）- 缓存及管理器</title>
      <link href="/2020/07/12/spring-huan-cun-wa-jue-ji-2-huan-cun-ji-guan-li-qi/"/>
      <url>/2020/07/12/spring-huan-cun-wa-jue-ji-2-huan-cun-ji-guan-li-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h2><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212726143_1059579798.png" alt="缓存管理器"></p><p>Spring提供了中央缓存管理器的底层SPI接口：<code>org.springframework.cache.CacheManager</code>，在spring-context 模块内。</p><p>以上是CacheManager 以及不同的缓存方案的管理器实现类</p><p>Spring提供的缓存管理器的SPI接口很简单，仅仅提供了两个待实现的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CacheManager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过指定缓存名称获取关联的缓存     */</span>    <span class="token annotation punctuation">@Nullable</span>    Cache <span class="token function">getCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取此缓存管理器已知的缓存名称的集合     */</span>    Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200711230414394_1325718760.png" alt="cache"></p><p>了解下Spring 提供的缓存接口<code>org.springframework.cache.Cache</code>，在<strong>spring-context</strong> 模块内，里面主要提供了存取缓存的方法，这里就不贴代码了</p><p>接下来讲一下几种缓存方案的接入和实现源码</p><br /><h2 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h2><blockquote><p>Caffeine，基于JAVA8的一个高性能缓存库，类似于<code>ConcurrentMap</code>，但不同的一点在于Caffeine可以基于一定规则动态清除缓存，而<code>ConcurrentMap</code>只能手动清除<br>github地址：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p></blockquote><p><br /><a href="https://cloud.tencent.com/developer/article/1497595" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497595</a></p><h3 id="引入Caffeine依赖"><a href="#引入Caffeine依赖" class="headerlink" title="引入Caffeine依赖"></a>引入Caffeine依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.ben-manes.caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="声明缓存类型"><a href="#声明缓存类型" class="headerlink" title="声明缓存类型"></a>声明缓存类型</h3><blockquote><p>这里的声明主要有两种方式，Spring 提供的配置声明，自定义bean声明</p></blockquote><h4 id="配置声明"><a href="#配置声明" class="headerlink" title="配置声明"></a>配置声明</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> caffeine    <span class="token key atrule">cache-names</span><span class="token punctuation">:</span> <span class="token string">"saas-cache"</span></code></pre><h4 id="自定义声明"><a href="#自定义声明" class="headerlink" title="自定义声明"></a>自定义声明</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String cacheName <span class="token operator">=</span> <span class="token string">"saas-cache"</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCacheManager</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br/><h3 id="CaffeineCacheConfiguration"><a href="#CaffeineCacheConfiguration" class="headerlink" title="CaffeineCacheConfiguration"></a>CaffeineCacheConfiguration</h3><blockquote><p>顾名思义，它是一个Caffeine缓存配置类，主要用来创建Caffeine缓存管理器，<br>需要在配置文件上添加相应的配置，如上面的配置声明。</p></blockquote><p>该类上添加了条件注解@Conditional***，如果条件不生效，则不会创建该bean。</p><pre class=" language-JAVA"><code class="language-JAVA">@Configuration(proxyBeanMethods = false)@ConditionalOnClass({ Caffeine.class, CaffeineCacheManager.class })@ConditionalOnMissingBean(CacheManager.class)@Conditional({ CacheCondition.class })class CaffeineCacheConfiguration {    /**     * @param cacheProperties    在上面声明缓存类型中的配置声明，则会一一匹配到CacheProperties     */    @Bean    CaffeineCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers customizers,            ObjectProvider<Caffeine<Object, Object>> caffeine, ObjectProvider<CaffeineSpec> caffeineSpec,            ObjectProvider<CacheLoader<Object, Object>> cacheLoader) {        CaffeineCacheManager cacheManager = createCacheManager(cacheProperties, caffeine, caffeineSpec, cacheLoader);        // 这里读取配置中配置的cache-names        List<String> cacheNames = cacheProperties.getCacheNames();        if (!CollectionUtils.isEmpty(cacheNames)) {            cacheManager.setCacheNames(cacheNames);        }        return customizers.customize(cacheManager);    }}</code></pre><br/><h3 id="CaffeineCacheManager"><a href="#CaffeineCacheManager" class="headerlink" title="CaffeineCacheManager"></a>CaffeineCacheManager</h3><h4 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h4><ul><li>存放的缓存名称cacheMap，默认设置初始容量为16<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> ConcurrentMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Cache<span class="token operator">></span> cacheMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>默认缓存模式为静态模式，即不支持动态创建<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li><li>默认允许缓存null值<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> allowNullValues <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="设置缓存模式，及指定缓存名称"><a href="#设置缓存模式，及指定缓存名称" class="headerlink" title="设置缓存模式，及指定缓存名称"></a>设置缓存模式，及指定缓存名称</h4><p>这一步主要用于声明缓存管理器时调用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCacheNames</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果指定了一组缓存名称，则模式固定为静态模式，此时无法再动态创建其他的缓存区域</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 反之不指定则为动态模式，允许再次添加缓存</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 为指定的缓存名称创建一个CaffeineCache实例</span><span class="token keyword">protected</span> Cache <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createNativeCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">isAllowNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">createNativeCaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLoader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果是动态模式，在接下来获取缓存实例时，则会根据定义好的缓存名称动态创建缓存实例。<br>所以这里需要明白系统中所需的是静态还是动态模式！</p><h4 id="加载缓存实例"><a href="#加载缓存实例" class="headerlink" title="加载缓存实例"></a>加载缓存实例</h4><p>这一步主要用于在<code>CacheAspectSupport</code>中构造缓存操作上下文时，指定缓存名称获取缓存实例存入上下文，同个缓存名称只会保存一次</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Cache <span class="token function">getCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheName <span class="token operator">-</span><span class="token operator">></span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">?</span> <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h3 id="CaffeineCache"><a href="#CaffeineCache" class="headerlink" title="CaffeineCache"></a>CaffeineCache</h3><blockquote><p>Spring在<strong>spring-context-support</strong>中提供了Caffeine 的默认实现，要使用它的前提是项目中引入Caffeine的依赖，并显示地声明缓存管理器为<code>CaffeineCacheManager</code></p></blockquote><h4 id="构造缓存实例"><a href="#构造缓存实例" class="headerlink" title="构造缓存实例"></a>构造缓存实例</h4><blockquote><p>这一步主要用于声明缓存管理器时调用，在管理器中获取Caffeine缓存实例，再构造基于Sping cache的一个缓存实例<br>注意：这里默认拿到的Caffeine缓存实例是无界的，即UnboundedLocalManualCache，而想要获得有界缓存实例的条件是，指定一定的有界条件，如maximumSize，详细查看com.github.benmanes.caffeine.cache.Caffeine#isBounded</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> cache<span class="token punctuation">,</span>        <span class="token keyword">boolean</span> allowNullValues<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>allowNullValues<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"Name must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> <span class="token string">"Cache must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> cache<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取缓存"><a href="#获取缓存" class="headerlink" title="获取缓存"></a>获取缓存</h4><h5 id="获取底层使用的缓存"><a href="#获取底层使用的缓存" class="headerlink" title="获取底层使用的缓存"></a>获取底层使用的缓存</h5><blockquote><p>Caffeine底层有多种类型的缓存实现，如有界缓存和无界缓存等</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> cache<span class="token punctuation">;</span> <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getNativeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="获取缓存-1"><a href="#获取缓存-1" class="headerlink" title="获取缓存"></a>获取缓存</h5><blockquote><p>这一步主要用于执行缓存注解的方法前，同步/异步获取缓存，如若获取不到则调取注解方法获取最新结果</p></blockquote><ul><li>非同步获取</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key获取缓存，并对其包装成ValueWrapper */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> ValueWrapper <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token keyword">instanceof</span> <span class="token class-name">LoadingCache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LoadingCache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">toValueWrapper</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 查找指定key的缓存 */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> Object <span class="token function">lookup</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>同步获取</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key获取缓存，如果缓存不存在，则同步调用底层的get(K key, Function&lt;? super K, ? extends V> mappingFunction) * 一般缓存框架都默认实现了同步逻辑，如Caffeine cache 底层就使用了ConcurrentHashMap实现的同步处理，详细可看源码com.github.benmanes.caffeine.cache.UnboundedLocalCache#computeIfAbsent */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token keyword">final</span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> valueLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token function">fromStoreValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LoadFunction</span><span class="token punctuation">(</span>valueLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="存储缓存"><a href="#存储缓存" class="headerlink" title="存储缓存"></a>存储缓存</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 将值与指定key进行关联缓存 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">toStoreValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 若值与指定key关联缓存则直接返回，否则以原子操作 将两者进行关联，其底层使用了get(Object key, final Callable&lt;T> valueLoader) */</span><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> ValueWrapper <span class="token function">putIfAbsent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获得一个可调用的方法</span>    PutIfAbsentFunction callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PutIfAbsentFunction</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>callable<span class="token punctuation">.</span>called <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">toValueWrapper</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="逐出缓存"><a href="#逐出缓存" class="headerlink" title="逐出缓存"></a>逐出缓存</h4><blockquote><p>适用于注解@CacheEvict，根据属性beforeInvocation 确定是在调用方法之前还是成功之后逐出缓存</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key逐出缓存 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">invalidate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 指定key逐出缓存，如果该key存在并且逐出成功，则返回true */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">evictIfPresent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><blockquote><p>关于redis就不必多介绍了，大家经常用哈哈<br>Spring 将redis相关的 都放在 spring-data-redis中，如果是Springboot应用需要引入spring-boot-starter-data-redis</p></blockquote><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 要引入，用作redis连接池，否则会报错 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="声明缓存类型-1"><a href="#声明缓存类型-1" class="headerlink" title="声明缓存类型"></a>声明缓存类型</h3><h4 id="配置声明-1"><a href="#配置声明-1" class="headerlink" title="配置声明"></a>配置声明</h4><pre class=" language-YAML"><code class="language-YAML">spring:  cache:    type: redis  redis:    host: 127.0.0.1    port: 6379    timeout: 10000    database: 0    lettuce:      pool:        max-active: 100        max-wait: -1        max-idle: 8        min-idle: 0</code></pre><br /><h3 id="RedisCacheConfiguration"><a href="#RedisCacheConfiguration" class="headerlink" title="RedisCacheConfiguration"></a>RedisCacheConfiguration</h3><blockquote><p>Redis缓存配置类，主要用来创建Redis缓存管理器，需要结合上面的配置 才能正常创建 bean</p></blockquote><p>同样在该类上也做了约束，如Redis的连接工厂的class需要在类路径上，需要在redis配置bean加载后再加载该类，需要先在当前上下文中加载Redis连接工厂后再加载该类。</p><pre class=" language-JAVA"><code class="language-JAVA">@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisConnectionFactory.class)@AutoConfigureAfter(RedisAutoConfiguration.class)@ConditionalOnBean(RedisConnectionFactory.class)@ConditionalOnMissingBean(CacheManager.class)@Conditional(CacheCondition.class)class RedisCacheConfiguration {    @Bean    RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,            ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,            ObjectProvider<RedisCacheManagerBuilderCustomizer> redisCacheManagerBuilderCustomizers,            RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) {        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(                determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));        List<String> cacheNames = cacheProperties.getCacheNames();        if (!cacheNames.isEmpty()) {            builder.initialCacheNames(new LinkedHashSet<>(cacheNames));        }        redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));        return cacheManagerCustomizers.customize(builder.build());    }}</code></pre><br /><h3 id="RedisCacheManager"><a href="#RedisCacheManager" class="headerlink" title="RedisCacheManager"></a>RedisCacheManager</h3><blockquote><p>在上面的RedisCacheConfiguration中，它负责加载RedisCacheManager，通过<code>builder.build()</code></p></blockquote><h4 id="加载缓存管理器"><a href="#加载缓存管理器" class="headerlink" title="加载缓存管理器"></a>加载缓存管理器</h4><blockquote><p>这一步主要在Spring初始化的过程中，先指定一定约束条件加载RedisCacheConfiguration，再再加载缓存管理器。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> RedisCacheManager <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    RedisCacheManager cm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">(</span>cacheWriter<span class="token punctuation">,</span> defaultCacheConfiguration<span class="token punctuation">,</span> initialCaches<span class="token punctuation">,</span>            allowInFlightCacheCreation<span class="token punctuation">)</span><span class="token punctuation">;</span>    cm<span class="token punctuation">.</span><span class="token function">setTransactionAware</span><span class="token punctuation">(</span>enableTransactions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cm<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="加载缓存实例-1"><a href="#加载缓存实例-1" class="headerlink" title="加载缓存实例"></a>加载缓存实例</h4><blockquote><p>这一步主要在前文提到的，在CacheAspectSupport类中构造缓存上下文的过程（祥看<code>org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContext#CacheOperationContext</code>）创建的</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">@Overrideprotected RedisCache getMissingCache(String name) {    return allowInFlightCacheCreation ? createRedisCache(name, defaultCacheConfig) : null;}</code></pre><br /><h3 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h3><h4 id="构造缓存实例-1"><a href="#构造缓存实例-1" class="headerlink" title="构造缓存实例"></a>构造缓存实例</h4><blockquote><p>上面提到，在CacheAspectSupport类中构造缓存上下文的过程中，会同时加载缓存实例，下面看如何创建</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">protected RedisCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) {    super(cacheConfig.getAllowCacheNullValues());    Assert.notNull(name, "Name must not be null!");    Assert.notNull(cacheWriter, "CacheWriter must not be null!");    Assert.notNull(cacheConfig, "CacheConfig must not be null!");    this.name = name;    this.cacheWriter = cacheWriter;    this.cacheConfig = cacheConfig;    this.conversionService = cacheConfig.getConversionService();}</code></pre><h4 id="获取缓存-2"><a href="#获取缓存-2" class="headerlink" title="获取缓存"></a>获取缓存</h4><pre class=" language-JAVA"><code class="language-JAVA">/** * Caffeine的同步方式是基于ConcurrentHashMap实现的，而基于Redis的同步方式是使用synchronized实现 * 注意，这里我们可以看到，无论是否能获取缓存，这里始终是同步的 * @param valueLoader    待执行的注解方法，在无缓存时调用 */public synchronized <T> T get(Object key, Callable<T> valueLoader) {    // 将缓存包装成ValueWrapper，存在则直接返回    ValueWrapper result = get(key);    if (result != null) {        return (T) result.get();    }    T value = valueFromLoader(key, valueLoader);    put(key, value);    return value;}protected Object lookup(Object key) {    byte[] value = cacheWriter.get(name, createAndConvertCacheKey(key));    if (value == null) {        return null;    }    // 使用反序列化器将值进行反序列化    return deserializeCacheValue(value);}</code></pre><h4 id="存储缓存-1"><a href="#存储缓存-1" class="headerlink" title="存储缓存"></a>存储缓存</h4><blockquote><p>在上一步获取不到缓存，进而调用注解方法得到结果后，开始存储缓存</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">public void put(Object key, @Nullable Object value) {    // 这里会做校验，是否配置了运行存储NULL值，如果不支持NULL值并且结果为NULL，则将其置为NullValue    Object cacheValue = preProcessCacheValue(value);    if (!isAllowNullValues() && cacheValue == null) {        throw new IllegalArgumentException(String.format(                "Cache '%s' does not allow 'null' values. Avoid storing null via '@Cacheable(unless=\"#result == null\")' or configure RedisCache to allow 'null' via RedisCacheConfiguration.",                name));    }    cacheWriter.put(name, createAndConvertCacheKey(key), serializeCacheValue(cacheValue), cacheConfig.getTtl());}</code></pre><h4 id="逐出缓存-1"><a href="#逐出缓存-1" class="headerlink" title="逐出缓存"></a>逐出缓存</h4><blockquote><p>适用于注解@CacheEvict，根据属性beforeInvocation 确定是在调用方法之前还是成功之后逐出缓存<br>调用方法详细可查看：<code>org.springframework.cache.interceptor.CacheAspectSupport#execute(org.springframework.cache.interceptor.CacheOperationInvoker, java.lang.reflect.Method, org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContexts)</code></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定缓存名称和key逐出缓存 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cacheWriter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createAndConvertCacheKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于其他缓存及其处理器，方式差不多和以上两个一样，这里就不一一列举了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>可以发现，Spring内置的缓存处理机制，只适用于单个缓存的场景之下。而当我们需要考虑多级缓存的时候，貌似很难着手，这时可以通过以上的源码分析思考下，如何自定义（多级）缓存。</p><p>在下一篇中，我将会进行实战如何自定义（多级）缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring缓存挖掘机（一）- demo及源码剖析</title>
      <link href="/2020/07/10/spring-huan-cun-wa-jue-ji-1-demo-ji-yuan-ma-pou-xi/"/>
      <url>/2020/07/10/spring-huan-cun-wa-jue-ji-1-demo-ji-yuan-ma-pou-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于系统中存在多方请求设备服务获取设备运行状态的现象，易出现重复请求的问题，故需要使用缓存去减缓调取频率，具体的方案是多级缓存操作<br />本地缓存+redis缓存+调设备服务（慢，耗资源）<br />先查本地缓存，若无则查redis缓存，否则再调服务<br /><br><br /></p><h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><p>先看下市面上现有的缓存框架有哪些<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1592883820155-ce76c20f-9f94-46a0-9a19-c36155b8a577.png#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=594&size=23107&status=done&style=none&width=594#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&originHeight=363&originWidth=594&status=done&style=none&width=594" alt="image.png"><br /><br><br /></p><p><a name="4b87a15b"></a></p><h2 id="Spring-内置缓存组件"><a href="#Spring-内置缓存组件" class="headerlink" title="Spring 内置缓存组件"></a>Spring 内置缓存组件</h2><p><br />先阅读下官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-caching" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-caching</a><br /></p><h3 id="Spring缓存管理器"><a href="#Spring缓存管理器" class="headerlink" title="Spring缓存管理器"></a>Spring缓存管理器</h3><p>阅读文档可知，Spring提供了中央缓存管理器的底层SPI接口：<code>org.springframework.cache.CacheManager</code>，，在spring-context 模块内。<br>基于它可由各种第三方的缓存管理器去实现和扩展，目前Spring 同样内置了以下几种第三方缓存组件管理器，命名规范为***Manager<br /></p><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212726143_1059579798.png" alt="缓存管理器"></p><br /><h3 id="Spring缓存"><a href="#Spring缓存" class="headerlink" title="Spring缓存"></a>Spring缓存</h3><p>Spring 也提供了缓存通用操作接口<code>org.springframework.cache.Cache</code>，在spring-context 模块内<br>而在Cache接口下，Spring内置了几种市面上常见缓存方案的实现，命名规范为<code>***Cache</code></p><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200711230414394_1325718760.png" alt="cache"></p><p>以上，RedisCache位于spring-data-redis，其他的都在spring-context-support中。<br>注意，可以看到，在Spring5 中 已经没了GuavaCache的身影，取而代之的是Caffeine。</p><table><thead><tr><th>缓存</th><th>说明</th></tr></thead><tbody><tr><td>CaffeineCache</td><td>是通过JAVA8对Guava缓存的重写版本，（在Spring5）取代了对Guava缓存的支持，在5.2.4中要求Caffeine版本为2.1或以上</td></tr><tr><td>ConcurrentMapCache</td><td>基于ConcurrentMap实现的缓存技术，无过期时间，需手动删除</td></tr><tr><td>JCacheCache</td><td>基于JCache标准的实现作为缓存技术</td></tr><tr><td>RedisCache</td><td>基于Redis实现的缓存技术</td></tr><tr><td>EhCacheCache</td><td>基于EhCache实现的缓存技术</td></tr><tr><td>NoOpCache</td><td>不会实际存储缓存，适用于禁用缓存的无操作实现</td></tr></tbody></table><p>而在Springboot中，通过<code>org.springframework.boot.autoconfigure.cache.CacheType</code>可以发现，Springboot还支持了其他类型的缓存框架</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> CacheType <span class="token punctuation">{</span>    GENERIC<span class="token punctuation">,</span>    JCACHE<span class="token punctuation">,</span>    EHCACHE<span class="token punctuation">,</span>    HAZELCAST<span class="token punctuation">,</span>    INFINISPAN<span class="token punctuation">,</span>    COUCHBASE<span class="token punctuation">,</span>    REDIS<span class="token punctuation">,</span>    CAFFEINE<span class="token punctuation">,</span>    SIMPLE<span class="token punctuation">,</span>    NONE<span class="token punctuation">}</span></code></pre><p>这里也大概说明一下</p><table><thead><tr><th>缓存</th><th>说明</th></tr></thead><tbody><tr><td>HAZELCAST</td><td>全称是Hazelcast IMDG (In-Memory Data Grid)，内存数据网格<br />是一个<strong>开源的分布式内存</strong>数据存储和计算平台<br />提供多种分布式数据结构如Map/Queue/Topic等<br /></td></tr><tr><td>INFINISPAN</td><td>是一款基于Apache v2.0版本的开源数据网格系统</td></tr><tr><td>COUCHBASE</td><td>是一款非关系型数据库，MemBase（存储键值对）与couchDb（存储json文档）这两个NoSQL数据库合并的产物，</td></tr></tbody></table></br><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>增加了对应的注解方式以支持缓存功能：@EnableCaching、@CacheConfig、@Cacheable、@CachePut、@CacheEvict等</p><h4 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h4><blockquote><p>启用Springboot 的缓存管理功能，等同于&lt;cache: * &gt; 的xml文件配置。当开启时，CacheManager的bean<strong>必须</strong>指定手动注册，目前暂未有合理的缓存框架可以用作惯例。<br>当要将 <code>@EnableCaching</code>与CacheManager等建立合理的联系时，Spring已经提供了接口<code>CachingConfigurer</code>用于实现</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>是否要基于cglib的代理方式，缺省为false，即基于jdk动态代理</td></tr><tr><td>mode</td><td>代理实现方式（动态代理PROXY，静态代理ASPECTJ），缺省为动态代理</td></tr></tbody></table><h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><blockquote><p><strong>类级别</strong>的注解。用于提供一种在类级别共享与缓存相关的配置。当注解在类上时，会提供基于该类的默认配置，即可能被覆盖</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>cacheNames</td><td>缓存操作对应的名称，可多个</td></tr><tr><td>keyGenerator</td><td>要使用的自定义key生成器的bean名称，当缓存操作未设置任何值时，使用它替代默认值</td></tr><tr><td>cacheManager</td><td>要使用的自定义cacheManager的bean名称，当缓存操作未设置解析器和管理器时，且没通过cacheResolver属性设置解析器时，使用它替代默认值</td></tr><tr><td>cacheResolver</td><td>要使用的自定义cacheResolver的bena名称，当缓存操作未设置解析器和管理器时，使用它替代默认值</td></tr></tbody></table><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><blockquote><p>被注解的方法，支持在有缓存时直接返回，无缓存（或缓存过期）时执行方法，并在方法返回时指定缓存名称和key缓存最新数据<br>适用场景：注解方法需要做缓存以 缓解调用频率对底层service/db的影响，通过过期时间可灵活设置数据更新</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>cacheNames</td><td>缓存操作对应的名称，可多个</td></tr><tr><td>value</td><td>同上</td></tr><tr><td>key</td><td>默认使用方法参数作为key值，也可以借助SpEL表达式组装key值</td></tr><tr><td>keyGenerator</td><td>与key功能互斥，要使用的自定义cacheManager的bean名称，可以实现org.springframework.cache.interceptor.KeyGenerator使用</td></tr><tr><td>cacheManager</td><td>要使用的自定义cacheManager的bean名称</td></tr><tr><td>cacheResolver</td><td>与cacheManager互斥，要使用的自定义cacheResolver的bena名称</td></tr><tr><td>condition</td><td>缓存条件，使用SpEL表达式来实现，只有条件成立才会缓存</td></tr><tr><td>unless</td><td>否决缓存条件，使用SpEL表达式来实现，即在方法调用后执行该条件，只有条件不成立才会缓存</td></tr><tr><td>sync</td><td>是否开启同步调用，默认false，当为true时多线程执行时则会同步调用注解方法（注意，前提需要第三方缓存框架提供同步支持，自定义实现时也要考虑）</td></tr></tbody></table><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><blockquote><p>与@Cacheable相反，它会一直执行注解方法而不会跳过，并每次将结果存储在缓存中，底层触发Cache的put()<br>适用场景：注解方法需要被调用以及时更新缓存</p></blockquote><p>它的属性和@Cacheable 一样，只不过少了sync，因为它不需考虑是否要同步调用</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><blockquote><p> 被注解的方法，支持在调用方法前/后 执行缓存逐出操作，底层触发Cache的evict()<br>适用场景：注解方法需要在特定时间被调用以逐出缓存，例如一个设备启动并结束后，关乎它的某些状态已无需维护，故在结束那一刻逐出缓存</p></blockquote><p>它的属性和@Cacheable也差不多，下面看些不一样的属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>allEntries</td><td>是否逐出指定缓存名称下的所有key，缺省为false，仅逐出指定key的缓存；true则在方法执行成功后逐出所有key的缓存</td></tr><tr><td>beforeInvocation</td><td>是否在调用方法之前逐出指定key缓存，缺省为false，当方法执行成功后才会逐出缓存；true则无需关心方法的调用结果，直接逐出</td></tr></tbody></table></br><h2 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h2><p>在分析源码之前，先使用一个demo来分析（注意，这里要引入caffeine的依赖）<br /></p><ul><li>先定义了一个缓存的配置类CustomCacheConfig，使用@EnableCaching开启缓存支持，定义缓存名称，初始化缓存管理器CaffeineCacheManager，带入缓存名称。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 全局缓存名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String cacheName <span class="token operator">=</span> <span class="token string">"saas-cache"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCacheManager</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>编写一个service接口和实现类，在其接口方法上添加缓存注解，sync代表同步访问</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DemoService</span> <span class="token punctuation">{</span>    String <span class="token function">getData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clearData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">DemoService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> SaasCacheConfig<span class="token punctuation">.</span>cacheName<span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#s1.concat(#s2)"</span><span class="token punctuation">,</span> sync <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"none cache, start to save..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>value <span class="token operator">=</span> SaasCacheConfig<span class="token punctuation">.</span>cacheName<span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#s1.concat(#s2)"</span><span class="token punctuation">,</span> beforeInvocation <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// empty method</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>编写测试用例，先调用带有@CacheEvict注解的方法进行缓存清除，再多线程执行带有@Cacheable注解的方法，测试是否支持同步访问</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"source.cache"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCache</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    DemoService demoService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoService<span class="token punctuation">.</span><span class="token function">clearData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>输出结果，验证了@Cacheable和@CacheEvict的作用</li></ul><pre><code>none cache, start to save...successsuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccessnone cache, start to save...success</code></pre><br /><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先在实现方法上打断点<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212815509_1714130693.png" alt="debug1"><br><br />运行测试用例，断点内容如下<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212855279_1874790059.png" alt="debug2"><br />上图断点转换成大致流程如下<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710213050157_990479030.png" alt="flow_chart"><br />Spring提供了<code>org.springframework.cache.interceptor.CacheInterceptor</code>和<code>org.springframework.cache.interceptor.CacheAspectSupport</code>用于声明式缓存<br /></p><h3 id="CacheAspectSupport"><a href="#CacheAspectSupport" class="headerlink" title="CacheAspectSupport"></a>CacheAspectSupport</h3><p>该类包含了与Spring基础的缓存api的集成功能。<br /><br>下面分析下源码<br /></p><h4 id="拦截器进入到execute"><a href="#拦截器进入到execute" class="headerlink" title="拦截器进入到execute()"></a>拦截器进入到execute()</h4><p>每次进行切面，都会执行execute()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">execute</span><span class="token punctuation">(</span>CacheOperationInvoker invoker<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取被代理类</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> <span class="token function">getTargetClass</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取可操作的缓存资源并指定被代理类+方法进行过滤，得到一个可操作集合</span>        CacheOperationSource cacheOperationSource <span class="token operator">=</span> <span class="token function">getCacheOperationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheOperationSource <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Collection<span class="token operator">&lt;</span>CacheOperation<span class="token operator">></span> operations <span class="token operator">=</span> cacheOperationSource<span class="token punctuation">.</span><span class="token function">getCacheOperations</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>operations<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">execute</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> method<span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">CacheOperationContexts</span><span class="token punctuation">(</span>operations<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> target<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面得到的缓存操作对象CacheOperation 如下</p><pre><code>Builder[public java.lang.String source.cache.service.DemoServiceImpl.getData(java.lang.String,java.lang.String,java.lang.Integer)] caches=[saas-cache] | key=&#39;#s1.concat(#s2)&#39; | keyGenerator=&#39;&#39; | cacheManager=&#39;&#39; | cacheResolver=&#39;&#39; | condition=&#39;&#39; | unless=&#39;&#39; | sync=&#39;true&#39;</code></pre><h4 id="构造缓存操作上下文"><a href="#构造缓存操作上下文" class="headerlink" title="构造缓存操作上下文"></a>构造缓存操作上下文</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CacheOperationContexts</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">CacheOperation</span><span class="token operator">></span> operations<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>contexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedMultiValueMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>operations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>CacheOperation op <span class="token operator">:</span> operations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>contexts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getOperationContext</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> target<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token function">determineSyncFlag</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CacheOperationContext</span><span class="token punctuation">(</span>CacheOperationMetadata metadata<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>metadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> <span class="token function">extractArgs</span><span class="token punctuation">(</span>metadata<span class="token punctuation">.</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>caches <span class="token operator">=</span> CacheAspectSupport<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCaches</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> metadata<span class="token punctuation">.</span>cacheResolver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cacheNames <span class="token operator">=</span> <span class="token function">createCacheNames</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>caches<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="创建缓存实例"><a href="#创建缓存实例" class="headerlink" title="创建缓存实例"></a>创建缓存实例</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// org.springframework.cache.interceptor.CacheAspectSupport#getCaches</span><span class="token keyword">protected</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> <span class="token function">getCaches</span><span class="token punctuation">(</span>        CacheOperationInvocationContext<span class="token operator">&lt;</span>CacheOperation<span class="token operator">></span> context<span class="token punctuation">,</span> CacheResolver cacheResolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> caches <span class="token operator">=</span> cacheResolver<span class="token punctuation">.</span><span class="token function">resolveCaches</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>caches<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No cache could be resolved for '"</span> <span class="token operator">+</span>                context<span class="token punctuation">.</span><span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"' using resolver '"</span> <span class="token operator">+</span> cacheResolver <span class="token operator">+</span>                <span class="token string">"'. At least one cache should be provided per cache operation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> caches<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// org.springframework.cache.interceptor.AbstractCacheResolver#resolveCaches</span><span class="token keyword">public</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> <span class="token function">resolveCaches</span><span class="token punctuation">(</span>CacheOperationInvocationContext<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames <span class="token operator">=</span> <span class="token function">getCacheNames</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collection<span class="token operator">&lt;</span>Cache<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>cacheNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String cacheName <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前设置的缓存管理器中指定名称的缓存实例</span>        Cache cache <span class="token operator">=</span> <span class="token function">getCacheManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Cannot find cache named '"</span> <span class="token operator">+</span>                    cacheName <span class="token operator">+</span> <span class="token string">"' for "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="若开启了同步模式"><a href="#若开启了同步模式" class="headerlink" title="若开启了同步模式"></a>若开启了同步模式</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">final</span> CacheOperationInvoker invoker<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> CacheOperationContexts contexts<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果开启了同步（即sync=true），则进入if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">isSynchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CacheOperationContext context <span class="token operator">=</span> contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当注解上添加条件condition时，这里需要校验是否通过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isConditionPassing</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取key值</span>            Object key <span class="token operator">=</span> <span class="token function">generateKey</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 得到具体的缓存对象，基于SPI机制，这里可以出现不同类型的缓存对象，如CaffeineCache</span>            Cache cache <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如何同步处理的核心就在cache.get这里，不同的缓存组件已经对应封装了同步逻辑，如果缓存存在则直接返回，不存在则同步获取资源</span>                <span class="token comment" spellcheck="true">// </span>                <span class="token keyword">return</span> <span class="token function">wrapCacheValue</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">unwrapReturnValue</span><span class="token punctuation">(</span><span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Cache<span class="token punctuation">.</span>ValueRetrievalException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// The invoker wraps any Throwable in a ThrowableWrapper instance so we</span>                <span class="token comment" spellcheck="true">// can just make sure that one bubbles up the stack.</span>                <span class="token keyword">throw</span> <span class="token punctuation">(</span>CacheOperationInvoker<span class="token punctuation">.</span>ThrowableWrapper<span class="token punctuation">)</span> ex<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 条件不通过，无需缓存直接调用基础方法</span>            <span class="token keyword">return</span> <span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="若是异步模式（默认）"><a href="#若是异步模式（默认）" class="headerlink" title="若是异步模式（默认）"></a>若是异步模式（默认）</h4><h5 id="执行前清除缓存"><a href="#执行前清除缓存" class="headerlink" title="执行前清除缓存"></a>执行前清除缓存</h5><pre class=" language-java"><code class="language-java"><span class="token function">processCacheEvicts</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheEvictOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>若方法注解是@CacheEvict，且设置了属性beforeInvocation为true，则会在执行注解方法之前清除缓存</p><p>清除代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doEvict</span><span class="token punctuation">(</span>Cache cache<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> <span class="token keyword">boolean</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">evictIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleCacheEvictError</span><span class="token punctuation">(</span>ex<span class="token punctuation">,</span> cache<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清除主要调用了缓存实现对应的<code>evictIfPresent</code>或<code>evict</code>方法</p><h5 id="缓存主逻辑"><a href="#缓存主逻辑" class="headerlink" title="缓存主逻辑"></a>缓存主逻辑</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">final</span> CacheOperationInvoker invoker<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> CacheOperationContexts contexts<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 校验上下文是否命中了缓存操作对象CacheableOperation，如果当前是清除操作则不命中</span>    Cache<span class="token punctuation">.</span>ValueWrapper cacheHit <span class="token operator">=</span> <span class="token function">findCachedItem</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果找不到则收集未命中的缓存</span>    List<span class="token operator">&lt;</span>CachePutRequest<span class="token operator">></span> cachePutRequests <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheHit <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">collectPutRequests</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">,</span> cachePutRequests<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Object cacheValue<span class="token punctuation">;</span>    Object returnValue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果命中缓存，并且没有收集缓存，则获取缓存数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheHit <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasCachePut</span><span class="token punctuation">(</span>contexts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cacheValue <span class="token operator">=</span> cacheHit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        returnValue <span class="token operator">=</span> <span class="token function">wrapCacheValue</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        returnValue <span class="token operator">=</span> <span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>        cacheValue <span class="token operator">=</span> <span class="token function">unwrapReturnValue</span><span class="token punctuation">(</span>returnValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 收集任何显式的 @CachePuts</span>    <span class="token function">collectPutRequests</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CachePutOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cacheValue<span class="token punctuation">,</span> cachePutRequests<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Process any collected put requests, either from @CachePut or a @Cacheable miss</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>CachePutRequest cachePutRequest <span class="token operator">:</span> cachePutRequests<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cachePutRequest<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="执行后清除缓存"><a href="#执行后清除缓存" class="headerlink" title="执行后清除缓存"></a>执行后清除缓存</h5><pre class=" language-java"><code class="language-java"><span class="token function">processCacheEvicts</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheEvictOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>若方法注解是@CacheEvict，且设置了属性beforeInvocation为false（缺省），则会在执行注解方法<strong>成功</strong>后清除缓存<br><br /></p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>作为拦截器的角色，派生于<code>CacheAspectSupport</code>的，spring获取拦截链时，会拿到CacheInterceptor并执行切面逻辑<br><br /></p><p>下一篇继续研究几种缓存方案的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS集成lambda+ApiGateway</title>
      <link href="/2020/06/04/aws-ji-cheng-lambda-apigateway/"/>
      <url>/2020/06/04/aws-ji-cheng-lambda-apigateway/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目不大，但是使用了AWS的服务，挺贵的。。咨询了AWS的技术人员后，他们提供了lambda + Apigateway的方案，可以节省很多的资源。<br /><br><br />尝试过以java为开发语言，springboot为函数框架，冷启动时间很长，响应慢的情况下，还会导致收费增加，故我这里改成脚本语言去实现<br /></p><p><a name="9cjSK"></a></p><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p><a name="nTF9S"></a></p><h3 id="1-创建lamda函数"><a href="#1-创建lamda函数" class="headerlink" title="1. 创建lamda函数"></a>1. 创建lamda函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1589954896351-0c676797-73b9-468b-af75-865b5be48f62.png#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&name=image.png&originHeight=367&originWidth=1795&size=33210&status=done&style=none&width=1795" alt="image.png"><br />下面创建了一个函数名为test-function，运行时为python<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663472276-7f372b8f-fd59-4c05-b1cc-238848425296.png#align=left&display=inline&height=755&margin=%5Bobject%20Object%5D&name=image.png&originHeight=755&originWidth=1794&size=84896&status=done&style=none&width=1794" alt="image.png"><br /></p><p><a name="M1May"></a></p><h3 id="2-配置测试事件"><a href="#2-配置测试事件" class="headerlink" title="2. 配置测试事件"></a>2. 配置测试事件</h3><p>主要用于测试这个函数有没有跑成功<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663537636-1b758b45-a1e5-4a1c-9c4a-afc530b3756a.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=117&originWidth=676&size=8127&status=done&style=none&width=676" alt="image.png"><br />下面配置了一个事件名称为test的测试事件<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1589956651446-b410c5f1-f57d-4718-a61e-08cfeac2cb38.png#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=826&size=32547&status=done&style=none&width=826" alt="image.png"><br /></p><p><a name="I7wNH"></a></p><h3 id="3-添加函数代码"><a href="#3-添加函数代码" class="headerlink" title="3. 添加函数代码"></a>3. 添加函数代码</h3><p>由于上面设置的运行时环境是JAVA8，AWS暂时不支持在面板上编辑代码，故我们可以通过本地写完代码后，上传到S3、或者直接手动上传。这个待定~~<br><a name="HdGAJ"></a></p><h4 id="使用python实现一个函数"><a href="#使用python实现一个函数" class="headerlink" title="使用python实现一个函数"></a>使用python实现一个函数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'queryStringParameters'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span>    protocol <span class="token operator">=</span> <span class="token string">'http'</span>    domain_name <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'domainName'</span><span class="token punctuation">]</span>    request_url <span class="token operator">=</span> protocol <span class="token operator">+</span> <span class="token string">'://'</span> <span class="token operator">+</span> domain_name <span class="token operator">+</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'path'</span><span class="token punctuation">]</span>    request_ip <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'identity'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'sourceIp'</span><span class="token punctuation">]</span>    param <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'queryStringParameters'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> param <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"statusCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">'error.'</span><span class="token punctuation">}</span>    param_size <span class="token operator">=</span> len<span class="token punctuation">(</span>param<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> param_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        param_str <span class="token operator">=</span> <span class="token string">'?'</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">in</span> param<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        param_str <span class="token operator">=</span> param_str <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'&amp;'</span>    param_str <span class="token operator">=</span> param_str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    request_url <span class="token operator">=</span> request_url <span class="token operator">+</span> param_str    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'request url :'</span><span class="token punctuation">,</span> request_url<span class="token punctuation">,</span> <span class="token string">', request ip :'</span><span class="token punctuation">,</span> request_ip<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"statusCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">'success.'</span><span class="token punctuation">}</span></code></pre><p>注意，如果用到了其他需安装的依赖的话，需要先将依赖下载到和python文件同个文件夹下</p><pre class=" language-shell"><code class="language-shell">pip install pymsql -t .</code></pre><p>如下，我安装了pymsql的依赖到文件夹中，并将其和python文件一起打成zip包，用于上传到lambda后台<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663135995-fa241d55-774f-4a3a-8baf-acdc1561e52d.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=87&originWidth=261&size=4027&status=done&style=none&width=261" alt="image.png"><br />接着开始上传函数文件，后台支持在线编辑代码，但是由于函数引了其他依赖，故以zip包上传的形式打包上去<br />这里需要注意，处理程序要对应修改，形式为：文件名.方法名<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663678059-be7b88fd-7851-4e2a-b3e9-a1a373c5786a.png#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=1624&size=26931&status=done&style=none&width=1624" alt="image.png"><br /><br><br />上传后效果如下<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663787533-95eb8e9a-4cce-48d2-813a-2418eb03ed25.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&name=image.png&originHeight=586&originWidth=1488&size=70260&status=done&style=none&width=1488" alt="image.png"><br /></p><p><a name="pINrp"></a></p><h3 id="4-配置lambda环境"><a href="#4-配置lambda环境" class="headerlink" title="4. 配置lambda环境"></a>4. 配置lambda环境</h3><p><a name="GuVrW"></a></p><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p>可根据函数实际运行情况，对其分配超时时间和内存<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663814291-ed8334ee-9924-476e-83b6-fbe7318e7a50.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=814&size=11185&status=done&style=none&width=814" alt="image.png"><br /></p><p><a name="RbgOX"></a></p><h4 id="并发设置"><a href="#并发设置" class="headerlink" title="并发设置"></a>并发设置</h4><p>可默认不改，使用预置并发需要收费<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663878594-1da573f8-941e-401c-abdf-b3f3ed2f1602.png#align=left&display=inline&height=548&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=1596&size=43076&status=done&style=none&width=1596" alt="image.png"><br /></p><p><a name="OBySq"></a></p><h4 id="VPC设置"><a href="#VPC设置" class="headerlink" title="VPC设置"></a>VPC设置</h4><p>当需要调用其他aws服务时，需要配置再同个VPC下<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663931128-187af22c-fbc8-4b6a-a41a-2a7fd45773cb.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=1642&size=17212&status=done&style=none&width=1642" alt="image.png"><br /></p><p><a name="FrfvT"></a></p><h3 id="5-API-Gateway创建一个API"><a href="#5-API-Gateway创建一个API" class="headerlink" title="5. API Gateway创建一个API"></a>5. API Gateway创建一个API</h3><ul><li>若用到了aws服务，则用REST API，否则可使用HTTP API</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664056048-cf85f66c-6f4f-477f-afae-d24f07ba096e.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=763&size=47464&status=done&style=none&width=763" alt="image.png"></p><ul><li>终端节点类型默认选择区域性，目前仅在一个区域内操作</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664187817-35fc3f99-41d8-4543-b18e-dec83f104548.png#align=left&display=inline&height=553&margin=%5Bobject%20Object%5D&name=image.png&originHeight=553&originWidth=935&size=40197&status=done&style=none&width=935" alt="image.png"><br><a name="xELRF"></a></p><h3 id="6-创建资源和方法"><a href="#6-创建资源和方法" class="headerlink" title="6. 创建资源和方法"></a>6. 创建资源和方法</h3><ul><li>先创建一个get请求的方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664293392-ccccd835-61cb-4d03-8ec1-92c0a216562d.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=442&originWidth=691&size=35170&status=done&style=none&width=691" alt="image.png"></p><ul><li>托管给lambda代理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664340173-05fe4e25-892d-4053-82a9-f4da56c0ff1e.png#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&name=image.png&originHeight=508&originWidth=918&size=26734&status=done&style=none&width=918" alt="image.png"></p><ul><li>再新创建一个资源</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664428852-cf003ceb-216e-4214-a9a5-637937880131.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=720&size=40343&status=done&style=none&width=720" alt="image.png"></p><ul><li>资源主要是对应一个路径参数，如<a href="http://localhost/pets/p，则需要先创建一个资源路径为pets，再创建一个资源路径为p，再在资源p下创建一个方法，用于访问该接口" target="_blank" rel="noopener">http://localhost/pets/p，则需要先创建一个资源路径为pets，再创建一个资源路径为p，再在资源p下创建一个方法，用于访问该接口</a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664452523-f1b8e30c-22b4-4f04-857d-7beef080a5d0.png#align=left&display=inline&height=415&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=1054&size=31713&status=done&style=none&width=1054" alt="image.png"></p><ul><li>最终效果如下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664613111-c9a88799-1a45-44cc-92d0-044daf10e2ac.png#align=left&display=inline&height=561&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1762&size=63494&status=done&style=none&width=1762" alt="image.png"></p><ul><li>可对每个方法进行测试，这里不多讲，主要讲部署</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664646244-9799a21d-afb5-4825-9197-99cb3ff4c23c.png#align=left&display=inline&height=565&margin=%5Bobject%20Object%5D&name=image.png&originHeight=565&originWidth=712&size=43518&status=done&style=none&width=712" alt="image.png"></p><ul><li>部署阶段名称为test，当发布生产时，可改为prod</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664658831-7d4d2e61-79bf-4889-9aa4-d6b0de36a6eb.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=600&size=21600&status=done&style=none&width=600" alt="image.png"></p><ul><li>部署成功，如下，</li></ul><p>访问url：<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test?data=1" target="_blank" rel="noopener">https://****.com/test?data=1</a>，可返回函数内定义的“success”<br />访问url：<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test/pets?data=1" target="_blank" rel="noopener">https://***m/test/pets?data=1</a>，同样可返回“success”<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664761645-44cb4f05-60bb-411f-8ca4-0f66f56adfb7.png#align=left&display=inline&height=745&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1508&size=77565&status=done&style=none&width=1508" alt="image.png"><br /><br><br /></p><p><a name="YGQO9"></a></p><h3 id="7-配置自定义域名"><a href="#7-配置自定义域名" class="headerlink" title="7. 配置自定义域名"></a>7. 配置自定义域名</h3><p>由于API Gateway 仅支持带证书的域名，所以这里我们要部署证书到aws<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664939795-95c9247a-5466-42ae-b750-627d84fb00d2.png#align=left&display=inline&height=823&margin=%5Bobject%20Object%5D&name=image.png&originHeight=823&originWidth=1581&size=79195&status=done&style=none&width=1581" alt="image.png"><br />我使用的是腾讯云，故在腾讯云申请到免费证书后，上传到ACM后台：<a href="https://us-west-2.console.aws.amazon.com/acm/home?region=us-west-2" target="_blank" rel="noopener">https://us-west-2.console.aws.amazon.com/acm/home?region=us-west-2</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665143414-c869099e-e5b5-43d4-b532-a36c8720facd.png#align=left&display=inline&height=636&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1253&size=47713&status=done&style=none&width=1253" alt="image.png"><br /></p><p><a name="cgASv"></a></p><h3 id="8-域名映射路径"><a href="#8-域名映射路径" class="headerlink" title="8. 域名映射路径"></a>8. 域名映射路径</h3><p>开放接口有：/app/offers/get 和 /offers/get<br><a name="rpGXM"></a></p><h4 id="1-先配置API映射，路径为None"><a href="#1-先配置API映射，路径为None" class="headerlink" title="1. 先配置API映射，路径为None"></a>1. 先配置API映射，路径为None</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590831480790-cb5b3dec-fe08-4c5a-9395-040a0b0d9edd.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=1138&size=13714&status=done&style=none&width=1138" alt="image.png"><br><a name="3T6Tg"></a></p><h4 id="2-在API-内定好资源和方法"><a href="#2-在API-内定好资源和方法" class="headerlink" title="2. 在API 内定好资源和方法"></a>2. 在API 内定好资源和方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590831529725-4f9a134f-0b4e-4bf8-be0d-e876adef1990.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=216&size=6132&status=done&style=none&width=216" alt="image.png"><br /><br><br /><br><br /><del>这里我想实现的是，将原来的<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test?data=1" target="_blank" rel="noopener">https://****.com/test?data=1</a>，通过自定义域名映射成，<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com?data=1</a></del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665287068-d22a62e2-22e2-4337-a9e0-e43361484313.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1637&size=32241&status=done&style=none&width=1637" alt="image.png"><br /><del>以上配置后发现不生效，只能<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com/test?data=1</a></del><br /><br><br /><del>查看资料发现，aws默认给我们生成的url是有特征的</del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665407264-05a69e95-2a46-4e60-87c7-66191b791f03.png#align=left&display=inline&height=467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=1195&size=60799&status=done&style=none&width=1195" alt="image.png"><br /><del>所以在API映射中，我们是无法做到把stage通过映射关系替代掉的</del><br /><br><br /><del>幸好，后面查阅资料，翻到网友已经找到解决方案了：</del><a href="https://www.stacknoob.com/s/jNBYcCaDDAR5e7Y7GLPHbk" target="_blank" rel="noopener"><del>https://www.stacknoob.com/s/jNBYcCaDDAR5e7Y7GLPHbk</del></a><br /><del>创建API（或使用现有的API，并修改资源）并为其提供代理资源，以及源自根路径的简单GET方法，即可实现自定义域名成功映射，不用被 阶段名state 所影响</del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665560580-17ee7c74-f2ea-4d61-8a2b-54239687eb47.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image.png&originHeight=404&originWidth=969&size=32201&status=done&style=none&width=969" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665658504-b2207ca6-64a5-4b59-8f38-4c88f1a22169.png#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=1751&size=63806&status=done&style=none&width=1751" alt="image.png"><br /><br><br /><del>重新部署，访问<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com?data=1</a>，即可成功返回“success”</del><br /><del><br /></del><br><a name="gKHWS"></a></p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p><a name="TZoII"></a></p><h3 id="1-Lambda存在函数有一定的约束条件"><a href="#1-Lambda存在函数有一定的约束条件" class="headerlink" title="1. Lambda存在函数有一定的约束条件"></a>1. Lambda存在函数有一定的约束条件</h3><p>参考<a href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/gettingstarted-limits.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/gettingstarted-limits.html</a><br />实际项目中遇到返回的包体字节太大，导致报错，报错原因是因为LAMBDA函数设置的调用负载同步请求是6MB，实际大于6MB。<br />解决方案：参考<a href="https://theburningmonk.com/2020/04/hit-the-6mb-lambda-payload-limit-heres-what-you-can-do/" target="_blank" rel="noopener">https://theburningmonk.com/2020/04/hit-the-6mb-lambda-payload-limit-heres-what-you-can-do/</a></p>]]></content>
      
      
      <categories>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> AWS Lambda </tag>
            
            <tag> AWS APIGateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（十）优雅退出实现逻辑</title>
      <link href="/2020/06/03/netty-wa-jue-ji-shi-you-ya-tui-chu-shi-xian-luo-ji/"/>
      <url>/2020/06/03/netty-wa-jue-ji-shi-you-ya-tui-chu-shi-xian-luo-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为高性能的异步通讯框架，Netty自身已经封装了优雅退出的实现机制。</p></blockquote><p>本篇内容参考了《Netty进阶之路-跟着案例学Netty》。<br /></p><p><a name="Bc79T"></a></p><h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>在Linux上重新部署程序的时候，通常我们会有两个命令杀掉进程</p><pre class=" language-shell"><code class="language-shell"># 正常停止kill pid# 粗暴停止kill -9 pid</code></pre><p>我们也知道，正常情况下我们不能够使用“kill -9”的方式去停止程序，这会导致很多业务问题，例如</p><ul><li>缓存数据未持久化到磁盘，导致数据丢失；</li><li>正在进行写文件操作，导致文件损坏；</li><li>消息队列中有消息还未处理，导致请求丢失；</li><li>事务操作一半，导致数据混乱</li></ul><p><br />至于Netty为什么要优雅停止，其中涉及到什么场景，继续看下去。<br /></p><p><a name="K1JoG"></a></p><h2 id="为什么要优雅退出"><a href="#为什么要优雅退出" class="headerlink" title="为什么要优雅退出"></a>为什么要优雅退出</h2><ul><li>尽快释放NIO线程和句柄等资源</li><li>当使用flush做批量消息发送时，需要将积压在发送队列中的待发送消息发送完成</li><li>正在写或正在读的消息，需要继续处理</li><li>设置在NioEventLoop线程调度器中的定时任务，需要执行或清理</li></ul><p><a name="Ltetu"></a></p><h2 id="涉及的主要操作和资源对象"><a href="#涉及的主要操作和资源对象" class="headerlink" title="涉及的主要操作和资源对象"></a>涉及的主要操作和资源对象</h2><p><img src="/images/Netty%E6%8C%96%E6%8E%98%E6%9C%BA/Netty%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA.png" alt="Netty优雅退出.png"></p><p><a name="0Cxwm"></a></p><h2 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h2><p>Netty优雅退出的总入口是EventLoopGroup，在之前的《<strong>Netty挖掘机（三）结合spring搭建netty脚手架</strong>》和《<strong>Netty挖掘机（四）结合spring boot搭建netty脚手架</strong>》里，我也用到了优雅退出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@PreDestroy</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    boss<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    worker<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"############# shutdown server... #############"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />如上，我们只要调用无参的<code>shutdownGracefully()</code>即可，当然Netty还开放了指定退出的超时时间和周期的方法，对于强制退出的方法，Netty也已经标注了废弃，实际项目最好不使用。</p><pre class=" language-java"><code class="language-java">Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token keyword">long</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var3<span class="token punctuation">,</span> TimeUnit var5<span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** @deprecated */</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** @deprecated */</span><span class="token annotation punctuation">@Deprecated</span>List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="tSQlf"></a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>流程图<br /></p><p><a name="AS8Hx"></a></p><h3 id="事件循环线程组NioEventLoopGroup"><a href="#事件循环线程组NioEventLoopGroup" class="headerlink" title="事件循环线程组NioEventLoopGroup"></a>事件循环线程组NioEventLoopGroup</h3><p>调用无参的退出方法，传入系统设置的默认关机安静时期和默认关机超时时长</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractEventExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token keyword">implements</span> <span class="token class-name">EventExecutor</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> DEFAULT_SHUTDOWN_QUIET_PERIOD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> DEFAULT_SHUTDOWN_TIMEOUT <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span>DEFAULT_SHUTDOWN_QUIET_PERIOD<span class="token punctuation">,</span> DEFAULT_SHUTDOWN_TIMEOUT<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>接着来到<code>io.netty.util.concurrent.MultithreadEventExecutorGroup#shutdownGracefully()</code><br />遍历EventLoop数组，逐一进行优雅退出操作。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token keyword">long</span> quietPeriod<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>EventExecutor l<span class="token operator">:</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span>quietPeriod<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="9nOAu"></a></p><h3 id="事件循环线程NioEventLoop"><a href="#事件循环线程NioEventLoop" class="headerlink" title="事件循环线程NioEventLoop"></a>事件循环线程NioEventLoop</h3><p>首先我们了解一下<code>``io.netty.util.concurrent.SingleThreadEventExecutor</code>中对线程状态的标识静态常量值</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 未启动</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ST_NOT_STARTED <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 已启动</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ST_STARTED <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 退出中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ST_SHUTTING_DOWN <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 退出</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ST_SHUTDOWN <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终止</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ST_TERMINATED <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><p>在后面退出的过程中， 会一直校验线程状态是否大于等于ST_SHUTTING_DOWN</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> state <span class="token operator">>=</span> ST_SHUTTING_DOWN<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />来到<code>io.netty.util.concurrent.SingleThreadEventExecutor#shutdownGracefully</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token keyword">long</span> quietPeriod<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 此时线程状态为2，已启动</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前线程是否事件循环原生线程</span>    <span class="token keyword">boolean</span> inEventLoop <span class="token operator">=</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> wakeup<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldState<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自旋+原子操作，以作并发保护</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> newState<span class="token punctuation">;</span>        wakeup <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        oldState <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inEventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是事件循环原生线程，则代表是由NioEventLoop线程发起的，此时将状态变为退出中</span>            newState <span class="token operator">=</span> ST_SHUTTING_DOWN<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若线程状态原来是1和2，则将状态变为退出中</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>oldState<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> ST_NOT_STARTED<span class="token operator">:</span>                <span class="token keyword">case</span> ST_STARTED<span class="token operator">:</span>                    newState <span class="token operator">=</span> ST_SHUTTING_DOWN<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    newState <span class="token operator">=</span> oldState<span class="token punctuation">;</span>                    wakeup <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// CAS操作，修改线程状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>STATE_UPDATER<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 代码略</span>    <span class="token keyword">return</span> <span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="ggsSK"></a></p><h4 id="1-（主线程）先判断线程状态是否已退出"><a href="#1-（主线程）先判断线程状态是否已退出" class="headerlink" title="1. （主线程）先判断线程状态是否已退出"></a>1. （主线程）先判断线程状态是否已退出</h4><p><a name="GIeSu"></a></p><h4 id="2-（主线程）自旋-原子操作（CAS）将线程状态改为退出中"><a href="#2-（主线程）自旋-原子操作（CAS）将线程状态改为退出中" class="headerlink" title="2. （主线程）自旋+原子操作（CAS）将线程状态改为退出中"></a>2. （主线程）自旋+原子操作（CAS）将线程状态改为退出中</h4><p>这里为了做并发保护，Netty4 采用了避免加锁的方式：自旋 + 原子操作，而Netty5（<a href="https://github.com/netty/netty/blob/netty-5.0.0.Alpha1/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java" target="_blank" rel="noopener">netty-5.0.0.Alpha1</a>） 则是采用了加锁策略，感兴趣的可以点击前面的链接看看。<br /><br><br />从上面代码看出，Netty 使用<code>AtomicIntegerFieldUpdater</code> 的 <code>compareAndSet</code> 对线程进行修改，若修改成功则退出循环；若发现当前线程的状态已被别的线程修改过，则继续自旋，直到发现线程已经处于ST_SHUTTING_DOWN、ST_SHUTDOWN、ST_TERMINATED的状态，才退出循环。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicIntegerFieldUpdater<span class="token operator">&lt;</span>SingleThreadEventExecutor<span class="token operator">></span> STATE_UPDATER <span class="token operator">=</span>            AtomicIntegerFieldUpdater<span class="token punctuation">.</span><span class="token function">newUpdater</span><span class="token punctuation">(</span>SingleThreadEventExecutor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"state"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="GnTgw"></a></p><h4 id="3-（事件循环线程）执行run方法，关闭注册在Selctor上的所有Channel"><a href="#3-（事件循环线程）执行run方法，关闭注册在Selctor上的所有Channel" class="headerlink" title="3. （事件循环线程）执行run方法，关闭注册在Selctor上的所有Channel"></a>3. （事件循环线程）执行run方法，关闭注册在Selctor上的所有Channel</h4><p>来到<code>io.netty.channel.nio.NioEventLoop#run</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>继续看<code>closeAll()</code>，来到<code>io.netty.channel.nio.NioEventLoop#closeAll</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 重新获取就绪的键</span>    <span class="token function">selectAgain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将注册在Selector上的所有channel组装</span>    Collection<span class="token operator">&lt;</span>AbstractNioChannel<span class="token operator">></span> channels <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>AbstractNioChannel<span class="token operator">></span><span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>SelectionKey k<span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object a <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">AbstractNioChannel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            channels<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractNioChannel<span class="token punctuation">)</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若键不属于通道，则将其取消注册</span>            k<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span> task <span class="token operator">=</span> <span class="token punctuation">(</span>NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>            <span class="token function">invokeChannelUnregistered</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> k<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历曾注册在Selector上的所有channel，将其一个个关闭</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>AbstractNioChannel ch<span class="token operator">:</span> channels<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面循环调用了Channel Unsafe的close方法，来到<code>io.netty.channel.AbstractChannel.AbstractUnsafe#close(io.netty.channel.ChannelPromise)</code><br />可以看到，在<code>AbstractChannel</code>中有一个内部类<code>AbstractUnsafe</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">final</span> ChannelPromise promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ClosedChannelException closedChannelException <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClosedChannelException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> closedChannelException<span class="token punctuation">,</span> closedChannelException<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再看下close方法，来到<code>io.netty.channel.AbstractChannel.AbstractUnsafe#close(io.netty.channel.ChannelPromise, java.lang.Throwable, java.nio.channels.ClosedChannelException, boolean)</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">final</span> ChannelPromise promise<span class="token punctuation">,</span> <span class="token keyword">final</span> Throwable cause<span class="token punctuation">,</span>                   <span class="token keyword">final</span> ClosedChannelException closeCause<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> notify<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果线程已经被取消，则直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>promise<span class="token punctuation">.</span><span class="token function">setUncancellable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 是否已经发起关闭</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closeInitiated<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>closeFuture<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Closed already.</span>            <span class="token function">safeSetSuccess</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>promise <span class="token keyword">instanceof</span> <span class="token class-name">VoidChannelPromise</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Only needed if no VoidChannelPromise.</span>            <span class="token comment" spellcheck="true">// This means close() was called before so we just register a listener and return</span>            closeFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>ChannelFuture future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                    promise<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    closeInitiated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 校验通道是否处于活动状态并已连接</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> wasActive <span class="token operator">=</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将发送队列清空，并不允许发送新的消息</span>    <span class="token keyword">final</span> ChannelOutboundBuffer outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取准备关闭Channel的操作并返回一个执行器</span>    Executor closeExecutor <span class="token operator">=</span> <span class="token function">prepareToClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>closeExecutor <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        closeExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 执行关闭</span>                    <span class="token function">doClose0</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Call invokeLater so closeAndDeregister is executed in the EventLoop again!</span>                    <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token annotation punctuation">@Override</span>                        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">// Fail all the queued messages</span>                                outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span>cause<span class="token punctuation">,</span> notify<span class="token punctuation">)</span><span class="token punctuation">;</span>                                outboundBuffer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>closeCause<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token function">fireChannelInactiveAndDeregister</span><span class="token punctuation">(</span>wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在所有情况下，关闭链路并使排队的消息失败。</span>            <span class="token function">doClose0</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使所有排队的消息失败</span>                outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span>cause<span class="token punctuation">,</span> notify<span class="token punctuation">)</span><span class="token punctuation">;</span>                outboundBuffer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>closeCause<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当前链路是否有消息正在发送，如果有则将SelectionKey的去注册操作封装成task放到EventLoop中稍后执行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inFlush0<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fireChannelInactiveAndDeregister</span><span class="token punctuation">(</span>wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 立即执行SelectionKey的去注册操作</span>            <span class="token function">fireChannelInactiveAndDeregister</span><span class="token punctuation">(</span>wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>主要操作如下：<br><a name="Yu8Ts"></a></p><h5 id="3-1-将发送队列清空，并不允许发送新的消息"><a href="#3-1-将发送队列清空，并不允许发送新的消息" class="headerlink" title="3.1 将发送队列清空，并不允许发送新的消息"></a>3.1 将发送队列清空，并不允许发送新的消息</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> ChannelOutboundBuffer outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><p><a name="lcEq0"></a></p><h5 id="3-2-判断当前链路是否有消息正在发送，若有则将SelectionKey的去注册操作封装成task放到Eventloop线程中执行，否则立即执行去注册操作"><a href="#3-2-判断当前链路是否有消息正在发送，若有则将SelectionKey的去注册操作封装成task放到Eventloop线程中执行，否则立即执行去注册操作" class="headerlink" title="3.2 判断当前链路是否有消息正在发送，若有则将SelectionKey的去注册操作封装成task放到Eventloop线程中执行，否则立即执行去注册操作"></a>3.2 判断当前链路是否有消息正在发送，若有则将SelectionKey的去注册操作封装成task放到Eventloop线程中执行，否则立即执行去注册操作</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>inFlush0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fireChannelInactiveAndDeregister</span><span class="token punctuation">(</span>wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">fireChannelInactiveAndDeregister</span><span class="token punctuation">(</span>wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="fomLG"></a></p><h5 id="3-3-关闭链路并使排队的消息失败：doClose0"><a href="#3-3-关闭链路并使排队的消息失败：doClose0" class="headerlink" title="3.3 关闭链路并使排队的消息失败：doClose0()"></a>3.3 关闭链路并使排队的消息失败：doClose0()</h5><p><code>io.netty.channel.socket.nio.NioSocketChannel#doClose</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="2UYnL"></a></p><h5 id="3-4-触发链路失效通知"><a href="#3-4-触发链路失效通知" class="headerlink" title="3.4 触发链路失效通知"></a>3.4 触发链路失效通知</h5><p><code>io.netty.channel.DefaultChannelPipeline#fireChannelInactive</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> ChannelPipeline <span class="token function">fireChannelInactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AbstractChannelHandlerContext<span class="token punctuation">.</span><span class="token function">invokeChannelInactive</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="mookh"></a></p><h5 id="3-5-从多路复用器上取消selectionkey"><a href="#3-5-从多路复用器上取消selectionkey" class="headerlink" title="3.5 从多路复用器上取消selectionkey"></a>3.5 从多路复用器上取消selectionkey</h5><p><code>io.netty.channel.nio.AbstractNioChannel#doDeregister</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doDeregister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token function">selectionKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="cRgnx"></a></p><h5 id="3-6-释放发送队列中所有尚未发送的bytebuf"><a href="#3-6-释放发送队列中所有尚未发送的bytebuf" class="headerlink" title="3.6 释放发送队列中所有尚未发送的bytebuf"></a>3.6 释放发送队列中所有尚未发送的bytebuf</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span>cause<span class="token punctuation">,</span> notify<span class="token punctuation">)</span><span class="token punctuation">;</span>    outboundBuffer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>closeCause<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>来到<code>io.netty.channel.ChannelOutboundBuffer#close(java.lang.Throwable, boolean)</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">final</span> Throwable cause<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> allowChannelOpen<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代码略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span>cancelled<span class="token punctuation">)</span> <span class="token punctuation">{</span>         ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">safeRelease</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">safeFail</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>promise<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 代码略</span>    <span class="token comment" spellcheck="true">// 从数组中清除所有的buffer，以便进行GC处理</span>    <span class="token function">clearNioBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="aGaez"></a></p><h3 id="任务队列TaskQueue"><a href="#任务队列TaskQueue" class="headerlink" title="任务队列TaskQueue"></a>任务队列TaskQueue</h3><p>Netty在优雅退出中，执行以上操作后，还不能够真正地退出，它仍有一些善后工作需要处理。我们知道，NioEventLoop除了进行I/O读写，还负责定时任务执行，ShutdownHook（非JDK原生）执行等。若此时有到期的定时任务，即使Channel链路关闭后仍要继续执行，线程无法退出。<br /></p><p><a name="UyZU1"></a></p><h4 id="1-确认是否真正退出"><a href="#1-确认是否真正退出" class="headerlink" title="1. 确认是否真正退出"></a>1. 确认是否真正退出</h4><p>在Netty执行了<code>closeAll()</code>关闭了链路、清空发送队列、使排队消息直接失效、SelectionKey的去注册操作 等后，还需要再次校验是否可以真正退出<br /><code>io.netty.channel.nio.NioEventLoop#run</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>来到<code>io.netty.util.concurrent.SingleThreadEventExecutor#confirmShutdown</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前线程状态不是ST_SHUTTING_DOWN、ST_SHUTDOWN、或ST_TERMINATED，则返回false，认为还未更新线程状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前线程不是事件循环原生线程，则抛出异常，必须在事件循环线程中调用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"must be invoked from an event loop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 取消所有计划任务</span>    <span class="token function">cancelScheduledTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 代码略</span><span class="token punctuation">}</span></code></pre><p><a name="tkB8r"></a></p><h4 id="2-执行正在TaskQueue中排队的task"><a href="#2-执行正在TaskQueue中排队的task" class="headerlink" title="2. 执行正在TaskQueue中排队的task"></a>2. 执行正在TaskQueue中排队的task</h4><p>来到<code>io.netty.util.concurrent.SingleThreadEventExecutor#runAllTasks()</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> fetchedAll<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        fetchedAll <span class="token operator">=</span> <span class="token function">fetchFromScheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runAllTasksFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fetchedAll<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// keep on processing until we fetched all scheduled tasks.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ranAtLeastOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastExecutionTime <span class="token operator">=</span> ScheduledFutureTask<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">afterRunningAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若至少有一个任务执行成功，返回true</span>    <span class="token keyword">return</span> ranAtLeastOne<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="SgDhE"></a></p><h4 id="3-执行注册到NioEventLoop中的ShutdownHook"><a href="#3-执行注册到NioEventLoop中的ShutdownHook" class="headerlink" title="3. 执行注册到NioEventLoop中的ShutdownHook"></a>3. 执行注册到NioEventLoop中的ShutdownHook</h4><p>来到<code>io.netty.util.concurrent.SingleThreadEventExecutor#runShutdownHooks</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">runShutdownHooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownHooks<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span>shutdownHooks<span class="token punctuation">)</span><span class="token punctuation">;</span>        shutdownHooks<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Runnable task<span class="token operator">:</span> copy<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Shutdown hook raised an exception."</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastExecutionTime <span class="token operator">=</span> ScheduledFutureTask<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ran<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="6I6Di"></a></p><h4 id="4-检查是否达到优雅退出的超时时间"><a href="#4-检查是否达到优雅退出的超时时间" class="headerlink" title="4. 检查是否达到优雅退出的超时时间"></a>4. 检查是否达到优雅退出的超时时间</h4><p><code>io.netty.util.concurrent.SingleThreadEventExecutor#confirmShutdown</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 若线程状态为ST_SHUTDOWN或ST_TERMINATED，并且达到超时时间，则确认已经退出</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> nanoTime <span class="token operator">-</span> gracefulShutdownStartTime <span class="token operator">></span> gracefulShutdownTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 还未达到指定超时时间，则每隔100ms检测是否有新任务加入，有则继续执行</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nanoTime <span class="token operator">-</span> lastExecutionTime <span class="token operator">&lt;=</span> gracefulShutdownQuietPeriod<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check if any tasks were added to the queue every 100ms.</span>    <span class="token comment" spellcheck="true">// TODO: Change the behavior of takeTask() so that it returns on timeout.</span>    taskQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>WAKEUP_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Ignore</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>挺赞的，正常的处理逻辑当退出前所有该做的操作都处理完了后，一般直接退出进程了。然而Netty还做了优化，在没达到超时时间时，继续等待新任务并执行，以确保“万无一失”。<br /></p><p><a name="Vedx2"></a></p><h4 id="5-Netty正式退出"><a href="#5-Netty正式退出" class="headerlink" title="5. Netty正式退出"></a>5. Netty正式退出</h4><p>当<code>confirmShutdown()</code>返回true后，意味着Netty优雅退出操作完成，正式退出，于是return退出了自旋的循环。NioEventLoop线程也结束，整个程序正式退出！</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="qUK9T"></a></p><h2 id="Netty优雅退出需要注意的几点"><a href="#Netty优雅退出需要注意的几点" class="headerlink" title="Netty优雅退出需要注意的几点"></a>Netty优雅退出需要注意的几点</h2><p><a name="qQZGk"></a></p><h3 id="1-待发送的消息"><a href="#1-待发送的消息" class="headerlink" title="1. 待发送的消息"></a>1. 待发送的消息</h3><p>调用优雅退出的方法<code>shutdownGracefully()</code>后，不会立即关闭链路（是在事件循环线程中执行的），<code>ChannelOutboundBuffer</code>中的消息可以继续发送。而本次发送操作执行完后，无论消息有没有发送出去，下一次Selector轮询中，链路都将被关闭，未发送完成的消息也会被释放和丢弃<br><a name="PTW9m"></a></p><h3 id="2-需要发送的新消息"><a href="#2-需要发送的新消息" class="headerlink" title="2. 需要发送的新消息"></a>2. 需要发送的新消息</h3><p>即便ShutdownHook 触发了优雅退出方法，在退出期间应用线程仍可以随时调用Channel的write系列接口发送消息，但是这些新消息将发送失败<br /><br><a name="xtS8I"></a></p><h3 id="3-需要执行的定时任务"><a href="#3-需要执行的定时任务" class="headerlink" title="3. 需要执行的定时任务"></a>3. 需要执行的定时任务</h3><p>诸如TaskQueue上的定时任务、普通的应用线程的定时任务、ShutdownHook，在退出时也无法保证被完全执行，完全取决于超时时间和任务数量、以及处理速度<br><a name="JmglW"></a></p><h3 id="4-使用方式"><a href="#4-使用方式" class="headerlink" title="4. 使用方式"></a>4. 使用方式</h3><p>通常用于应用进程退出时，在应用的ShutdownHook 中调用优雅退出的方法<code>shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit)</code>接口，指定超时时间，以防止因为一些任务的执行被阻塞而无法正常退出</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（九）EventLoop底层原理-3章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-jiu-eventloop-di-ceng-yuan-li-3-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-jiu-eventloop-di-ceng-yuan-li-3-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p>上一章节《Netty挖掘机（八）EventLoop底层原理-2章节》，主要分析了EventLoop的创建流程。其中有一块还没讲到，处理IO事件和队列任务。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>            cancelledKeys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            needsToSelectAgain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> ioRatio <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ioRatio<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ioRatio <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> ioStartTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token keyword">final</span> <span class="token keyword">long</span> ioTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ioStartTime<span class="token punctuation">;</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span>ioTime <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> ioRatio<span class="token punctuation">)</span> <span class="token operator">/</span> ioRatio<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />当轮询到就绪的Channel时，则要开始进行处理I/O事件和执行非I/O操作的队列任务和定时任务。<br /></p><p><a name="fc9348f8"></a></p><h2 id="处理I-O事件"><a href="#处理I-O事件" class="headerlink" title="处理I/O事件"></a>处理I/O事件</h2><blockquote><p>如果有io事件的话，则遍历获取，其中会校验是连接就绪，写就绪或者读就绪。对应方法为<code>processSelectedKeys(</code>)。</p></blockquote><p><br />《EventLoop底层原理-2章节》中提到，在初始化NioEventLoop时，会创建选择器Selector，当判定开启了键集优化时，会通过使用反射将jdk原生Selector的selectedKeys、publicSelectedKeys改为Netty内部定义的SelectedSelectionKeySet。<br /></p><p><a name="346a0075"></a></p><h3 id="1-获取就绪状态的Socket附件"><a href="#1-获取就绪状态的Socket附件" class="headerlink" title="1. 获取就绪状态的Socket附件"></a>1. 获取就绪状态的Socket附件</h3><p><br />回来看处理I/O事件的代码，需要注意当程序启动的时候，内部逻辑是不会触发的，因为未产生就绪事件。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedKeys <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">processSelectedKeysOptimized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">processSelectedKeysPlain</span><span class="token punctuation">(</span>selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />Netty默认开启了键集优化，故<code>selectedKeys</code>不为null，会进入到<code>processSelectedKeysOptimized()</code>。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKeysOptimized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> selectedKeys<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> SelectionKey k <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null out entry in the array to allow to have it GC'ed once the Channel close</span>        <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/2363</span>        selectedKeys<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">final</span> Object a <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">AbstractNioChannel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token punctuation">(</span>AbstractNioChannel<span class="token punctuation">)</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span> task <span class="token operator">=</span> <span class="token punctuation">(</span>NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>            <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needsToSelectAgain<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// null out entries in the array to allow to have it GC'ed once the Channel close</span>            <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/2363</span>            selectedKeys<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">selectAgain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />循环遍历<code>selectedKeys</code>，检索获取Socket附件，判断当前附件类型，<br /><br><br />若是<code>AbstractNioChannel</code>类型，则说明它是<code>NioServerSocketChannel</code> 或者<code>NioSocketChannel</code>（因为我们这里讲的都是TCP，所以排除<code>NioDatagramChannel</code>），此时需要执行I/O事件；<br /><br><br />否则认定它是<code>NioTask</code>类型，由于Netty并未有<code>NioTask</code>的相关实现类，所以这个逻辑片段一般不会执行。<br /></p><p><a name="1bd02ee0"></a></p><h3 id="2-执行I-O事件"><a href="#2-执行I-O事件" class="headerlink" title="2. 执行I/O事件"></a>2. 执行I/O事件</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>SelectionKey k<span class="token punctuation">,</span> AbstractNioChannel ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AbstractNioChannel<span class="token punctuation">.</span>NioUnsafe unsafe <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果键集不可用了，则return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> EventLoop eventLoop<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            eventLoop <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// If the channel implementation throws an exception because there is no event loop, we ignore this</span>            <span class="token comment" spellcheck="true">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span>            <span class="token comment" spellcheck="true">// to close ch.</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span>        <span class="token comment" spellcheck="true">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span>        <span class="token comment" spellcheck="true">// still healthy and should not be closed.</span>        <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/5125</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop <span class="token operator">!=</span> <span class="token keyword">this</span> <span class="token operator">||</span> eventLoop <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// close the channel if the key is not valid anymore</span>        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> readyOps <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span>        <span class="token comment" spellcheck="true">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span>            <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/924</span>            <span class="token keyword">int</span> ops <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ops <span class="token operator">&amp;=</span> <span class="token operator">~</span>SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">;</span>            k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>ops<span class="token punctuation">)</span><span class="token punctuation">;</span>            unsafe<span class="token punctuation">.</span><span class="token function">finishConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span>            ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forceFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span>        <span class="token comment" spellcheck="true">// to a spin loop</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>获取Channel的内部类<code>Unsafe</code>；</li><li>判断当前键集是否可用，不可用则调用Unsafe类的close()关闭Channel，释放连接资源，并且立即返回；</li><li>当前键集可用，开始获取网络操作设置位，即获取当前Selector感兴趣的事件<ul><li>连接就绪：TCP连接已经建立。按位与操作追加操作设置位到该键集，并且必须使用unsafe注销到该事件，防止因为selector选择器一直处于无阻塞状态而立即返回，不断循环，可能导致CPU核心利用率到100%，这个和epoll的bug如出一辙；<br><br />对于这个点不太明白其因果关系，猜测是因为如果不注销的话，selector感兴趣的事件会一直是连接就绪，不会触发新的事件，从而导致cpu逐升到100%；</li><li>写就绪：即有发送包未发送完成，此时需要调用forceFlush()进行冲刷发送，冲刷完后一旦没有剩余数据可写，亦会注销写事件；</li><li>读就绪或接收连接就绪：调用read()，接收客户端的TCP连接。并且这里加多了个readyOps为0的条件，是因为Netty为了防止JDK导致的空论询的bug，和连接就绪后注销事件的处理方式相似。</li></ul></li></ul><p><a name="aa2afdc2"></a></p><h2 id="执行非I-O操作的队列任务和周期任务"><a href="#执行非I-O操作的队列任务和周期任务" class="headerlink" title="执行非I/O操作的队列任务和周期任务"></a>执行非I/O操作的队列任务和周期任务</h2><blockquote><p>回顾上一章，我们讲过在初始化事件循环器（线程）时，都维护了一个无锁队列taskQueue，内部堆放了待执行的队列任务；由于实现了ScheduledExecutorService，故还有一个周期任务队列scheduledTaskQueue。<br>这时候就要开始来执行任务了。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> fetchedAll<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        fetchedAll <span class="token operator">=</span> <span class="token function">fetchFromScheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runAllTasksFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fetchedAll<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// keep on processing until we fetched all scheduled tasks.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ranAtLeastOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastExecutionTime <span class="token operator">=</span> ScheduledFutureTask<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">afterRunningAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ranAtLeastOne<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>断言判断是否当前线程是否在指定的事件循环器中执行，若false则抛出<code>AssertionError</code>异常；</p></li><li><p>从周期任务队列中取出任务添加到队列任务中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">fetchFromScheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若周期任务队列为空，则返回true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTaskQueue <span class="token operator">==</span> null <span class="token operator">||</span> scheduledTaskQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">long</span> nanoTime <span class="token operator">=</span> AbstractScheduledEventExecutor<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 从周期队列任务队列中取出任务并返回，并且remove，此举是为了接下来马上执行任务</span>      Runnable scheduledTask <span class="token operator">=</span> <span class="token function">pollScheduledTask</span><span class="token punctuation">(</span>nanoTime<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTask <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 如果任务队列没有空间存放新的任务，则重新添加给周期队列任务</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>taskQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>scheduledTask<span class="token punctuation">)</span><span class="token punctuation">)</span>           scheduledTaskQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> scheduledTask<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>从任务队列中取出任务并执行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">runAllTasksFrom</span><span class="token punctuation">(</span>Queue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Runnable task <span class="token operator">=</span> <span class="token function">pollTaskFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">safeExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>      task <span class="token operator">=</span> <span class="token function">pollTaskFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>从尾部队列中取出任务并执行，对应方法为afterRunningAllTasks()，为什么要执行这个目前还未研究<br><br />// TODO</p></li></ul><p><br />到这里，阿黑已经大致梳理了关于NioEventLoop相关的3个章节的相关源码剖析，接下来将解析ByteBuffer的实现机制。</p><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（八）EventLoop底层原理-2章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-ba-eventloop-di-ceng-yuan-li-2-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-ba-eventloop-di-ceng-yuan-li-2-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p>上一章节《Netty挖掘机（七）EventLoop底层原理-1章节》，主要分析了EventLoopGroup的创建流程，这一章继续讲后续操作，EventLoop的创建。<br /></p><p><a name="IwOIs"></a></p><h1 id="创建NioEventLoop时，发生了什么？"><a href="#创建NioEventLoop时，发生了什么？" class="headerlink" title="创建NioEventLoop时，发生了什么？"></a>创建NioEventLoop时，发生了什么？</h1><p><a name="RR3gQ"></a></p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p><a name="Rarq1"></a></p><h3 id="4-创建带有队列的事件循环器，并打开选择器"><a href="#4-创建带有队列的事件循环器，并打开选择器" class="headerlink" title="4. 创建带有队列的事件循环器，并打开选择器"></a>4. 创建带有队列的事件循环器，并打开选择器</h3><blockquote><p>Netty基于JDK原生NIO做了优化，以此提升了性能。具体优化内容看下面红色字体。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">NioEventLoop</span><span class="token punctuation">(</span>NioEventLoopGroup parent<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> SelectorProvider selectorProvider<span class="token punctuation">,</span>                 SelectStrategy strategy<span class="token punctuation">,</span> RejectedExecutionHandler rejectedExecutionHandler<span class="token punctuation">,</span>                 EventLoopTaskQueueFactory queueFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token function">newTaskQueue</span><span class="token punctuation">(</span>queueFactory<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">newTaskQueue</span><span class="token punctuation">(</span>queueFactory<span class="token punctuation">)</span><span class="token punctuation">,</span>          rejectedExecutionHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>selectorProvider <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"selectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strategy <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"selectStrategy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取selector提供者信息，一般以操作系统做区分，如Linux一般用epoll机制</span>    provider <span class="token operator">=</span> selectorProvider<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开选择器</span>    <span class="token keyword">final</span> SelectorTuple selectorTuple <span class="token operator">=</span> <span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    selector <span class="token operator">=</span> selectorTuple<span class="token punctuation">.</span>selector<span class="token punctuation">;</span>    unwrappedSelector <span class="token operator">=</span> selectorTuple<span class="token punctuation">.</span>unwrappedSelector<span class="token punctuation">;</span>    selectStrategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="oeoQI"></a></p><h4 id="创建周期任务"><a href="#创建周期任务" class="headerlink" title="创建周期任务"></a>创建周期任务</h4><p><br />回顾上一章的类图，我们可以知道NioEventLoop向上有一个接口是<code>ScheduledExecutorService</code>，即实现了定时任务的相关接口。<br /><br><br />在io.netty.util.concurrent.AbstractScheduledEventExecutor内，已经实现了schedule()，并且在其中创建了周期任务队列并按指定周期执行。<br /></p><pre class=" language-java"><code class="language-java">PriorityQueue<span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> scheduledTaskQueue<span class="token punctuation">;</span>PriorityQueue<span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token function">scheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTaskQueue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        scheduledTaskQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultPriorityQueue</span><span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span>            SCHEDULED_FUTURE_TASK_COMPARATOR<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// Use same initial capacity as java.util.PriorityQueue</span>            <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> scheduledTaskQueue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="mbwjR"></a></p><h4 id="构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue-可看到"><a href="#构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue-可看到" class="headerlink" title="构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue()可看到"></a>构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue()可看到</h4><p><br />知识点来了，这里用到了JCTools的并发队列，对于JCTools的知识，后续开一篇文章讲解<br /><br><br />MPSC：用于多生产单消费者模式，且支持在多生产时是无锁操作以保证线程安全，同一时刻只支持单一消费者消费。<br /><br><br />为什么不用<code>LinkedBlockingQueue</code> 来做队列呢？<br /><br><br />无锁就是答案了，性能方面比jdk原生队列好太多了，而且Netty本身就是会存在多个生产者同时生产任务，而仅有EventLoop去处理队列中的任务，恰恰MPSC符合该场景。<br /></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// NioEventLoop.java</span><span class="token keyword">private</span> <span class="token keyword">static</span> Queue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">newTaskQueue0</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxPendingTasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This event loop never calls takeTask()</span>    <span class="token comment" spellcheck="true">// 默认采用无参构造方法</span>    <span class="token keyword">return</span> maxPendingTasks <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> PlatformDependent<span class="token punctuation">.</span>&lt;Runnable<span class="token operator">></span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">:</span> PlatformDependent<span class="token punctuation">.</span>&lt;Runnable<span class="token operator">></span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span>maxPendingTasks<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// PlatformDependent.java</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Queue<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Mpsc<span class="token punctuation">.</span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Mpsc.java</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Queue<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">MpscUnboundedArrayQueue</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>MPSC_CHUNK_SIZE<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">MpscUnboundedAtomicArrayQueue</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>MPSC_CHUNK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="Fye5b"></a></p><h4 id="打开选择器"><a href="#打开选择器" class="headerlink" title="打开选择器"></a>打开选择器</h4><p>具体流程是：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094744230-420a4bd0-2186-4eb0-a3ae-9ac9cf558386.jpeg#align=left&display=inline&height=509&margin=%5Bobject%20Object%5D&name=open_selector.jpg&originHeight=509&originWidth=1085&size=51709&status=done&style=none&width=1085" alt="open_selector.jpg"><br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> SelectorTuple <span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Selector unwrappedSelector<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 根据系统底层io模型创建一个selector（Windows系统的话这里是WindowsSelectorImpl）</span>        unwrappedSelector <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ChannelException</span><span class="token punctuation">(</span><span class="token string">"failed to open a new selector"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 禁用键集优化，通过io.netty.noKeySetOptimization配置，默认false，即开启优化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DISABLE_KEY_SET_OPTIMIZATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SelectorTuple 类似一个持有selector引用的句柄</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用JAVA 安全模型中的特权手段，执行对应的“特权”，这里应该是指尝试获取特权读取java核心库下的class对象</span>    <span class="token comment" spellcheck="true">// 获取SelectorImpl 类对象</span>    Object maybeSelectorImplClass <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>                    <span class="token string">"sun.nio.ch.SelectorImpl"</span><span class="token punctuation">,</span>                    <span class="token boolean">false</span><span class="token punctuation">,</span>                    PlatformDependent<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> cause<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若不是一个class对象 或 不是unwrappedSelector的子类，则直接return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>maybeSelectorImplClass <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token comment" spellcheck="true">// ......</span>        <span class="token comment" spellcheck="true">// 直接返回未经优化selector的SelectorTuple</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> selectorImplClass <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> maybeSelectorImplClass<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化SelectedSelectionKeySet，内部定义了一个SelectionKey数组，长度为1024</span>    <span class="token keyword">final</span> SelectedSelectionKeySet selectedKeySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelectedSelectionKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用“特权”，获取类变量，</span>    Object maybeException <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Field selectedKeysField <span class="token operator">=</span> selectorImplClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"selectedKeys"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Field publicSelectedKeysField <span class="token operator">=</span> selectorImplClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"publicSelectedKeys"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>PlatformDependent<span class="token punctuation">.</span><span class="token function">javaVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">9</span> <span class="token operator">&amp;&amp;</span> PlatformDependent<span class="token punctuation">.</span><span class="token function">hasUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// jdk9 及以上版本，直接使用Unsafe类底层实现替换</span>                <span class="token punctuation">}</span>                Throwable cause <span class="token operator">=</span> ReflectionUtil<span class="token punctuation">.</span><span class="token function">trySetAccessible</span><span class="token punctuation">(</span>selectedKeysField<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> cause<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                cause <span class="token operator">=</span> ReflectionUtil<span class="token punctuation">.</span><span class="token function">trySetAccessible</span><span class="token punctuation">(</span>publicSelectedKeysField<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> cause<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 使用反射将jdk原生Selector的selectedKeys、publicSelectedKeys改为Netty内部定义的SelectedSelectionKeySet</span>                selectedKeysField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">;</span>                publicSelectedKeysField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maybeException <span class="token keyword">instanceof</span> <span class="token class-name">Exception</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ......</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    selectedKeys <span class="token operator">=</span> selectedKeySet<span class="token punctuation">;</span>    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"instrumented a special java.util.Set into: {}"</span><span class="token punctuation">,</span> unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span>                             <span class="token keyword">new</span> <span class="token class-name">SelectedSelectionKeySetSelector</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="U3Rxc"></a></p><h3 id="5-执行NioEventLoop的run"><a href="#5-执行NioEventLoop的run" class="headerlink" title="5. 执行NioEventLoop的run()"></a>5. 执行NioEventLoop的run()</h3><blockquote><p><strong>这是整一块体中最核心的方法！</strong><br>尝试启动有且仅有一个Eventloop线程（如果当前线程非Eventloop线程的话），并在程序运行期间死循环执行NioEventLoop的run()，检测当前队列中是否有任务要执行。</p></blockquote><p><br />执行run()的入口是SingleThreadEventExecutor的execute()，哪里触发execute()的执行？<br /><br><br />在Bootstrap绑定端口时，会初始化注册channel到EventLoop内，并且开始执行EventLoop的execute()；在连接进来时，数据写到Channel，触发执行EventLoop的execute()；在处理好连接并返回时，注销，触发执行EventLoop的execute()。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094818411-c7caeebf-a495-49ea-9048-57ffa957c023.jpeg#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&name=debug.jpg&originHeight=303&originWidth=392&size=21490&status=done&style=none&width=392" alt="debug.jpg">)<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094819754-98c9a687-5732-45c2-8a64-553a26ae11ba.jpeg#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=debug2.jpg&originHeight=301&originWidth=389&size=20406&status=done&style=none&width=389" alt="debug2.jpg">)<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094821128-a97dc731-8bf1-42cc-a8b4-7bae0083ed5b.jpeg#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=debug3.jpg&originHeight=298&originWidth=393&size=21082&status=done&style=none&width=393" alt="debug3.jpg"><br /><br><br />下面先看下run()涉及的一个流程图，理清下思路<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094829054-52adb1c8-ba13-41a9-b287-166afdfbab77.jpeg#align=left&display=inline&height=494&margin=%5Bobject%20Object%5D&name=eventloop_run.jpg&originHeight=494&originWidth=909&size=46758&status=done&style=none&width=909" alt="eventloop_run.jpg"><br /></p><p><a name="rNeFe"></a></p><h4 id="执行器开始执行"><a href="#执行器开始执行" class="headerlink" title="执行器开始执行"></a>执行器开始执行</h4><p><br />翻阅代码后，最终的execute()执行在<code>io.netty.util.concurrent.SingleThreadEventExecutor</code>内。<br /><br><br />过程主要是添加任务到队列，启动线程，轮询，执行任务<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断当前线程是否事件循环线程</span>    <span class="token keyword">boolean</span> inEventLoop <span class="token operator">=</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加任务到MPSC任务队列中</span>    <span class="token function">addTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若非事件循环线程，则执行开启事件循环线程逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inEventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 通过Unsafe，将当前标识的线程状态从未启动变为已启动，并new线程，在线程内执行NioEventLoop的run()</span>        <span class="token function">startThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// inEventLoop为false，并且线程状态为shuttingdown，则唤醒以解除线程阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>addTaskWakesUp <span class="token operator">&amp;&amp;</span> <span class="token function">wakesUpForTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>inEventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="h72m7"></a></p><h4 id="事件循环器轮询队列任务"><a href="#事件循环器轮询队列任务" class="headerlink" title="事件循环器轮询队列任务"></a>事件循环器轮询队列任务</h4><p><br />NioEventLoop本质上就是一个单线程去执行特定的任务，所以它的run()，我们需要留意。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 死循环，直到线程shutdown</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>selectStrategy<span class="token punctuation">.</span><span class="token function">calculateStrategy</span><span class="token punctuation">(</span>selectNowSupplier<span class="token punctuation">,</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>CONTINUE<span class="token operator">:</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 不属于NIO的范畴，它不支持繁忙等待</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>BUSY_WAIT<span class="token operator">:</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>SELECT<span class="token operator">:</span>                        <span class="token function">select</span><span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            selector<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 若出现IOException，则重新建立选择器</span>                <span class="token function">rebuildSelector0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">handleLoopException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cancelledKeys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            needsToSelectAgain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> ioRatio <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ioRatio<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ioRatio <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> ioStartTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token keyword">final</span> <span class="token keyword">long</span> ioTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ioStartTime<span class="token punctuation">;</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span>ioTime <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> ioRatio<span class="token punctuation">)</span> <span class="token operator">/</span> ioRatio<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取消通道在Selector上的注册，关闭通道，并让NioEventLoop线程退出循环，结束运行...</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />文字流程如下：<br /></p><ul><li>Selector轮询检测。检测到队列中有任务，则当即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，若有通道准备（进行I/O操作）就绪则返回数&gt;0；检测到队列中没有任务，则直接返回-1，并调用select(wakenUp.getAndSet(false))；</li><li>获取ioRatio，即io比率。默认50，通过io比率可以控制执行任务的时长；</li><li>处理io事件。对应方法为processSelectedKeys()。如果有io事件的话，则遍历获取，其中会校验是连接就绪，写就绪或者读就绪；</li><li>运行队列任务。对应方法为runAllTasks()。如果io比率=100，则不限制任务的执行时长，确保执行完所有任务；否则通过io比率折算出时长，执行任务超过该时长则退出！</li></ul><p><a name="GnIF5"></a></p><h4 id="任务队列上未有任务，执行Netty的select"><a href="#任务队列上未有任务，执行Netty的select" class="headerlink" title="任务队列上未有任务，执行Netty的select"></a>任务队列上未有任务，执行Netty的select</h4><p><br />当检测到任务队列上未有任务时，会执行select(wakenUp.getAndSet(false));<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> oldWakenUp<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Selector selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> selectCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> currentTimeNanos <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> selectDeadLineNanos <span class="token operator">=</span> currentTimeNanos <span class="token operator">+</span> <span class="token function">delayNanos</span><span class="token punctuation">(</span>currentTimeNanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> timeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span>selectDeadLineNanos <span class="token operator">-</span> currentTimeNanos <span class="token operator">+</span> 500000L<span class="token punctuation">)</span> <span class="token operator">/</span> 1000000L<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeoutMillis <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果先将wakeUp设置为true再有任务提交，此时必须会导致任务挂起，直到select操作超时（或者管道中存在IdleStateHandler，则要等到空闲超时）；所以在执行Selector.select操作之前，需再次检查任务队列！</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> wakenUp<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            selectCnt <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedKeys <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> oldWakenUp <span class="token operator">||</span> wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasScheduledTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely because "</span> <span class="token operator">+</span>                                 <span class="token string">"Thread.currentThread().interrupt() was called. Use "</span> <span class="token operator">+</span>                                 <span class="token string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// epoll 空论询的检测逻辑代码</span>            <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">-</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span> <span class="token operator">>=</span> currentTimeNanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// timeoutMillis elapsed without anything selected.</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                       selectCnt <span class="token operator">>=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector <span class="token operator">=</span> <span class="token function">selectRebuildSelector</span><span class="token punctuation">(</span>selectCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            currentTimeNanos <span class="token operator">=</span> time<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">></span> MIN_PREMATURE_SELECTOR_RETURNS<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely {} times in a row for Selector {}."</span><span class="token punctuation">,</span>                             selectCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>CancelledKeyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" raised by a Selector {} - JDK bug?"</span><span class="token punctuation">,</span>                         selector<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />文字流程如下<br /></p><ol><li>获得当前时间，加上即将执行定时任务的剩余时间，得到Selector执行的“预计”剩余时间selectDeadLineNanos；</li><li>selectDeadLineNanos减当前时间，加上0.5ms的缓冲值，再除以1ms得到的Selector.select的阻塞超时时间timeoutMillis</li><li>当timeoutMillis  &lt;= 0，说明定时任务准备执行了！（如果是第一次进方法，此时立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量），接着退出方法体；</li><li>若当前队列有任务，并且wakeUp通过cas设置为true，此时立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，接着退出方法体；（为什么要做这一步，代码注释已声明）</li><li>执行Select.select(timeoutMillis)，会一直阻塞直到超时，这里调用的是JDK原生的select；</li><li>执行select后，如果Selector被唤醒，或者队列有任务，或者定时任务开始执行，则退出方法体  ；</li><li>由于程序处理中可能出现错误，而导致线程被中断，此时Netty帮我们做了处理，记录日志，并退出方法体 ；</li><li>重点来了，当select实际的阻塞时间&lt;timeoutMillis，并且计数器selectCnt&gt;=SELECTOR_AUTO_REBUILD_THRESHOLD，即循环超过了重试次数阈值（默认512），则Netty认为JDK触发了epoll空论询的bug，于是重建选择器，并立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，接着退出方法体；</li><li>退出方法体后，继续执行后续的处理I/O事件和执行队列任务；</li></ol><p><a name="D8jrw"></a></p><h4 id="处理IO事件和队列任务"><a href="#处理IO事件和队列任务" class="headerlink" title="处理IO事件和队列任务"></a>处理IO事件和队列任务</h4><p><br />这一块，等下一篇章继续讲解！<br /></p><p><a name="p9SwR"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a name="7SleK"></a></p><h2 id="Netty中是如何结合事件模型使用NIO同步非阻塞的特性"><a href="#Netty中是如何结合事件模型使用NIO同步非阻塞的特性" class="headerlink" title="Netty中是如何结合事件模型使用NIO同步非阻塞的特性"></a>Netty中是如何结合事件模型使用NIO同步非阻塞的特性</h2><ul><li>回顾BIO模型，由于单线程无法更好地利用CPU，socket的读写函数无法立即返回于是有了多线程，即一个请求对应一个处理线程，但还是同步阻塞的IO，发起请求同步，实际的IO操作阻塞，且线程的利用率非常地高，在海量请求下不切实际；</li><li>回到NIO，得益于Buffer、Channel、Selector三个组件，socket的读写函数可以立即返回。发起请求仍是同步，实际的I/O操作是非阻塞，它把数据交给Channel，进而有一个特定的线程去执行I/O操作。实现了“不用多开线程利用CPU”。<br><br />如何使用事件模型单线程处理所有I/O请求？<br><br />在NIO中主要有三个事件：连接就绪、读就绪、写就绪。首先需要注册这几个事件就绪时对应的处理器，接着用一个单线程死循环执行Selector.select 阻塞式地检测Channel的事件状态，等待并获取就绪事件的到来，当就绪事件到来时，告诉事件处理器。</li><li>来到Netty，在NIO的基础上，增加了Eventloop事件循环器，对原生Selector做了增强，不仅仅是一个死循环这么简单，在线程中断等用户行为错误、epoll空论询bug、适时唤醒Selector上下了很多功夫。还增加了JCTools 的无界队列MPSCQueue来存放待执行任务。</li></ul><p><a name="dBSB9"></a></p><h2 id="Netty解决了JDK的哪些bug"><a href="#Netty解决了JDK的哪些bug" class="headerlink" title="Netty解决了JDK的哪些bug"></a>Netty解决了JDK的哪些bug</h2><blockquote><p>在EventLoop的创建和执行过程中，Netty主要解决了哪些JDK的bug？</p></blockquote><ul><li>Netty优化JDK原生的Selector<br><br />通过Unsafe类或反射，去改动SelectorImpl中的变量值，如下，将数据结构从HashSet改为了数组，解决了遍历效率、HashSet因为扩容而带来的性能问题。</li></ul><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectedKeys<span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> publicSelectedKeys</code></pre><ul><li>Netty解决了JDK NIO 中 臭名昭著的epoll空轮询的bug<br><br />回顾之前《Netty挖掘机（一）初识Java Nio》，里面写到了如何用JAVA NIO 来写服务端应用</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 阻塞，获取已就绪的key个数</span>        <span class="token keyword">int</span> wait <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wait <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取所有的事件key</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> readykeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> readykeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移除已处理数据</span>            iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 处理逻辑</span>            <span class="token function">process</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>在原生JDK NIO中，Selector.select()默认会一直阻塞直到有就绪事件进来。然而却可能出现没有任何就绪事件就直接返回，导致select外层的循环不断执行，最终导致服务器的CPU核心利用率飙涨到100%，即epoll空论询的bug，这是Linux系统下所导致的，不知最新版本是否处理了这个问题？<br><br />而在Netty中，实现了自定义的一个select方法，同样它会调用原生的Selector.select()，但是它做了向上增强的检测机制：<ul><li>检查实际超时时间是否小于预设超时时间；</li><li>检查循环次数是否超过设定重试次数阈值；</li><li>重建选择器</li></ul></li></ul><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（七）EventLoop底层原理-1章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-qi-eventloop-di-ceng-yuan-li-1-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-qi-eventloop-di-ceng-yuan-li-1-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p><a name="93tFv"></a></p><h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><blockquote><p>顾名思义，事件循环。在前面的文章已经讲到，NIO内部使用了Reactor模型，而Reactor模型的核心就是事件驱动。事件驱动中就有这么一个事件循环器在工作。<br>接下来我们开始从源码入手，了解Netty的EventLoop的机制。</p></blockquote><p><a name="M68ke"></a></p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><br />首先，我们先看下相关类图，主要有两个关键类：<code>NioEventLoop</code>和<code>NioEventLoopGroup</code>。类图可以看到<br /></p><ul><li>最顶层接口是Executor，即线程执行器，提供了execute()在将来执行某个task；</li><li>ExecutorService，即真正的线程池接口，继承了Executor，封装了更多的方法，如submit()提交任务后可回传结果；</li><li><code>NioEventLoop</code>继承了抽象基类<code>SingleThreadEventLoop</code>，在单线程中执行所有已提交的任务；</li><li><code>NioEventLoopGroup</code>继承了抽象基类<code>MultithreadEventLoopGroup</code>，可同时处理多个线程的任务</li></ul><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094002448-df99c196-2c67-49f9-b6dd-63b9b634acd9.jpeg#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=class_diagram.jpg&originHeight=699&originWidth=926&size=26782&status=done&style=none&width=926" alt="class_diagram.jpg"><br /></p><p><a name="9SLRH"></a></p><h1 id="创建NioEventLoopGroup时，发生了什么？"><a href="#创建NioEventLoopGroup时，发生了什么？" class="headerlink" title="创建NioEventLoopGroup时，发生了什么？"></a>创建NioEventLoopGroup时，发生了什么？</h1><p><a name="tKIyL"></a></p><h2 id="首先先看下简化后的流程图"><a href="#首先先看下简化后的流程图" class="headerlink" title="首先先看下简化后的流程图"></a>首先先看下简化后的流程图</h2><blockquote><p>初始化NioEventLoopGroup时，通过指定线程数，创建N个NioEventLoop执行器。</p></blockquote><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094012869-c44b018c-b60f-4769-9bb0-c9e3b78e4375.jpeg#align=left&display=inline&height=616&margin=%5Bobject%20Object%5D&name=process.jpg&originHeight=616&originWidth=980&size=48925&status=done&style=none&width=980" alt="process.jpg"><br /></p><p><a name="77fGY"></a></p><h2 id="回到代码开发中"><a href="#回到代码开发中" class="headerlink" title="回到代码开发中"></a>回到代码开发中</h2><blockquote><p>我们在服务端的开发中，通常会引入两个独立的事件循环组，相当于两个Reactor线程池，一个boss用于accept连接，一个worker用于handle IO操作。只是两行代码，里面就做了足够多的逻辑。这两个组怎么创建得来呢？让我们从源码入手瞧一瞧。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="NXeqN"></a></p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p><a name="2wnx7"></a></p><h3 id="1-调用NioEventLoopGroup的构造方法"><a href="#1-调用NioEventLoopGroup的构造方法" class="headerlink" title="1. 调用NioEventLoopGroup的构造方法"></a>1. 调用<code>NioEventLoopGroup</code>的构造方法</h3><blockquote><p>在这里会先获取操作系统对应的实现NIO的方式。Linux2.6内核引入了epoll，替代了select和poll机制</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这里的nThreads默认为0</span><span class="token keyword">public</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> SelectorProvider<span class="token punctuation">.</span><span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />这里看到SelectorProvider类<br /></p><blockquote><p><code>SelectorProvider</code>类通过open*等方法，创建Selector、SocketChannel、ServerSocketChannel等。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>provider <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> provider<span class="token punctuation">;</span>        <span class="token keyword">return</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>SelectorProvider<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> SelectorProvider <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ......</span>                    provider <span class="token operator">=</span> sun<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ch<span class="token punctuation">.</span>DefaultSelectorProvider<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> provider<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />对应不同的操作系统，<code>DefaultSelectorProvider</code>类有不同的Selector实现机制（SPI机制的体现）。<br /><br><br />Windows系统采用 IOCP机制（java8）<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSelectorProvider</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">DefaultSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />Linux系统采用了Epoll机制（java8）<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSelectorProvider</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">createProvider</span><span class="token punctuation">(</span>String paramString<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//......</span>      <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GetPropertyAction</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"SunOS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token function">createProvider</span><span class="token punctuation">(</span><span class="token string">"sun.nio.ch.DevPollSelectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Linux"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token function">createProvider</span><span class="token punctuation">(</span><span class="token string">"sun.nio.ch.EPollSelectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PollSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="1V7Ws"></a></p><h3 id="2-调用父类MultithreadEventLoopGroup的构造方法"><a href="#2-调用父类MultithreadEventLoopGroup的构造方法" class="headerlink" title="2. 调用父类MultithreadEventLoopGroup的构造方法"></a>2. 调用父类<code>MultithreadEventLoopGroup</code>的构造方法</h3><blockquote><p>在这里主要是初始化EventLoop的线程数量。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> SelectorProvider selectorProvider<span class="token punctuation">,</span> SelectStrategyFactory selectStrategyFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> selectorProvider<span class="token punctuation">,</span> selectStrategyFactory<span class="token punctuation">,</span>RejectedExecutionHandlers<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="l31ax"></a></p><h4 id="查看父类"><a href="#查看父类" class="headerlink" title="查看父类"></a>查看父类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultithreadEventLoopGroup</span> <span class="token keyword">extends</span> <span class="token class-name">MultithreadEventExecutorGroup</span> <span class="token keyword">implements</span> <span class="token class-name">EventLoopGroup</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> InternalLogger logger <span class="token operator">=</span> InternalLoggerFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>MultithreadEventLoopGroup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> NettyRuntime<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果线程数为0，则设定为一个由final定义的不可变常量</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当传入的线程数为0时，系统会主动分配一个默认线程数量<code>DEFAULT_EVENT_LOOP_THREADS</code>，若程序设置了系统属性<code>io.netty.eventLoopThreads</code>则用该值；若设置了系统属性<code>io.netty.availableProcessors</code>则用该值 _ 2；否则返回可用于Java虚拟机的处理器数量 _ 2；源码合并如下<br /></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 存在属性值io.netty.eventLoopThreads 则取，否则走下一步</span>SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> NettyRuntime<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NettyRuntime</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AvailableProcessorsHolder holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AvailableProcessorsHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AvailableProcessorsHolder</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@SuppressForbidden</span><span class="token punctuation">(</span>reason <span class="token operator">=</span> <span class="token string">"to obtain default number of available processors"</span><span class="token punctuation">)</span>        <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>availableProcessors <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用final保证结果不可变，存在属性值io.netty.availableProcessor则取，否则获取当前虚拟机的处理器数量</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> availableProcessors <span class="token operator">=</span>                        SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>                                <span class="token string">"io.netty.availableProcessors"</span><span class="token punctuation">,</span>                                Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setAvailableProcessors</span><span class="token punctuation">(</span>availableProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>availableProcessors<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> holder<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="S0wTi"></a></p><h3 id="3-调用父类MultithreadEventExecutorGroup的构造方法"><a href="#3-调用父类MultithreadEventExecutorGroup的构造方法" class="headerlink" title="3. 调用父类MultithreadEventExecutorGroup的构造方法"></a>3. 调用父类<code>MultithreadEventExecutorGroup</code>的构造方法</h3><blockquote><p>在这里主要是遍历获取事件循环器对象。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">MultithreadEventExecutorGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// DefaultEventExecutorChooserFactory.INSTANCE：默认事件执行器选择器工厂</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> DefaultEventExecutorChooserFactory<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token function">MultithreadEventExecutorGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span>                                            EventExecutorChooserFactory chooserFactory<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// A. 创建每个任务执行程序的线程</span>        executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token function">newDefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新建事件执行器数组，指定长度；开始遍历拿到执行器对象</span>    children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventExecutor</span><span class="token punctuation">[</span>nThreads<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nThreads<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// B. 调用派生类NioEventLoopGroup的newChild()，得到一个事件循环器对象</span>            children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newChild</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO: Think about if this is a good exception type</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"failed to create a child event loop"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// C. 新建选择器</span>    chooser <span class="token operator">=</span> chooserFactory<span class="token punctuation">.</span><span class="token function">newChooser</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// D. 创建监听器，并遍历添加到事件执行器中</span>    <span class="token keyword">final</span> FutureListener<span class="token operator">&lt;</span>Object<span class="token operator">></span> terminationListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureListener</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>EventExecutor e<span class="token operator">:</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>terminationListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 去重，并返回只读集合</span>    Set<span class="token operator">&lt;</span>EventExecutor<span class="token operator">></span> childrenSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>EventExecutor<span class="token operator">></span><span class="token punctuation">(</span>children<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    Collections<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>childrenSet<span class="token punctuation">,</span> children<span class="token punctuation">)</span><span class="token punctuation">;</span>    readonlyChildren <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableSet</span><span class="token punctuation">(</span>childrenSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="mlZKe"></a></p><h4 id="A-创建每个任务执行程序的线程"><a href="#A-创建每个任务执行程序的线程" class="headerlink" title="A. 创建每个任务执行程序的线程"></a>A. 创建每个任务执行程序的线程</h4><ul><li>获取默认的线程工厂实例</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> ThreadFactory <span class="token function">newDefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>线程工厂的构造逻辑</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// priority: 线程优先级，默认Thread.NORM_PRIORITY = 5</span><span class="token comment" spellcheck="true">// daemon: 是否守护线程，这里为false</span><span class="token comment" spellcheck="true">// threadGroup: 线程组</span><span class="token comment" spellcheck="true">// poolName: 线程池名称</span><span class="token keyword">public</span> <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span>String poolName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> daemon<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">,</span> ThreadGroup threadGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//......</span>    prefix <span class="token operator">=</span> poolName <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> poolId<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>daemon <span class="token operator">=</span> daemon<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">=</span> priority<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadGroup <span class="token operator">=</span> threadGroup<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> <span class="token function">newThread</span><span class="token punctuation">(</span>FastThreadLocalRunnable<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> prefix <span class="token operator">+</span> nextId<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> daemon<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>daemon<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Doesn't matter even if failed to set.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>构造<code>ThreadPerTaskExecutor</code>，传入线程工厂，得到Executor线程执行器对象</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPerTaskExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ThreadFactory threadFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPerTaskExecutor</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 传入线程工厂</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadFactory <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"threadFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 调用线程工厂的newThread()新建一个线程，并启动</span>        threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">.</span>sta<span class="token operator">=</span><span class="token function">rt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="iWl9n"></a></p><h4 id="B-调用派生类NioEventLoopGroup的newChild"><a href="#B-调用派生类NioEventLoopGroup的newChild" class="headerlink" title="B. 调用派生类NioEventLoopGroup的newChild()"></a>B. 调用派生类NioEventLoopGroup的newChild()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioEventLoopGroup</span> <span class="token keyword">extends</span> <span class="token class-name">MultithreadEventLoopGroup</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> EventLoop <span class="token function">newChild</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        EventLoopTaskQueueFactory queueFactory <span class="token operator">=</span> args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token punctuation">(</span>EventLoopTaskQueueFactory<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoop</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token punctuation">(</span>SelectorProvider<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>SelectStrategyFactory<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newSelectStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>RejectedExecutionHandler<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />重点来了，这里新建了NioEventLoop事件循环器对象，相当于一个线程，也就是事件驱动思想。<br /></p><p><a name="Ec3w6"></a></p><h4 id="C-新建选择器"><a href="#C-新建选择器" class="headerlink" title="C. 新建选择器"></a>C. 新建选择器</h4><blockquote><p>选择器是用于从事件循环组中选取一个事件循环器，将连接注册到事件循环器中</p></blockquote><p><br />这里用了策略模式，若执行器数量是2的指数倍，则返回PowerOfTwoEventExecutorChooser，否则返回同样的实例 GenericEventExecutorChooser.<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> EventExecutorChooser <span class="token function">newChooser</span><span class="token punctuation">(</span>EventExecutor<span class="token punctuation">[</span><span class="token punctuation">]</span> executors<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>executors<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PowerOfTwoEventExecutorChooser</span><span class="token punctuation">(</span>executors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GenericEventExecutorChooser</span><span class="token punctuation">(</span>executors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析Eventloop！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（六）什么是Reactor_IO_Style</title>
      <link href="/2020/06/02/netty-wa-jue-ji-liu-shi-me-shi-reactor-io-style/"/>
      <url>/2020/06/02/netty-wa-jue-ji-liu-shi-me-shi-reactor-io-style/</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章讲解的内容都是偏向表面，比如介绍了JAVA NIO，Netty的实现流程，实现一套基于Spring+Netty的API服务模块等。 接下来开始深入挖掘，汲取Netty底层的设计思想和引用的优秀的框架、原理等。</p><blockquote><p>总之，拭目以待吧！</p></blockquote><p><a name="70f1fd3b"></a></p><h2 id="Reactor模型（反应堆模型）"><a href="#Reactor模型（反应堆模型）" class="headerlink" title="Reactor模型（反应堆模型）"></a>Reactor模型（反应堆模型）</h2><blockquote><p>谈到Netty，Nio，就绕不开一个IO模型：Reactor Pattern。维基百科介绍“ The reactor <a href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" target="_blank" rel="noopener">design pattern</a> is an <a href="https://en.wikipedia.org/wiki/Event_handling" target="_blank" rel="noopener">event handling</a> pattern for handling service requests delivered <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" target="_blank" rel="noopener">concurrently</a> to a service handler by one or more inputs.  The service handler then <a href="https://en.wikipedia.org/wiki/Demultiplex" target="_blank" rel="noopener">demultiplexes</a> the incoming requests and dispatches them synchronously to the associated request handlers ”。</p></blockquote><p><br />即，Reactor模型的特性是：</p><ul><li>可处理同时多个请求</li><li>service handler可将传入的请求进行多路拆分，同步分发到对应的处理逻辑</li><li>事件驱动架构</li></ul><p><a name="ec6db9ae"></a></p><h3 id="什么是事件驱动？"><a href="#什么是事件驱动？" class="headerlink" title="什么是事件驱动？"></a>什么是事件驱动？</h3><blockquote><p>事件驱动（ Event-driven architecture，也叫EDA）是一种编程范式，用于生成高度可扩展的应用程序。</p></blockquote><p><br />事件驱动下的系统，程序的执行由外部事件决定。基本的架构思想是设计一个事件循环（Event Loop）所形成的程序，这个事件循环程序不断检测当前需要处理的消息，根据消息触发一个对应的动作/函数进行处理。这个消息可能来源于人为动作、程序动作、时间动作。<br /></p><p><a name="8640d52e"></a></p><h3 id="什么是I-O多路复用？"><a href="#什么是I-O多路复用？" class="headerlink" title="什么是I/O多路复用？"></a>什么是I/O多路复用？</h3><blockquote><p>操作系统内核提供一个功能，通过select、poll、epoll、kqueue之类的系统函数，监视进程指定的一个或多个IO处于就绪 or 读 or 写事件时，通知该进程。此举可减少系统创建线程的开销。</p></blockquote><ul><li>只有当系统通知进程哪个句柄可读，才去执行read操作；哪个句柄可写，才去执行write操作，在提升效率的同时，减少了无用功；</li><li>多个句柄在同一个线程内并发交替地按序完成；</li><li>多路复用遵循多对一的方式，即n条输入线和1条输出线；</li><li>执行多路复用的设备称为多路复用器（MUX），执行反向处理的设备称为解复用器</li></ul><p><a name="3fd5cb6b"></a></p><h3 id="它的思路是"><a href="#它的思路是" class="headerlink" title="它的思路是"></a>它的思路是</h3><ol><li>在基于Reactor模型的应用中，引入了一个单独的请求处理程序来处理这种类型的请求；</li><li>传入的请求被注册并排队等待处理，解复用or分配的任务通常在事件循环（Event Loop）中完成；</li><li>而事件循环在单线程中运行，检测事件发生的时机，这里表明无需阻塞调用，可以直接使用基础资源；</li><li>例如这些事件是在网络连接可用或文件准备从磁盘或网络读取等情况下，事件循环会将事件分派到关联的请求处理程序（Workers）；</li><li>该请求的整个操作以异步非阻塞方式执行；</li><li>从Client发起请求开始，即产生了事件，此时并没有用队列作为缓冲，而是直接通过service handler根据不同的事件类型进行分发。</li></ol><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093908390-a0dee3d2-d6fe-4b75-8a6f-8eb20219ca26.jpeg#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=model.jpg&originHeight=440&originWidth=841&size=81581&status=done&style=none&width=841" alt="model.jpg"><br /></p><p><a name="b6239956"></a></p><h3 id="它的架构是"><a href="#它的架构是" class="headerlink" title="它的架构是"></a>它的架构是</h3><blockquote><p>tips：参考文章最底的学术文章链接</p></blockquote><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093918897-7d822953-c442-4faf-aaa2-fc7316fa649f.jpeg#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=class_diagram.jpg&originHeight=436&originWidth=664&size=87008&status=done&style=none&width=664" alt="class_diagram.jpg"><br /></p><p><a name="ba88bcc6"></a></p><h4 id="参与者："><a href="#参与者：" class="headerlink" title="参与者："></a>参与者：</h4><ul><li><p>Handle<br><br />即句柄（也可以叫描述符），标识由操作系统管理的资源。这种资源可以是一个网络连接（网络句柄），打开文件（文件句柄）等。在网络编程中，一般是socket句柄，即一个网络连接。一个连接进来，便注册到多路分解器（Synchronous Event Demultiplexer）中，以监听Handle中发生的事件</p><blockquote><p>什么是句柄？<br>类似于Linux中的文件描述符，在Windows中主要用来标识所有资源，例如一个窗口、按钮、图标、字体等等。<br>它像指针，但是它不同于指针。<br>句柄是系统所管理的引用标识,该标识可被系统定位到一块内存地址上，通过句柄可以访问内核对象。它内部已经封装好了对应的操作逻辑，有一张句柄表的玩意，我们使用句柄局限在特定范围内（所以这种间接访问对象的方式，显示出了系统对于引用资源的控制）；<br>而指针是包含引用对象的内存地址，是指向一块内存的指针,它没有封装对应的操作逻辑，我们可以自由发挥地操作它。</p></blockquote></li><li><p>Synchronous Event Demultiplexer<br><br />多路分解器。监听并阻塞直到Handle（句柄）中的事件发生，若阻塞返回，则无阻塞地执行返回的事件类型对应的处理。一般使用的解复用器是select，Linux2.6内核中提出了epoll，在JAVA NIO中用了Selector做封装。<br><br />//TODO 后续针对epoll、select、poll做一篇文章理解）</p></li><li><p>Initiation Dispatcher<br><br />启动调度程序。定义用于注册、删除和分派事件处理程序的接口。<br><br />当同步事件多路分解器检测到新事件时，通知启动调度程序（Initiation Dispatcher）回调特定于应用的事件处理程序。<br><br />常见的事件有连接就绪、读、写、超时事件。</p></li><li><p>Event Handler<br><br />事件处理器。定义事件的处理方法handle_event()，该方法抽象地表示特定于服务的事件调度操作。主要是给启动调度程序使用。</p></li><li><p>Concrete Event Handler<br><br />具体事件处理器，也可以说是逻辑处理器，是事件处理器接口的实现。实现特定事件的处理方法，应用向启动调度程序（Initiation Dispatcher）注册具体事件处理器，告知处理某些类型的事件。当事件到达时，启动调度程序（Initiation Dispatcher）会回调具体的逻辑处理方法。<br><br />比如一个网关服务中有一个具体事件处理器：参数处理程序，用于接收和过滤非法的参数。</p></li></ul><p><a name="f630b9a4"></a></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093931408-4c368689-863b-4c88-b53e-94d243d3ea77.jpeg#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=flow_chart.jpg&originHeight=238&originWidth=464&size=26767&status=done&style=none&width=464" alt="flow_chart.jpg"><br /><br><br />流程：<br /></p><ol><li>应用将具体事件处理程序（器）注册到启动调度程序，告知程序这个handler要处理哪种event， 每个EventHandler包含对相应Handle的引用 ;</li><li>启动调度程序请求每个事件处理程序，传回其内部句柄，该句柄向OS标识事件处理程序；</li><li>注册完所有事件处理程序后， 应用程序将调用处理事件，以启用事件循环（EventLoop），启动调度程序将来自每个已注册的事件处理程序的句柄进行组合，调用同步事件多路分解器的select()阻塞直到事件发生在这些句柄上；</li><li>当对应事件源的句柄变成“就绪”时（即某个或某些句柄的event发生后），比如TCP套接字已“就绪以供读取”，此时触发select()返回，通知启动调度程序；</li><li>启动调度程序响应事件处理程序上的的钩子方法，即执行对应的Event Handler来处理event。</li></ol><p><a name="af267e91"></a></p><h3 id="Reactor模型的优缺点"><a href="#Reactor模型的优缺点" class="headerlink" title="Reactor模型的优缺点"></a>Reactor模型的优缺点</h3><p><a name="52b8c184"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>异步非阻塞I/O。发起I/O请求非阻塞，实际的I/O操作交给了事件线程异步处理；</li><li>解耦。解耦了应用程序的实际处理逻辑，与应用不相关的解复用、调度机制，各司其职；</li><li>模块化。可以定义多个service，每个service负责自己的工作（逻辑），在模块化的同时，增强了复用性；</li><li>可移植性。不受限于特定OS，UNIX、Linux、Windows均支持Handle；</li><li>按序执行事件处理程序。启动调度程序的事件循环，是按序调用事件处理程序的，以减少复杂的同步机制。</li></ul><p><a name="2e769a75"></a></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>非抢占式的进程调度方式，在单线程的应用中，Event Handler执行是无法被中断而去做其他事，所以Event Handler处理event 时不能被block住，需要较长时间处理event的应用不适合Reactor模型。</li></ul><p><a name="21e37caf"></a></p><h3 id="为什么要用反应堆？"><a href="#为什么要用反应堆？" class="headerlink" title="为什么要用反应堆？"></a>为什么要用反应堆？</h3><blockquote><p>操作系统提供的系统函数select、epoll，本就可以使服务器维持较高TPS，承受并发十几万的连接（据说），在技术层面是满足性能要求；但是在软件编程层面看，这是一项很复杂的编程工作。</p></blockquote><p><br />从传统到IO多路复用到Reactor模型的调用，举个栗子，超市购物。<br /><br><br />在传统模型中，顾客购物买单，店长负责收银和被咨询工作，当顾客多时，需要排队；<br /><br><br />在IO多路复用的模型中，店长新招了一个售前店员，店员伴随着顾客购物，顾客有问题了店员帮助回答，当顾客示意将买单时，店员call店长准备买单；当顾客问一些商品的专业问题，店员不了解只好去问店主；当多个顾客想要同时购物仅剩的一件商品而出现打架时，店员示意暂停对外服务，并协助疏散顾客；类比到软件编程，就是面向过程的概念，系统需要关心如何实现某个事件的逻辑、还需要关心某个事件何时会发生、发生的条件等。<br /><br><br />在Reactor模型中，店长根据品类招了对应的专业售前店员，当顾客有问题对应的店员可以及时协助解决。此时的店员就是一个个具体的解决方案，类比到软件编程，Reactor模型下，就是面向对象（事件）的概念，通过定义一个个事件，并将具体业务和事件抽离开。<br /><br><br />总结：反应堆的执行效率虽然与IO多路复用几乎等价，但在软件编程上，反应堆解耦了应用程序的实际处理逻辑与应用不相关的解复用、调度机制，而多路复用是面向过程的思想，相对面向对象，它的开发效率降低，程序复杂性提高，不推荐！<br /></p><p><a name="7c55a2b4"></a></p><h3 id="几种Reactor模型"><a href="#几种Reactor模型" class="headerlink" title="几种Reactor模型"></a>几种Reactor模型</h3><p><br />略。<br /></p><p><a name="3dbf0c11"></a></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><br />Netty、Redis、nginx、 memcached<br /><br><br />推荐阅读： <a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="noopener">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a><br /><br><br />                        <a href="https://blog.csdn.net/russell_tao/article/details/17452997" target="_blank" rel="noopener">https://blog.csdn.net/russell_tao/article/details/17452997</a></p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（五）底层连接配置之ChannelOption</title>
      <link href="/2020/06/02/netty-wa-jue-ji-wu-di-ceng-lian-jie-pei-zhi-zhi-channeloption/"/>
      <url>/2020/06/02/netty-wa-jue-ji-wu-di-ceng-lian-jie-pei-zhi-zhi-channeloption/</url>
      
        <content type="html"><![CDATA[<p>上两篇主要介绍了如何结合spring和springboot搭建netty脚手架，其中在启动类中，我们通常会通过<code>ServerBootstrap.option</code>或者<code>ServerBootstrap.childOption</code>来配置TCP参数，合理的TCP参数配置对于项目的可用性还是挺重要的！<br /><br><br />那这一次我们来介绍一下Netty的TCP连接的底层参数配置：<code>io.netty.channel.ChannelOption</code><br /></p><p><a name="CxBF8"></a></p><h2 id="ChannelOption套接字配置"><a href="#ChannelOption套接字配置" class="headerlink" title="ChannelOption套接字配置"></a>ChannelOption套接字配置</h2><blockquote><p>Netty中关于套接字选项的设置，在<code>io.netty.channel.ChannelOption</code>这个类中。</p></blockquote><br /><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>SO_BROADCAST</td><td>对应套接字层的套接字：SO_BROADCAST，将消息发送到广播地址。</td></tr><tr><td>如果目标中指定的接口支持广播数据包，则启用此选项可让应用程序发送广播消息。</td><td></td></tr><tr><td>SO_KEEPALIVE</td><td>对应套接字层的套接字：SO_KEEPALIVE，保持连接。</td></tr><tr><td>在空闲套接字上发送探测，以验证套接字是否仍处于活动状态。</td><td></td></tr><tr><td>SO_SNDBUF</td><td>对应套接字层的套接字：SO_SNDBUF，设置发送缓冲区的大小。</td></tr><tr><td>SO_RCVBUF</td><td>对应套接字层的套接字：SO_RCVBUF，获取接收缓冲区的大小。</td></tr><tr><td>SO_REUSEADDR</td><td>对应套接字层的套接字：SO_REUSEADDR，本地地址复用。</td></tr><tr><td>启用此选项允许绑定已使用的本地地址。</td><td></td></tr><tr><td>SO_LINGER</td><td>对应套接字层的套接字：SO_LINGER，延迟关闭连接。</td></tr><tr><td>启用此选项，在调用close时如果存在未发送的数据时，在close期间将阻止调用应用程序，直到数据被传输或连接超时。</td><td></td></tr><tr><td>SO_BACKLOG</td><td>对应TCP/IP协议中_backlog_参数，_backlog_即连接队列，设置TCP中的连接队列大小。如果队列满了，会发送一个ECONNREFUSED错误信息给C端，即“ Connection refused”。</td></tr><tr><td>SO_TIMEOUT</td><td>等待客户连接的超时时间。</td></tr><tr><td>IP_TOS</td><td>对应套接字层的套接字：IP_TOS，在IP标头中设置服务类型（TOS）和优先级。</td></tr><tr><td>IP_MULTICAST_ADDR</td><td>对应IP层的套接字选项：IP_MULTICAST_IF，设置应发送多播数据报的传出接口。</td></tr><tr><td>IP_MULTICAST_IF</td><td>对应IP层的套接字选项：IP_MULTICAST_IF2，设置应发送多播数据报的IPV6传出接口。</td></tr><tr><td>IP_MULTICAST_TTL</td><td>对应IP层的套接字选项：IP_MULTICAST_TTL，在传出的 多播数据报的IP头中设置生存时间（TTL）。</td></tr><tr><td>IP_MULTICAST_LOOP_DISABLED</td><td>取消 指定应将 传出的多播数据报的副本 回传到发送主机，只要它是多播组的成员即可。</td></tr><tr><td>TCP_NODELAY</td><td>对应TCP层的套接字选项：TCP_NODELAY，指定TCP是否遵循Nagle算法 决定何时发送数据。Nagle算法代表通过减少必须发送包的个数来增加网络软件系统的效率。即尽可能发送大块数据避免网络中充斥着大量的小数据块。如果要追求高实时性，需要设置关闭Nagle算法；如果需要追求减少网络交互次数，则设置开启Nagle算法。</td></tr></tbody></table><br /><a name="K19pV"></a>## ChannelOption通用配置| 参数 | 解释 || --- | --- || ALLOCATOR | ByteBuf的分配器，默认值为ByteBufAllocator.DEFAULT。 || RCVBUF_ALLOCATOR | 用于Channel分配接受Buffer的分配器，默认值为AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。 || MESSAGE_SIZE_ESTIMATOR | 消息大小估算器，默认为DefaultMessageSizeEstimator.DEFAULT。估算ByteBuf、ByteBufHolder和FileRegion的大小，其中ByteBuf和ByteBufHolder为实际大小，FileRegion估算值为0。该值估算的字节数在计算水位时使用，FileRegion为0可知FileRegion不影响高低水位。 || CONNECT_TIMEOUT_MILLIS | 连接超时毫秒数，默认值30000毫秒即30秒。 || WRITE_SPIN_COUNT | 一个Loop写操作执行的最大次数，默认值为16。也就是说，对于大数据量的写操作至多进行16次，如果16次仍没有全部写完数据，此时会提交一个新的写任务给EventLoop，任务将在下次调度继续执行。这样，其他的写请求才能被响应不会因为单个大数据量写请求而耽误。 || WRITE_BUFFER_WATER_MARK |  || ALLOW_HALF_CLOSURE | 一个连接的远端关闭时本地端是否关闭，默认值为False。值为False时，连接自动关闭；为True时，触发ChannelInboundHandler的userEventTriggered()方法，事件为ChannelInputShutdownEvent。 || AUTO_READ | 自动读取，默认值为True。Netty只在必要的时候才设置关心相应的I/O事件。对于读操作，需要调用channel.read()设置关心的I/O事件为OP_READ，这样若有数据到达才能读取以供用户处理。该值为True时，每次读操作完毕后会自动调用channel.read()，从而有数据到达便能读取；否则，需要用户手动调用channel.read()。需要注意的是：当调用config.setAutoRead(boolean)方法时，如果状态由false变为true，将会调用channel.read()方法读取数据；由true变为false，将调用config.autoReadCleared()方法终止数据读取。 || AUTO_CLOSE |  |]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（四）结合springboot搭建netty脚手架</title>
      <link href="/2020/05/31/netty-wa-jue-ji-si-jie-he-springboot-da-jian-netty-jiao-shou-jia/"/>
      <url>/2020/05/31/netty-wa-jue-ji-si-jie-he-springboot-da-jian-netty-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<p>上文《Netty挖掘机（三）结合spring搭建netty脚手架》，结合Spring+Netty实现API接口服务模块，本文继续码字，以Springboot的方式接入Netty实现API接口服务。<br /><br><br />我们知道，spring-boot-starter-web 默认的web容器是Tomcat，同样也支持修改容器<br /><br><br />如要把Tomcat 切换为Jetty，我们首先要做的是先移除包中的Tomcat依赖，再加入Jetty容器<br /></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><br />以上操作，即可将默认的Tomcat容器切换为Jetty容器。<br /><br><br />然而，当使用Netty替代web容器的时候，也是上面这种做法吗？<br /><br><br />回顾下Netty和Servlet的区别<br /></p><ul><li>Servlet<br><br />Servlet是一种Java EE规范 ，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。<br><br />Tomcat和Jetty 是一个servlet容器，而Jetty比大多数的servlet容器要更轻，即轻量级的servlet容器。</li><li>Netty<br><br />而Netty是一个异步事件驱动的基于NIO的网络应用程序框架，它支持扩展实现自己的servlet容器。</li></ul><p><br />当需要面对处理大量网络协议的时候，建议使用Netty，当仅用于HTTP应用程序的时候，可以使用servlet容器。<br /><br><br />所以当使用Netty替代tomcat等servlet容器时，可以实现一个自定义的servlet容器。<br /></p><p><a name="67723949"></a></p><h2 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h2><ol><li>首先Springboot 中移除Tomcat 依赖；</li><li>引入Servlet依赖，自己实现一个Servlet上下文，并加入Spring上下文；</li><li>Netty捕获到一个完整的Http 请求后，转换为ServletRequest，交给DispatcherServlet处理；</li><li>DispatcherServlet内部进行解析， 调用HandlerMapping寻找处理器，找到对应的处理器Controller后执行并返回处理结果；</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590937108727-af422824-31a2-4260-b204-7fec1c7f31bb.jpeg#align=left&display=inline&height=519&margin=%5Bobject%20Object%5D&name=process.jpg&originHeight=519&originWidth=1066&size=31225&status=done&style=none&width=1066" alt="process.jpg"><br /></p><p><a name="475f2d9c"></a></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p><a name="c780a665"></a></p><h3 id="Maven-pom配置"><a href="#Maven-pom配置" class="headerlink" title="Maven pom配置"></a>Maven pom配置</h3><ul><li>主要引入了Netty、Springboot的相关依赖，并且排除了内嵌的tomcat包依赖；</li><li>项目中使用了Servlet来接收http，而我们又排除了tomcat依赖，所以需手动加上servlet-api依赖；</li></ul><p><a name="1b888f46"></a></p><h3 id="全局返回实体"><a href="#全局返回实体" class="headerlink" title="全局返回实体"></a>全局返回实体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResultVO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ResultVO <span class="token function">create</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">{</span>        ResultVO ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResultVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setMsg</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="acf861a0"></a></p><h3 id="定义功能类"><a href="#定义功能类" class="headerlink" title="定义功能类"></a>定义功能类</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResultVO <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"my name is jerry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="47381299"></a></p><h3 id="Netty-启动类"><a href="#Netty-启动类" class="headerlink" title="Netty 启动类"></a>Netty 启动类</h3><blockquote><p>通过Spring上下文找到dispatcherServlet，并传入Channel初始化配置类，用于执行具体的业务逻辑。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${netty.port:8080}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DispatcherServlet dispatcherServlet<span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"############# start server at port: {}... #############"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap                <span class="token comment" spellcheck="true">// 绑定两个组</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 创建NioServerSocketChannel实例</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 添加Channel初始化配置类</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpChannelInitializer</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 服务于boss线程(accept connect)</span>                <span class="token comment" spellcheck="true">// 设置TCP中的连接队列大小，如果队列满了，会发送一个ECONNREFUSED错误信息给C端，即“ Connection refused”</span>                <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置关闭tcp的Nagle算法（尽可能发送大块数据，避免网络中充斥着许多小数据块），要求高实时性</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置启用心跳保活机制</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="25751352"></a></p><h3 id="管道初始化配置类"><a href="#管道初始化配置类" class="headerlink" title="管道初始化配置类"></a>管道初始化配置类</h3><blockquote><p>每次有请求进来时，调用初始化配置，将处理器添加到管道。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>Channel ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpObjectAggregator</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpFirstServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpLastServerHandler</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>添加了一个支持最大消息为64*1024 kb大小的<code>HttpFirstServerHandler</code>，即聚合了多个Http片段。而一般不设置的话默认是有多个Http的片段组合成一次请求的；</li><li>添加了两个处理器，一个用于将Netty接收到的Http请求包装到<code>HttpServletRequest</code>中，一个用于接收<code>MockHttpServletRequest</code>，并使用dispatcherServlet执行内部的业务逻辑。</li></ul><p><a name="7a3e16e0"></a></p><h3 id="包装HttpServletRequest"><a href="#包装HttpServletRequest" class="headerlink" title="包装HttpServletRequest"></a>包装<code>HttpServletRequest</code></h3><blockquote><p>Netty捕获到一个完整的Http 请求后，转换为ServletRequest，转发到下一个处理器</p></blockquote><p><br />假设管道配置了聚合http片段时，入站处理器需要继承<code>SimpleChannelInboundHandler</code>。<br /><br><br />代码如下<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext channelHandlerContext<span class="token punctuation">,</span> FullHttpRequest fullHttpRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    MockHttpServletRequest servletRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MockHttpServletRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String uri <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>favicon<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    uri <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String method <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuf content <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fullHttpRequest<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> servletRequest<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span>header<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UriComponents uriComponents <span class="token operator">=</span> UriComponentsBuilder<span class="token punctuation">.</span><span class="token function">fromUriString</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String path <span class="token operator">=</span> uriComponents<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setRequestURI</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServletPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setScheme</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServerName</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServerPort</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>content<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    content<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> byteArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    String contentStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>byteArr<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>byteArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HttpMethod<span class="token punctuation">.</span>GET<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        QueryStringDecoder uriDecoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryStringDecoder</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>        uriDecoder<span class="token punctuation">.</span><span class="token function">parameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>param<span class="token operator">-</span><span class="token operator">></span> servletRequest<span class="token punctuation">.</span><span class="token function">addParameter</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>HttpMethod<span class="token punctuation">.</span>POST<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> contentMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>contentStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        servletRequest<span class="token punctuation">.</span><span class="token function">addParameters</span><span class="token punctuation">(</span>contentMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    channelHandlerContext<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="fb43c6fd"></a></p><h3 id="处理实际的业务逻辑"><a href="#处理实际的业务逻辑" class="headerlink" title="处理实际的业务逻辑"></a>处理实际的业务逻辑</h3><blockquote><p>DispatcherServlet内部进行解析， 调用HandlerMapping寻找处理器，找到对应的处理器Controller后执行并返回处理结果；</p></blockquote><p><br />假设管道配置了聚合http片段时，入站处理器需要继承<code>SimpleChannelInboundHandler</code>。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> MockHttpServletRequest servletRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MockHttpServletResponse servletResponse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MockHttpServletResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatcherServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>    String respContent <span class="token operator">=</span> servletResponse<span class="token punctuation">.</span><span class="token function">getContentAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuf resultBuf <span class="token operator">=</span> Unpooled<span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span>respContent<span class="token punctuation">,</span> CharsetUtil<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>    HttpResponseStatus status <span class="token operator">=</span> HttpResponseStatus<span class="token punctuation">.</span>OK<span class="token punctuation">;</span>    FullHttpResponse response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFullHttpResponse</span><span class="token punctuation">(</span>HttpVersion<span class="token punctuation">.</span>HTTP_1_1<span class="token punctuation">,</span> status<span class="token punctuation">,</span> resultBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加响应头信息</span>    HttpHeaders headers <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>HttpHeaderNames<span class="token punctuation">.</span>CONTENT_TYPE<span class="token punctuation">,</span> HttpHeaderValues<span class="token punctuation">.</span>APPLICATION_JSON  <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>HttpHeaderNames<span class="token punctuation">.</span>CONTENT_LENGTH<span class="token punctuation">,</span> resultBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"================= REQUEST END, cost {} ms =================\n"</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="dcc66630"></a></p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ApplicationContext applicationContext <span class="token operator">=</span> SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>HttpServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />好了，接下来开始启动程序，发现报错，很明显，描述是指缺少了<code>ServletWebServerFactory</code>这个bean，即未能加载嵌入的供web应用加载的空间。<br /></p><pre class=" language-java"><code class="language-java">Caused by<span class="token operator">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContextException<span class="token operator">:</span> Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean<span class="token punctuation">.</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">getWebServerFactory</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">206</span><span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">createWebServer</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">180</span><span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">onRefresh</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">154</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">8</span> common frames omitted</code></pre><p><br />查看源码，可以发现逻辑走向是这样的，<br /><br><br />先获取webServer和servletContext，如果两者都为null，则去获取ServletWebServer工厂，进而得到webServer，否则则开始启动上下文。<br /><br><br />如果不忽略tomcat，按正常的逻辑跑下去，一般是获取到<code>TomcatServletWebServerFactory</code>再去获得webSever。而且<code>ServletWebServerFactory</code>默认的实现类仅有几种<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590938693489-546dd5fa-51e9-4ca4-b891-34f017f36b5a.jpeg#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=servletWebServerFactory.jpg&originHeight=156&originWidth=1075&size=24025&status=done&style=none&width=1075" alt="servletWebServerFactory.jpg"><br /><br><br />综上，现在我们排除了tomcat的依赖，想要结合Netty自己实现一个Servlet上下文，则需要走else if的逻辑，即可得：servletContext不能为null。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">GenericWebApplicationContext</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableWebServerApplicationContext</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createWebServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        WebServer webServer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>webServer<span class="token punctuation">;</span>        ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>webServer <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> servletContext <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认获得Tomcat工厂实现类，用于获取Tomcat作为WebServer</span>            ServletWebServerFactory factory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWebServerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>webServer <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getWebServer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletContextInitializer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContextException</span><span class="token punctuation">(</span><span class="token string">"Cannot initialize servlet context"</span><span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">GenericWebApplicationContext</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableWebServerApplicationContext</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> ServletWebServerFactory <span class="token function">getWebServerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanNames <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>ServletWebServerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanNames<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContextException</span><span class="token punctuation">(</span><span class="token string">"Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />按以上的分析，由于是在<code>SpringApplication.run</code>的启动逻辑内报错，故我们需要在启动生命周期内，创建<code>ServletContext</code>这个bean<br /><br><br />这里可以使用<code>SpringApplicationRunListener</code>，并且通过spring.factories文件配置监听器即可生效<br /></p><blockquote><p>什么是<code>SpringApplicationRunListener</code>？<br>在调用<code>SpringApplication.run()</code>的过程中，会进行初始化事件体系，如果发现有自定义广播，则会将其设置成自身的事件广播，否则使用默认的<code>SimpleApplicationEventMulticaster</code>，代码在<code>org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</code>。<br><code>SpringApplicationRunListener</code>接口参与了Springboot的生命周期，开放了基于生命周期各个过程的接口，使得用户方便在指定的生命周期广播相应的事件</p></blockquote><p><a name="905b9be7"></a></p><h4 id="创建监听器"><a href="#创建监听器" class="headerlink" title="创建监听器"></a>创建监听器</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletListener</span> <span class="token keyword">implements</span> <span class="token class-name">SpringApplicationRunListener</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ServletListener</span><span class="token punctuation">(</span>SpringApplication application<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextPrepared</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">class</span> <span class="token class-name">SelfServletContext</span> <span class="token keyword">extends</span> <span class="token class-name">MockServletContext</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> ServletRegistration<span class="token punctuation">.</span>Dynamic <span class="token function">addServlet</span><span class="token punctuation">(</span>String servletName<span class="token punctuation">,</span> Servlet servlet<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> FilterRegistration<span class="token punctuation">.</span>Dynamic <span class="token function">addFilter</span><span class="token punctuation">(</span>String filterName<span class="token punctuation">,</span> Filter filter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelfServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setServletContext</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="spring.factories"></a></p><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h4><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">org.springframework.boot.SpringApplicationRunListener</span><span class="token punctuation">=</span><span class="token attr-value">cn.binary.jerry.netty.config.ServletListener</span></code></pre><p><br />接下来开始启动程序，启动正常，并且调试接口： <a href="http://localhost:8082/user/get/jy" target="_blank" rel="noopener">http://localhost:8082/user/get/jy</a><br /><br><br />发现在最后一个Handler中的<code>dispatcherServlet.service(servletRequest, servletResponse);</code>出错，报空指针…<br /><br><br />查看源码发现是在以下代码中，未找到ServletConfig这个配置，而<code>FrameworkServlet</code>是<code>DispatcherServlet</code>的父类，所以可以通过反射机制给父类的参数配置值<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">FrameworkServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServletBean</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> ServletConfig config<span class="token punctuation">;</span>    <span class="token keyword">public</span> ServletConfig <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">publishRequestHandledEvent</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> <span class="token keyword">long</span> startTime<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Throwable failureCause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>publishEvents <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationContext <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> processingTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 由于this.getServletConfig() 为null，获取不到servletName，导致报NPT</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletRequestHandledEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> WebUtils<span class="token punctuation">.</span><span class="token function">getSessionId</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getUsernameForRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span> processingTime<span class="token punctuation">,</span> failureCause<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p><br />既然没有配置，我们就手动帮它配，并且进行初始化<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ApplicationContext applicationContext <span class="token operator">=</span> SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取DispatcherServlet</span>    DispatcherServlet dispatcherServlet <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CommonUtils<span class="token punctuation">.</span><span class="token function">setDeclaredFieldValue</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">,</span> <span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MockServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>HttpServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />接下来开始启动程序，启动正常，并且调试接口： <a href="http://localhost:8082/user/get/jy" target="_blank" rel="noopener">http://localhost:8082/user/get/jy</a> ，一切正常了！<br /></p><p><a name="138a6766"></a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><br />在Netty In Action中提到，Server端的程序不建议使用<code>SimpleChannelInboundHandler</code>，因为执行了<code>channelRead0()</code>后会自动释放指向保存该消息的ByteBuf的内存引用，而在Server端往往需要回传数据给Client端，ctx.write()又是异步的，这样就会导致<code>channelRead0()</code>返回后写操作还没有完成。而一般对于Client端使用而言，已经有了传入消息并处理完了，此时便可以自动释放。所以一般开发中Server端的程序的入站处理器建议使用<code>ChannelInboundHandlerAdapter</code>。<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590938750240-d8379a1c-890a-4fb5-9ab0-a7efb47dcd3d.jpeg#align=left&display=inline&height=535&margin=%5Bobject%20Object%5D&name=channelRead_code.jpg&originHeight=535&originWidth=861&size=23509&status=done&style=none&width=861" alt="channelRead_code.jpg"><br /><br><br />到这里，基于Springboot+Netty实现的API框架已成功搭建好了哈。<br /><br><br />具体源码请查看github：<br /><br><br /><a href="https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-3" target="_blank" rel="noopener">https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-3</a></p><hr><p>Ending……<br /><br><br />阿黑在下一章节将继续源码剖析！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（三）结合spring搭建netty脚手架</title>
      <link href="/2020/05/31/netty-wa-jue-ji-san-jie-he-spring-da-jian-netty-jiao-shou-jia/"/>
      <url>/2020/05/31/netty-wa-jue-ji-san-jie-he-spring-da-jian-netty-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<p>上文《Netty挖掘机（二）初识Netty》，主要介绍了Netty的特性及其如何启动，启动的相关配置说明。这一篇主要讲一下如何结合Spring搭建Netty脚手架，实现API接口服务模块。<br /><br><br />结合Spring依赖注入的特性，在Netty的handler中获取上下文的bean，再通过uri找到匹配的方法。<br /></p><p><a name="20f02ddc"></a></p><h3 id="maven-pom配置"><a href="#maven-pom配置" class="headerlink" title="maven pom配置"></a>maven pom配置</h3><p><br />主要引入了Netty、Spring的依赖， 及其日志框架logback，很简单。<br /></p><p><a name="786e68ad"></a></p><h3 id="封装请求体"><a href="#封装请求体" class="headerlink" title="封装请求体"></a>封装请求体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiReq</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * HTTP protocol     */</span>    <span class="token keyword">private</span> String protocol<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ip     */</span>    <span class="token keyword">private</span> String remoteIp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request type     */</span>    <span class="token keyword">private</span> String method<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request uri     */</span>    <span class="token keyword">private</span> String uri<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request headers     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request data     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> data <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String controllerName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String invokeMethodName<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getParam</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="aa2bad4d"></a></p><h3 id="封装返回体"><a href="#封装返回体" class="headerlink" title="封装返回体"></a>封装返回体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiResp</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>8826517176378050058L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ApiResp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ApiResp <span class="token function">create</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">{</span>        ApiResp ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApiResp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setMsg</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="62fa2d54"></a></p><h3 id="定义Controller的基类，用于后续反射调用派生类方法"><a href="#定义Controller的基类，用于后续反射调用派生类方法" class="headerlink" title="定义Controller的基类，用于后续反射调用派生类方法"></a>定义Controller的基类，用于后续反射调用派生类方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiController</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ApiResp <span class="token function">invoke</span><span class="token punctuation">(</span>String invokeMethodName<span class="token punctuation">,</span> ApiReq req<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Method method <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>invokeMethodName<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ApiResp result <span class="token operator">=</span> <span class="token punctuation">(</span>ApiResp<span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="a9a58b76"></a></p><h3 id="定义一个功能类"><a href="#定义一个功能类" class="headerlink" title="定义一个功能类"></a>定义一个功能类</h3><p><br />用户功能类，这里只列出一个方法，返回简单的文字描述信息。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token keyword">extends</span> <span class="token class-name">ApiController</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ApiResp <span class="token function">get</span><span class="token punctuation">(</span>ApiReq req<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ApiResp<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"my name is "</span> <span class="token operator">+</span> req<span class="token punctuation">.</span><span class="token function">getParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="7d16d5f4"></a></p><h3 id="实现一个Netty-启动类"><a href="#实现一个Netty-启动类" class="headerlink" title="实现一个Netty 启动类"></a>实现一个Netty 启动类</h3><p><br />回顾一下上文讲到的启动类，其实启动类对外透明化，只要很简单的几行代码，就帮我们实现了很多配置，甚至有更多的透明化配置等着我们去使用。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractControllerAdapter controllerAdapter<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HttpServer</span><span class="token punctuation">(</span>AbstractControllerAdapter controllerAdapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>controllerAdapter <span class="token operator">=</span> controllerAdapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"############# start server at port: {}... #############"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap                <span class="token comment" spellcheck="true">// 绑定两个组</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 创建NioServerSocketChannel实例</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 添加处理器Handler</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 为通道Channel进行初始化配置</span>                        ChannelPipeline pipeline <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">HttpServerHandler</span><span class="token punctuation">(</span>controllerAdapter<span class="token punctuation">)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 服务于boss线程(accept connect)</span>                <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置关闭tcp的Nagle算法（尽可能发送大块数据，避免网络中充斥着许多小数据块），要求高实时性</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置启用心跳保活机制</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />其中在初始化配置中，可以看到主要配置了三个<br /></p><ul><li>HttpRequestDecoder：将字节解码为HttpRequest、HttpContent和LastHttpContent消息；</li><li>HttpResponseEncoder：将HttpResponse、HttpContent和LastHttpContent消息编码为字节；</li><li>HttpServerHandler：服务中转站，下面会提到。</li></ul><p><a name="080445ec"></a></p><h3 id="服务中转站"><a href="#服务中转站" class="headerlink" title="服务中转站"></a>服务中转站</h3><p><br />中转，即是一个协同者的角色，提供一个handler，拦截请求以执行入站和出战事件。<br /><br><br />ChannelHandler是Netty中处理器的抽象，Netty对其提供了很多种可以开箱即用的实现，包括运用于各种协议（如HTTP SSL）的ChannelHandler，在内部也使用了事件和Future。<br /><br><br />在这里我们用了其中的一个实现ChannelInboundHandlerAdapter来拦截和处理事件。其中涉及到Netty中对HTTP的执行流程的一个封装。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590936988432-8b30f96a-44d9-48b4-9b6d-47ef4dd89bd9.jpeg#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&name=full_http.jpg&originHeight=220&originWidth=705&size=8574&status=done&style=none&width=705" alt="full_http.jpg"><br /><br><br />以上是一次完整的Http请求，HttpRequest是请求的第一部分，包含Http头部信息；HttpContent是请求中存放数据的块体，不止一个；LastHttpContent标志请求的结束，也包含数据，也可能包含尾随的Http头部信息。<br /><br><br />按照这种顺序，接下来实现通过一次完整的Http请求获取数据<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractControllerAdapter adapter<span class="token punctuation">;</span>    <span class="token keyword">private</span> ApiReq req<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HttpServerHandler</span><span class="token punctuation">(</span>AbstractControllerAdapter adapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adapter <span class="token operator">=</span> adapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">HttpRequest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                HttpRequest request <span class="token operator">=</span> <span class="token punctuation">(</span>HttpRequest<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>                req <span class="token operator">=</span> ApiReq<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">LastHttpContent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String controllerName <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getControllerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                HttpContent content <span class="token operator">=</span> <span class="token punctuation">(</span>HttpContent<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> data <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">parseData</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                FullHttpResponse response <span class="token operator">=</span> ApiResp<span class="token punctuation">.</span><span class="token function">response</span><span class="token punctuation">(</span>adapter<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />到这里，基于Spring+Netty实现的API框架已成功搭建好了哈。<br /><br><br />具体源码请查看github：<br /><br><br /><a href="https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-2" target="_blank" rel="noopener">https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-2</a></p><hr><p>Ending……<br /><br><br />阿黑在下一章节将结合SpringBoot搭建Netty脚手架…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器系统日志管理logrotate</title>
      <link href="/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/"/>
      <url>/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br />对于业务系统，每天都会输出大量的日志，并且增长极快，久而久之在有限的容量内总会消耗完服务器的磁盘空间；<br /><br><br />当我们遇到故障需要排查的时候，日志往往是第一选择，然而当日志日渐庞大的时候，排查成问题，空间也成问题；<br /><br><br />线上埋点系统出现问题，排查发现硬盘被日志撑爆了。<br /><br><br />。。。<br /><br><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>帮我们解决了日志方面的繁琐问题，<br /></p><ul><li>它支持自动执行日志的（周期性）切割，压缩，删除</li><li>可以指定目录存放压缩日志文件</li><li>当执行出错时可以指定email发出邮件报警</li></ul><p><a name="e05dce83"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><br /><a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">logrotate</a>旨在简化对生成大量日志文件的系统的管理。它允许自动旋转，压缩，删除和邮寄日志文件。每个日志文件可以每天，每周，每月或当它变得太大时处理。通常，logrotate作为每天cron任务运行。<br /></p><p><a name="e655a410"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br />主流的Linux系统一般都会自带logrotate包，如果没有，则使用以下命令安装<br /></p><pre class=" language-shell"><code class="language-shell">$ yum install logrotate crontabs $ logrotate -vlogrotate 3.8.6 - Copyright (C) 1995-2001 Red Hat, Inc.This may be freely redistributed under the terms of the GNU Public LicenseUsage: logrotate [-dfv?] [-d|--debug] [-f|--force] [-m|--mail command] [-s|--state statefile]        [-v|--verbose] [-l|--log STRING] [--version] [-?|--help] [--usage] [OPTION...] <configfile></code></pre><p><a name="6255b094"></a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的默认配置文件放在 <code>/etc/logrotate.conf</code>，我们无需对它进行操作<br /></p><p><a name="95cfe8dc"></a></p><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>有一个针对日志的自定义配置文件夹 <code>/etc/logrotate.d/</code>，可以看到系统已经默认配置了syslog、yum等日志管理配置<br /></p><pre><code>$ ll /etc/logrotate.d/-rw-r--r-- 1 root root  76 Aug  2  2018 bootlog-rw-r--r-- 1 root root 160 Sep 15  2017 chrony-rw-r--r-- 1 root root 408 Aug  2  2018 psacct-rw-r--r-- 1 root root 224 Aug  9  2018 syslog-rw-r--r-- 1 root root 100 Aug 21  2018 yum</code></pre><p><a name="19dc45e9"></a></p><h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的执行文件放在 <code>/usr/sbin/logrotate</code><br /></p><p><a name="8dac4304"></a></p><h2 id="详细配置说明"><a href="#详细配置说明" class="headerlink" title="详细配置说明"></a>详细配置说明</h2><pre class=" language-shell"><code class="language-shell">/var/log/logback.log {    daily    rotate 30    compress    delaycompress    missingok       notifempty       size 30k       yearly    create 0600 root root    postrotate        # 输入指定的命令    endscript}</code></pre><ul><li>daily：日志文件按天轮换，还可以配置”weekly”，”monthly”，”yearly”。</li><li>rotate count：只能存储的归档文件数量，其他将被删除，如果count为0代表直接删除归档</li><li>compress：每次轮换完成后，将已轮换的归档用gzip压缩</li><li>delaycompress：与compress搭配使用，表示将最近归档文件的压缩推迟到下一个轮换周期</li><li>missingok：若当前日志文件缺少，则不发出错误消息而是继续执行下一个日志文件</li><li>notifempty：若当前日志为空，则不执行轮换</li><li>create mode owner group：在轮换之后，用指定权限创建新的日志文件，mode以八进制指定日志文件的模式（与chmod相同），owner指定将拥有日志文件的用户名，group指定日志文件将属于的组。可以省略任何日志文件属性，在这种情况下，新文件的那些属性将使用与原始日志文件相同的值来表示省略的属性。可以使用nocreate选项禁用此选项</li><li>postrotate/endscript：在所有指令完成后，postrotate和endscript里面指定的命令将被执行</li><li>size _size_：仅当日志文件大小超过指定字节大小时，才会触发轮换</li><li>dateext：使用当前日期作为命名格式</li><li>dateformat _format_string_：配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数</li></ul><p><br />更多配置查看<a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">官方说明</a><br /></p><p><a name="4c763bb6"></a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><a name="ce559ba2"></a></p><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><ul><li>-d, –debug：开启调试模式，此时不会执行实际操作，但会打印出整个执行流程</li><li>-f, –force：强制轮换文件</li><li>-m, –mail ：压缩日志后，发送日志到指定邮箱</li><li>-s, –state=statefile ：使用指定的状态文件</li><li>-v, –verbose ：显示转储过程</li></ul><p><a name="17d444b6"></a></p><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>自动运行<br><br />默认情况下， <a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>在安装时已创建了以天为单位的定时任务<pre class=" language-shell"><code class="language-shell">$ cat /etc/cron.daily/logrotate</code></pre></li></ul><p>#!/bin/sh<br>/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf<br>EXITVALUE=$?<br>if [ $EXITVALUE != 0 ]; then<br>    /usr/bin/logger -t logrotate “ALERT exited abnormally with [$EXITVALUE]”<br>fi<br>exit 0</p><pre><code>- &lt;br /&gt;当运行周期为周/月/年时，可以在/etc/cron.*/logrotate下配置即可，当然也可以手动配置到crontab上。- 手动运行   - debug模式（logrotate -d ）```shell$ logrotate -d /etc/logrotate.d/custom-log</code></pre><ul><li><p>verbose模式（logrotate -v ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -v /etc/logrotate.d/custom-log</code></pre></li><li><p>强制模式（logrotate -vf ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -vf /etc/logrotate.d/custom-log</code></pre></li></ul><p><a name="9c5945ef"></a></p><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><ol><li><p>强制模式不起作用<br><br />删除记录状态的文件</p><pre class=" language-shell"><code class="language-shell">$ rm /var/lib/logrotate/logrotate.status</code></pre></li><li><p>日志文件为空无法执行<br><br />那就让它不为空呗</p></li><li><p>使用nohup进行日志输出，接着日志切割后，原日志大小不变<br><br />改变nohup输出方式：nohup xxx.sh &gt;&gt; nohup.out &amp;，要有两个&gt;</p></li></ol><p><br />大概就是这样，让我们尝试接入到我们的系统内吧！</p>]]></content>
      
      
      <categories>
          
          <category> logrotate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计之错误码（二）</title>
      <link href="/2020/05/30/api-she-ji-zhi-cuo-wu-ma-er/"/>
      <url>/2020/05/30/api-she-ji-zhi-cuo-wu-ma-er/</url>
      
        <content type="html"><![CDATA[<p><a name="EtstL"></a></p><h2 id="错误码类型"><a href="#错误码类型" class="headerlink" title="错误码类型"></a>错误码类型</h2><p>上一篇说到，错误码类型会有业务错误码和系统错误码，所以我们必须要将其考虑进来<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588486291183-acc1f079-b50f-47fe-994a-7befc6480140.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=482&size=9821&status=done&style=none&width=482" alt="image.png"><br /></p><p><a name="eeyl1"></a></p><h2 id="错误码设计"><a href="#错误码设计" class="headerlink" title="错误码设计"></a>错误码设计</h2><p>错误码设计原则是，尽可能做到简洁。故我将错误码分成两部分：系统码（前4位）+错误码（后4位）<br />系统码和错误码区间区间 需通过后台申请。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588486466975-c2c05977-7f33-49e3-8446-d5494e64ac55.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=562&size=20319&status=done&style=none&width=562" alt="image.png"><br />由于要区分错误码类型，我定义了指定的区间进行分配，剩下未分配的区间，待后续动态扩展<br /><br><br />例如，我所在部门假设会有50个项目来开发，那么我可以申请区间为00010000-00500000的错误码。当然后续由于业务扩展，又增加了新的项目，亦可以重新申请新的错误码区间！<br /></p><p><a name="2uuq3"></a></p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>我考虑了两种场景，对内错误码API和开放错误码API。<br />基础的模型有：运营后台、错误码系统、错误码服务<br><a name="kv6FM"></a></p><h3 id="对内错误码"><a href="#对内错误码" class="headerlink" title="对内错误码"></a>对内错误码</h3><p>贯彻“错误码无侵入”的理念，对内设计的领域模型，主要有业务系统—&gt;错误码SDK&lt;—&gt;错误码内部API<br><a name="XkX0q"></a></p><h3 id="开放错误码"><a href="#开放错误码" class="headerlink" title="开放错误码"></a>开放错误码</h3><p>我们仅需要将错误码API接口开放即可，并 提供一套错误码API文档<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587195975740-66f381e2-0c28-4a6a-a464-f9a95d61ab06.png#align=left&display=inline&height=389&margin=%5Bobject%20Object%5D&name=image.png&originHeight=521&originWidth=1000&size=33575&status=done&style=none&width=746" alt="image.png"><br /></p><p><a name="P3eEF"></a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588495621963-ec565c00-55cf-4f61-a80a-8a9e64007ff4.png#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1161&size=91009&status=done&style=none&width=1161" alt="image.png"><br /></p><p><a name="vFpv2"></a></p><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>码盒项目基于Springboot + Spring cloud + Mysql搭建而成，项目架构比较简单。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588487357922-814f9fa7-62dd-44b9-85c8-92263f9f953b.png#align=left&display=inline&height=478&margin=%5Bobject%20Object%5D&name=image.png&originHeight=643&originWidth=1003&size=48545&status=done&style=none&width=746" alt="image.png"><br /></p><p><a name="vqdYr"></a></p><h3 id="运营后台"><a href="#运营后台" class="headerlink" title="运营后台"></a>运营后台</h3><ul><li><p>创建业务部门、业务系统</p></li><li><p>申请端口、系统码、错误码区间</p></li><li><p>修改错误码信息、及其错误描述</p></li><li><p>售后排查功能<br><a name="s6Kq9"></a></p><h3 id="错误码服务"><a href="#错误码服务" class="headerlink" title="错误码服务"></a>错误码服务</h3></li><li><p>内部错误码API接口</p></li><li><p>外部错误码API接口</p></li><li><p>错误码文档可视化<br><a name="PFghE"></a></p><h3 id="错误码提取"><a href="#错误码提取" class="headerlink" title="错误码提取"></a>错误码提取</h3><p>支持在编译期间，从业务中自动提取出错误码内容<br><a name="cHdkr"></a></p><h3 id="错误码SDK"><a href="#错误码SDK" class="headerlink" title="错误码SDK"></a>错误码SDK</h3><p>接入业务系统，通过配置中心配置，开启错误码同步及检测功能，并支持开启周期性更新错误码<br><a name="xoel4"></a></p><h3 id="错误码话术转换"><a href="#错误码话术转换" class="headerlink" title="错误码话术转换"></a>错误码话术转换</h3><p>待定。。。<br /></p><br /><br /></li></ul><p><a name="fsVRc"></a></p><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588488831390-1e0b2e66-35d9-45cf-aa94-ed7a58895462.png#align=left&display=inline&height=799&margin=%5Bobject%20Object%5D&name=image.png&originHeight=799&originWidth=1002&size=61758&status=done&style=none&width=1002" alt="image.png"><br />从上图看出，我这里区分了4个角色：项目负责人、产品、技术、用户<br /></p><p><a name="8MBao"></a></p><h3 id="负责人"><a href="#负责人" class="headerlink" title="负责人"></a>负责人</h3><p>这是接入码盒的第一步</p><ul><li>创建业务部门：根据部门信息，对应创建一条部门记录</li><li>创建业务系统：根据系统信息，对应创建一条系统记录，并自动生成一个系统码，4位组成</li><li>申请配置：这里不仅可以申请错误码区间，还可以申请域名，端口等，这样可以协同管理跨部门的信息</li></ul><p><br />当申请配置成功后，即可进行下一步<br><a name="1gd5n"></a></p><h3 id="技术线"><a href="#技术线" class="headerlink" title="技术线"></a>技术线</h3><p>引进码盒SDK即可，但是配置方式有以下几种<br><a name="wExmJ"></a></p><h4 id="配置错误码文件"><a href="#配置错误码文件" class="headerlink" title="配置错误码文件"></a>配置错误码文件</h4><p>这是最简单的一种接入方式。技术人员在具体的业务项目中引入码箱SDK，并在资源文件下定义code.json，内容参考如下</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">101</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"参数有误"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"请检查入参：必填参数是否为空，长度超出规定限制长度 或 是否不符合格式"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">102</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"系统繁忙"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"可能发生了网络或者系统异常，导致无法判定准确的转账结果。此时，商户不能直接当做转账成功或者失败处理，可以考虑采用相同的out_biz_no重发请求，或者通过调用“(alipay.fund.trans.order.query)”来查询该笔转账订单的最终状态"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">103</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"根据监管部门的要求，请补全您的身份信息解除限制"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"根据监管部门的要求，请补全您的身份信息解除限制"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><br /><p><a name="aW6rv"></a></p><h4 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h4><p>常见的项目，会将错误码定义在枚举类中，增加了可读性，以及便于迭代。<br />这里针对此业务错误码枚举类，增加了自定义注解 <code>@CodeBoxData</code> 的支持，如下。当然有些项目错误码多，需要按业务进行区分，即有多个枚举类，也一样在每个枚举类上添加 <code>@CodeBoxData</code> 注解。<br /><br><br />配置注解的目的，也是为了生成错误码信息到资源文件下的code.json文件中。<br />至于怎么生成，这里主要借鉴了lombok、mapstruct等的思路，它们基于注解处理器，给我们提供了很多丰富的功能。<br />在编译期间，码盒的注解处理器将会将枚举类的内容动态添加到code.json。接着等项目启动，SDK将会将生成的错误码同步到码盒系统。</p><p><a name="rmQAn"></a></p><h3 id="产品线"><a href="#产品线" class="headerlink" title="产品线"></a>产品线</h3><p>码盒提供了针对产品经理的一个解决方案，在公司产品经理和开发人员经常有这样几个苦恼：</p><ol><li>开发人员定义的错误信息太技术，导致涌出部分售后问题，引发产品不满：“这不是我设计的！”；</li><li>修改错误信息，必须改代码，重新发布，引发开发人员不满：“又来！”；</li><li>错误信息应该从哪里处理，前端？后端？中台？，引发开发人员疑惑：“是你，是你，还是你？”；</li></ol><p><br />以上问题，在码盒上统统解决，当发现错误信息会带来售后问题而需要优化时，仅需要在码盒后台修改即可！<br /></p><p><a name="3lZjy"></a></p><h2 id="业务接入"><a href="#业务接入" class="headerlink" title="业务接入"></a>业务接入</h2><p><a name="eUnVy"></a></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>业务项目基于Springboot + Spring cloud 框架<br /></p><p><a name="5tmFC"></a></p><h3 id="下载码盒项目"><a href="#下载码盒项目" class="headerlink" title="下载码盒项目"></a>下载码盒项目</h3><p><a href="https://github.com/qJerry/Code-Box" target="_blank" rel="noopener">https://github.com/qJerry/Code-Box</a></p><p><a name="Y927q"></a></p><h3 id="执行数据库脚本"><a href="#执行数据库脚本" class="headerlink" title="执行数据库脚本"></a>执行数据库脚本</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588496780981-63ca66bb-315c-4e90-98b7-4a0f1a04fd2e.png#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&name=image.png&originHeight=355&originWidth=428&size=18805&status=done&style=none&width=428" alt="image.png"></p><p><a name="WwDRB"></a></p><h3 id="更改码盒内部API配置文件"><a href="#更改码盒内部API配置文件" class="headerlink" title="更改码盒内部API配置文件"></a>更改码盒内部API配置文件</h3><p>数据库配置、端口配置、注册中心配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">hikari</span><span class="token punctuation">:</span>      <span class="token key atrule">username</span><span class="token punctuation">:</span> root      <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/code_box<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span>8<span class="token important">&amp;serverTimezone</span>=GMT%2B8<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8501</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>1002/eureka/</code></pre><p><a name="A0WFd"></a></p><h3 id="引入SDK"><a href="#引入SDK" class="headerlink" title="引入SDK"></a>引入SDK</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.qJerry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>CodeBox-Sdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p><a name="btjRy"></a></p><h3 id="添加自定义注解-CodeBoxData"><a href="#添加自定义注解-CodeBoxData" class="headerlink" title="添加自定义注解@CodeBoxData"></a>添加自定义注解@CodeBoxData</h3><p>在错误码枚举类上添加自定义注解，枚举类的参数参考如下</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@CodeBoxData</span><span class="token keyword">public</span> <span class="token keyword">enum</span> BusinessCodeEnum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设备：1000-1999</span>    <span class="token function">EQUIPMENT_NOT_EXIST</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"设备不存在"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 用户：2000-2499</span>    <span class="token function">USER_LOGIN_AGAIN</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">"请重新登录"</span><span class="token punctuation">,</span> <span class="token string">"当前缓存信息已过期，需要重新登录"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer code<span class="token punctuation">;</span>    String message<span class="token punctuation">;</span>    String detail<span class="token punctuation">;</span>    <span class="token function">BusinessCodeEnum</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">,</span> String detail<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>detail <span class="token operator">=</span> detail<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="wfh0H"></a></p><h3 id="业务项目配置文件添加码盒配置"><a href="#业务项目配置文件添加码盒配置" class="headerlink" title="业务项目配置文件添加码盒配置"></a>业务项目配置文件添加码盒配置</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">code</span><span class="token punctuation">:</span>  <span class="token key atrule">business</span><span class="token punctuation">:</span>    <span class="token key atrule">id</span><span class="token punctuation">:</span> 1    // 业务部门id    <span class="token key atrule">system</span><span class="token punctuation">:</span>      <span class="token key atrule">id</span><span class="token punctuation">:</span> 1    // 业务系统id  <span class="token key atrule">refresh</span><span class="token punctuation">:</span>    <span class="token key atrule">open</span><span class="token punctuation">:</span> false    // 是否开启周期性任务    <span class="token key atrule">cron</span><span class="token punctuation">:</span> 0 0/5 * * * <span class="token punctuation">?</span>    // 调度周期  <span class="token key atrule">sync-log</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><a name="NLHZd"></a></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>在每个需要用到错误码的地方，直接调用SDK的 <code>ResultVO.err()</code> 输入具体的错误码即可，如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ResultVO <span class="token function">getCode</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Strings<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span> name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">err</span><span class="token punctuation">(</span>10101L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">suc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然，SDK也内置了全局异常处理器<code>CodeBoxGlobalException</code>，直接传入错误码即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CodeBoxGlobalException</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="y6oBK"></a></p><h2 id="框架特色"><a href="#框架特色" class="headerlink" title="框架特色"></a>框架特色</h2><p><a name="pTn79"></a></p><h3 id="99-无侵入"><a href="#99-无侵入" class="headerlink" title="99%无侵入"></a>99%无侵入</h3><p>为了尽可能做到不侵入业务代码，我制作了一个SDK，并添加了自定义注解或者直接配置文件配置的形式进行接入<br /></p><p><a name="GS9he"></a></p><h3 id="自定义注解处理器"><a href="#自定义注解处理器" class="headerlink" title="自定义注解处理器"></a>自定义注解处理器</h3><p>支持在编译期间，对于在业务错误码枚举类上添加了自定义注解的类，将在编译期间，将其拉取到资源文件下的code.json中，业务技术方无需手写code.json文件，只需添加注解，即可快速完成接入的一大步。<br /></p><p><a name="u43Ed"></a></p><h3 id="动态字节码技术（对外透明化）"><a href="#动态字节码技术（对外透明化）" class="headerlink" title="动态字节码技术（对外透明化）"></a>动态字节码技术（对外透明化）</h3><p>内部封装了一个错误码工具类，使用了ASM动态字节码功能，在项目启动期间和周期性刷新错误码期间，将会动态添加或更新错误码到SDK的错误码枚举类中，对外透明化，业务仅需提供一个错误码作为入参，即可获取详细的错误码内容。<br /><strong>出发点：</strong><br />可能有些人包括我一开始会直接使用redis缓存来存放错误码信息。但从实际使用上看，错误码更多的是静态数据，一般不会去频繁改动，这时候放置于缓存就有点浪费资源了。故我在做自定义注解处理器的时候，就想到了使用动态字节码技术，在运行期间放置或修改错误码信息。<br /></p><p><a name="BnrZa"></a></p><h3 id="及时更新错误码内容"><a href="#及时更新错误码内容" class="headerlink" title="及时更新错误码内容"></a>及时更新错误码内容</h3><p>当在后台修改对应的错误码信息后，若开启了周期性刷新，则会定时同步最新数据到本地~~<br /></p><p><a name="P90Ko"></a></p><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p>可以配置是否要同步错误码日志到平台、配置接入码盒的方式、配置是否要定时更新后台同步的错误码信息等等<br /></p><p><a name="Eh02J"></a></p><h3 id="日志排查功能"><a href="#日志排查功能" class="headerlink" title="日志排查功能"></a>日志排查功能</h3><p>当配置了同步错误码日志到平台后，即可在后台查看具体的错误信息，并给出具体的解决方案。<br /></p><p><a name="If95A"></a></p><h3 id="错误日志导出"><a href="#错误日志导出" class="headerlink" title="错误日志导出"></a>错误日志导出</h3><br /><br /><p><a name="slp4k"></a></p><h2 id="项目状况"><a href="#项目状况" class="headerlink" title="项目状况"></a>项目状况</h2><p><a name="SZVna"></a></p><h3 id="已完成事项"><a href="#已完成事项" class="headerlink" title="已完成事项"></a>已完成事项</h3><p>已完成码盒服务、码盒SDK的开发<br /></p><p><a name="fMiLc"></a></p><h3 id="未完成事项"><a href="#未完成事项" class="headerlink" title="未完成事项"></a>未完成事项</h3><p>运营后台相关功能。<br /></p><p><a name="rOATz"></a></p><h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/qJerry/Code-Box" target="_blank" rel="noopener">https://github.com/qJerry/Code-Box</a></p>]]></content>
      
      
      <categories>
          
          <category> API错误码设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计之错误码（一）</title>
      <link href="/2020/05/03/api-she-ji-zhi-cuo-wu-ma-yi/"/>
      <url>/2020/05/03/api-she-ji-zhi-cuo-wu-ma-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于项目中自己负责的一块业务，经常会出现产品反馈给我“xxx失败了，帮忙看看什么问题”，而我就会马不停蹄地上服务器see logs。再者后续平台可能会做开放API的处理，此时此刻，亟不可待，需要一套完整的错误码设计方案出炉。用户—客服—产品 这一条线就可以通过错误码定位到问题，不用再到最后一步：开发。<br /></p><p><a name="xo9nX"></a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在参考了几个大厂的错误码规范后，我发现其实每家平台都有不同的考虑而下了不同的功夫，而我自认为比较周全（可能是文档的问题）的是Google Api的文档。<br />“该如何设计呢？”</p><ul><li>首先我想的第一点就是：简单。错误码设计必须简单易懂，不需要多华丽。</li></ul><p>所以我想到的方案就是：定义一个公共枚举类，首先定义出我负责模块的错误码和错误描述，以及解决方案。</p><ul><li>这时脑海中出现了第二个点：如何区分其他模块？一个系统不同业务模块必定会有不同的错误码，不能够让大家随着你的性子走，随便定义一个公共类就完事了吧，有什么亮点呢？</li></ul><p>错误码定制化，包括系统+模块+功能+错误码。<br />“这样就足够了吗？”<br /></p><p><a name="XzVaf"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><a name="s3edE"></a></p><h2 id="什么是错误码？"><a href="#什么是错误码？" class="headerlink" title="什么是错误码？"></a>什么是错误码？</h2><p>错误码，对于很多人而言就是一串数字，它关联了系统上的各种错误信息。<br />错误码带给我们的作用是什么？</p><ul><li>告知我们哪个系统哪个模块出了问题；</li><li>告知我们具体是什么问题；</li><li>通过决策和话术转换回显合理的错误内容给用户。</li></ul><p><a name="MiQro"></a></p><h2 id="错误码服务的人群"><a href="#错误码服务的人群" class="headerlink" title="错误码服务的人群"></a>错误码服务的人群</h2><ul><li>对于服务间的调用，即针对技术人员</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1581909865245-0fd083ff-47c3-4b75-bbac-c1ad9e8111ea.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=682&size=13082&status=done&style=none&width=682" alt="image.png"></p><ul><li>对于客户端的调用，即针对非技术人员</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1581909929407-1017b9b0-1422-4c6d-ad7e-40e8ed42e7c9.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=161&originWidth=681&size=12721&status=done&style=none&width=681" alt="image.png"><br /></p><p><a name="rpcKs"></a></p><h2 id="错误码服务的类型"><a href="#错误码服务的类型" class="headerlink" title="错误码服务的类型"></a>错误码服务的类型</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587191468061-1c34aa7e-d62c-4e96-b33e-bb3578a82436.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=386&size=2433&status=done&style=none&width=386" alt="image.png"><br /></p><p><a name="iEyMu"></a></p><h2 id="错误码设计的原则"><a href="#错误码设计的原则" class="headerlink" title="错误码设计的原则"></a>错误码设计的原则</h2><p><a name="t0aFW"></a></p><h3 id="规范的错误代码"><a href="#规范的错误代码" class="headerlink" title="规范的错误代码"></a>规范的错误代码</h3><p><a name="2G6kF"></a></p><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582019707581-16efc7a7-c742-4183-b9ec-5a2327d0e8ca.png#align=left&display=inline&height=122&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=721&size=9264&status=done&style=none&width=721" alt="image.png"><br /></p><ul><li>系统：</li></ul><p>即服务之上的定义，如Saas可以定义为一个系统，其中有一个个的服务<br />一般不用到这个级别的话，默认为0。</p><ul><li>应用：</li></ul><p>即服务，一个系统中可以有多个服务，这里基于实际服务数量，仅限定2位。</p><ul><li>功能：</li></ul><p>即功能接口，例如提现接口、支付接口等等。</p><ul><li>错误码：</li></ul><p>提示级别+自增代码。<br />错误提示级别，1：返回提示；2：返回不提示；3：隐藏性卖萌提示；<br />注意：很多系统都会将错误码和httpcode混合在一块，虽说我们现在大多采用的通信协议为http，但是同时市面上也有其他各种通信协议如dubbo、hessian、thrift等。当出现系统进行重构而更改了通信协议时，或者对接了其他不同通信协议的服务，将会是一件很棘手的事。故错误码应该不与httpcode耦合，而是应抽象出一套自己的selfcode。<br /><br><br />以上规范对于服务提供方而言，是非常适合的，便于快速定位到具体问题；<br />但是对于服务消费方而言，恐怕就无意义了，当我们做成开放API供第三方开发者接入时，就会面临第三方开发者徒增理解和交流的复杂度。</p><p><a name="OmsDp"></a></p><h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587191743115-adda4354-8385-4311-aa64-8ea572b0cd64.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=375&size=2535&status=done&style=none&width=375" alt="image.png"></p><ul><li>模块：</li></ul><p>可以当做应用来理解，也可以当做功能模块来理解，看系统的架构。</p><ul><li>错误码：</li></ul><p>自增代码。</p><p>相对于第一版而言，它更加简单清晰，且通过模块与错误码的绑定，更加快速定位问题，和降低沟通的成本。</p><p><a name="QBzUp"></a></p><h3 id="规范的错误消息"><a href="#规范的错误消息" class="headerlink" title="规范的错误消息"></a>规范的错误消息</h3><blockquote><p>错误消息应该帮助用户轻松，快速地理解和解决API错误。</p></blockquote><ul><li>不要假定用户是API专家。 用户可以是客户端开发人员，操作人员，IT人员或应用程序的最终用户。</li><li>不要假定用户了解服务实现或熟悉错误的上下文（如日志分析）。</li><li>如果可能，应构造错误消息，以便技术用户（但不一定是您的API开发人员）可以响应错误并进行更正。</li><li>保持错误消息简练。 如果需要请提供链接，这样困惑的读者可以提出问题，提供反馈或获取更多信息（这些信息不一定适合在错误消息中展示）。如果不合适，就可以使用详细信息字段展开。</li></ul><p><a name="Hxfk6"></a></p><h3 id="规范的错误细节（详细信息）"><a href="#规范的错误细节（详细信息）" class="headerlink" title="规范的错误细节（详细信息）"></a>规范的错误细节（详细信息）</h3><p>只有能够帮助应用程序处理错误时，才应该引入错误详细信息；<br />如果错误信息只能由人来处理，则仅依赖错误消息即可；<br />下面是一些示例<code>error_details</code>有效内容：</p><ul><li><code>RetryInfo</code>描述客户端何时可以重试失败的请求，可以返回<code>Code.UNAVAILABLE</code>或<code>Code.ABORTED</code></li><li><code>QuotaFailure</code>描述配额检查如何失败，可以返回<code>Code.RESOURCE_EXHAUSTED</code></li><li><code>BadRequest</code>描述客户端请求中的违例，可以返回<code>Code.INVALID_ARGUMENT</code></li></ul><br /><a name="Uj2EA"></a>### 标准的错误模型基于以上几点，我们可以得到如下大致的错误模型：```javapublic class Status {  // 规范化的错误码  int code = 1;  // 规范化的错误信息  String message = 2;  // 规范化的错误细节描述  Object details = 3;}```<p><a name="eBxrK"></a></p><h3 id="错误重试机制"><a href="#错误重试机制" class="headerlink" title="错误重试机制"></a>错误重试机制</h3><p>对于某些错误，是否需要进行重试的控制（此时也需要考虑API的幂等性）<br /></p><p><a name="L13I7"></a></p><h2 id="错误码的处理方式"><a href="#错误码的处理方式" class="headerlink" title="错误码的处理方式"></a>错误码的处理方式</h2><p>在分布式应用中，一个请求往往涉及到多个服务，这时如果请求出现异常，则不应该盲目将错误从服务端传播到客户端。同时也需要避免出现非技术人员看到技术性的错误。需进行合理翻译：</p><ul><li>隐藏接口实现的详细信息和机密信息。</li><li>调整发生错误的一方。基于自下而上的处理方式，从另一个服务收到错误的服务器，应将该错误层层传播给自己的调用方，最终由最上层的调用方来处理。</li></ul><p><br />类比到日常开发中，我们通常用Springboot搭建Api接口，按照约定的规范，定义了controller、service、dao层。对于一个请求贯通三层导致的异常，想必大多人都不会傻乎乎地使用大量的“try catch”充斥在代码里，而是通过全局异常错误处理器来处理错误。这也是我们惯有的思路。<br /></p><p><a name="OtaJj"></a></p><h2 id="错误码如何分配"><a href="#错误码如何分配" class="headerlink" title="错误码如何分配"></a>错误码如何分配</h2><blockquote><p>我们总会面临这么一个问题，不同业务线的同学，未使用规范好的错误代码，而导致出现同一个错误码出现了不同的错误信息，这样在业务代码中，不仅可能会多做了一些判断的语句，还会增加其他开发人员理解的复杂度。</p></blockquote><ul><li>各个业务线的部门，应该分配对应的错误码区间。</li></ul><p>怎么分配？在新建业务线时，负责人需要向上申请错误码（这里还可以延伸到申请端口、域名之类的信息，这样就可以集中梳理好文档，方便日后的调整）；</p><ul><li>一个业务线部门的多个系统，也应该继续分配对应的错误码区间，这样便能有效避免出现重复的错误码，造成麻烦。分配方式亦可以同上；</li><li>错误码区间，最好也按错误级别分配区间，如系统级别的异常分配a-b区间、业务级别的异常分配c-d区间。</li></ul><br /><p><a name="fmxPu"></a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>另一些思考：<br />确实，对于很多新业务来说，“规范”似乎总不会停留在嘴边，有也大多只会说“嗯，后面要搞的”，往往是“效率至上”。一个需求下来，你做的快，别人就夸你效率高，殊不知其间考虑少了多少东西，进而也许引发后续的重构灾难。<br /><br><br />对于错误码，可能很多人看来，随便定义了一个枚举类，按注释区分好就得了。但是真的够了吗？也许仔细想一下，还真的不够。既然不够，方案来凑。接下来将进行实战篇，开发一套错误码系统。</p>]]></content>
      
      
      <categories>
          
          <category> API错误码设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq引发的内存溢出</title>
      <link href="/2020/03/25/rabbitmq-yin-fa-de-nei-cun-yi-chu/"/>
      <url>/2020/03/25/rabbitmq-yin-fa-de-nei-cun-yi-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某一天，和我们配合的中台组给我们部门发了一组新的MQ配置，用于支付回调消息的接收，原来我们的某个项目已经有一个MQ，所以项目需要适配两个MQ（该项目都是作为消费者的角色）。<br /><br>rabbitmq使用的版本是<br /></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><br />兼容多MQ的代码<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>config<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>CachingConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RabbitTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Qualifier<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactoryConfigurer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Primary<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig1</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token keyword">public</span> ConnectionFactory <span class="token function">connectionFactory1</span> <span class="token punctuation">(</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.host}"</span><span class="token punctuation">)</span> String host<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.port}"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.username}"</span><span class="token punctuation">)</span> String username<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.password}"</span><span class="token punctuation">)</span> String password    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        CachingConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"rabbitTemplate1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token keyword">public</span> RabbitTemplate <span class="token function">rabbitTemplate1</span> <span class="token punctuation">(</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        RabbitTemplate rabbitTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"listenerContainerFactory1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> SimpleRabbitListenerContainerFactory <span class="token function">listenerContainerFactory1</span> <span class="token punctuation">(</span>            SimpleRabbitListenerContainerFactoryConfigurer configurer<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleRabbitListenerContainerFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configurer<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>AcknowledgeMode<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>config<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>CachingConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>support<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>Jackson2JsonMessageConverter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Qualifier<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactoryConfigurer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>condition<span class="token punctuation">.</span>ConditionalOnProperty<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"pay.callback.message.config.enable"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"connectionFactory2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ConnectionFactory <span class="token function">connectionFactory2</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.host}"</span><span class="token punctuation">)</span> String host<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.port}"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.userName}"</span><span class="token punctuation">)</span> String userName<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.password}"</span><span class="token punctuation">)</span> String password    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        CachingConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"listenerContainerFactory2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> SimpleRabbitListenerContainerFactory <span class="token function">listenerContainerFactory2</span> <span class="token punctuation">(</span>            SimpleRabbitListenerContainerFactoryConfigurer configurer<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory2"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleRabbitListenerContainerFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configurer<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setMessageConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setAcknowledgeMode</span><span class="token punctuation">(</span>AcknowledgeMode<span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setDefaultRequeueRejected</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br /><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>开发环境验证通过，发布到测试环境时，出现了以下异常<br><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584962184230-94cacf83-10fa-4a66-82e6-b2d0866ac935.png#align=left&display=inline&height=309&originHeight=309&originWidth=1379&status=done&style=none&width=1379" alt=""><br /><br>一下子就精神了，这就是臭名昭著的内存溢出<br />回顾以往出现内存溢出，往往有以下几种</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p><br />#### 堆空间溢出<br>java.lang.OutOfMemoryError: Java heap space<br /><br><br />出现的原因一般是</p><ul><li>数据突增。比如突然创建了大对象，超出了最大堆空间内存，可能还来不及回收，也可能根本就无法满足。</li><li>对象堆积。一般是程序编码有问题，导致创建的对象一直堆积在堆内存，无法被GC探测回收。</li></ul><p><a name="5owiu"></a></p><h4 id="永久代溢出"><a href="#永久代溢出" class="headerlink" title="永久代溢出"></a>永久代溢出</h4><p>java.lang.OutOfMemoryError: PermGen space<br /></p><p><a name="YBI5C"></a></p><h4 id="元空间溢出"><a href="#元空间溢出" class="headerlink" title="元空间溢出"></a>元空间溢出</h4><p>java.lang.OutOfMemoryError: Metaspace<br /><br><br />元空间的概念是在jdk1.8提出来的，用来取代以前的永久代。永久代<br /><br><br />遇到这种问题，冷静，接着一步步校验<br><a name="74rSx"></a></p><h3 id="查看jvm启动参数"><a href="#查看jvm启动参数" class="headerlink" title="查看jvm启动参数"></a>查看jvm启动参数</h3><pre class=" language-shell"><code class="language-shell">java -server -Xmx512M -Xms512M -Denv=FAT -XX:+UseCodeCacheFlushing -XX:+HeapDumpOnOutOfMemoryError -Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:-OmitStackTraceInFastThrow -jar /usr/local/application/**.jar</code></pre><p><br />可以看出，启动参数限制了最大堆内存是515M，因为是测试环境，部署了很多个项目，保险起见设置的，平时也都正常。<br /><br><br />那就是说调大最大堆内存就可以，接下来试一下把最大堆内存调整为1G。<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585108515492-d1f2688c-a8e7-431b-b0c3-e9e9d5588f6f.png#align=left&display=inline&height=197&name=image.png&originHeight=394&originWidth=1149&size=34669&status=done&style=none&width=574.5" alt="image.png"><br /><br><br />使用了测试环境的配置，更改启动参数，本地运行后，仍然会报错<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585020549225-b792bbee-e45c-46db-a495-e6134b1b260c.png?x-oss-process=image/resize,w_1492#align=left&display=inline&height=385&originHeight=385&originWidth=1492&status=done&style=none&width=1492" alt=""><br /><br><br />呃。。。。<br /></p><p><a name="8EZYi"></a></p><h3 id="查看VisualVm"><a href="#查看VisualVm" class="headerlink" title="查看VisualVm"></a>查看VisualVm</h3><p>这时候打开VisualVm看看，可以看到设置的最大堆大小在1000MB，而已使用的堆内存大小才100多MB，此时能够笃定是创建了大对象而导致的内存溢出。<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585113933509-612e463d-c2de-4119-8f15-3b08aae91b9d.png#align=left&display=inline&height=198&name=image.png&originHeight=395&originWidth=938&size=39095&status=done&style=none&width=469" alt="image.png"><br /><br><br /></p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>这一步开始来断点，排查大对象从哪里来，此时查看报错的源码，发现确实是因为大对象的创建导致<br />代码在<code>com.rabbitmq.client.impl.Frame</code> 类中，Frame是指AMQP协议层面的通信帧。</p><p>对于Frame的理解，可以查看其它博客：<a href="https://blog.csdn.net/usagoole/article/details/83048009" target="_blank" rel="noopener">https://blog.csdn.net/usagoole/article/details/83048009</a><br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585031558601-735fded5-3c8c-4a16-907b-37405ff6aa0a.png?x-oss-process=image/resize,w_968#align=left&display=inline&height=405&originHeight=405&originWidth=968&status=done&style=none&width=968" alt=""><br /><br><br />从上图可以看到，输入流读取的字节数为1345270062，这时候即创建了一个大小为1345270062（1.2G）的字节数组，于是乎出现内存溢出。</p><p>至于为什么会突然读取到这么大的字节数，重新调试，我把断点打在<code>com.rabbitmq.client.impl.SocketFrameHandler</code><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585114607912-18d1f90f-89d0-4828-a3b0-9bd8be57e17b.png#align=left&display=inline&height=124&name=image.png&originHeight=247&originWidth=1120&size=29771&status=done&style=none&width=560" alt="image.png"></p><p>系统有两个MQ，原有的MQ一切正常，从支付回调MQ开始，就开始报错了，所以初步怀疑是这个MQ账号的问题，或许是账号不对？没有远程登录的权限？</p><p><a name="MOeVr"></a></p><h3 id="理解源码"><a href="#理解源码" class="headerlink" title="理解源码"></a>理解源码</h3><p>Rabbitmq是基于socket连接读取的输入流，再将它转成字节数组。<br />先熟悉一下<code>com.rabbitmq.client.impl.Frame</code><br />帧（Frame），AMQP协议层面的通信帧</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585123637246-3dec2065-2aa4-4df0-98cd-37df07cf4ddd.png#align=left&display=inline&height=179&originHeight=179&originWidth=1162&size=0&status=done&style=none&width=1162" alt=""><br /><br><br />上图从左到右依次为帧类型、通道编号、帧大小、内容、结束标记组成一个帧<br /><br><br />从上面调试的代码可以看出，我们是打算取出payload这一段内容时，超出了长度。<br /><br><br />再看看以下代码，<br />readInt()的作用是，读取四个输入字节，并做了位移运算，返回一个整型值。<br />一个int存储的是32位的整型数据，32bit = 4 * 1byte，即表明每次从输入流里读取4个字节的数据；<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> payloadSize <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> ch1 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch2 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch3 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch4 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch1 <span class="token operator">|</span> ch2 <span class="token operator">|</span> ch3 <span class="token operator">|</span> ch4<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch1 <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch2 <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch3 <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch4 <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585130485796-42921d27-6590-4d14-b9db-5f95b68556d5.png#align=left&display=inline&height=168&name=image.png&originHeight=168&originWidth=955&size=18264&status=done&style=none&width=955" alt="image.png"><br /><br><br />断点可以看出，返回的整型值，也就是payload的长度，达到了1345270062，这样下一步创建byte对象的时候，就出现内存溢出的事故。</p><p>但是为什么会出现这个大对象，回过头去分析readInt()，<code>in.read()</code>将16进制的网络字节码 转为10进制的数组，正<br />是因为读取的数据有问题，才导致位移运算后得到一个比较大的整型值。<br /></p><p><a name="1q2wB"></a></p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>围绕着上面这个问题，此时需要抓个包看看，采取的是边断点边抓包的方式。<br /></p><ul><li>打开抓包工具，过滤器设置指定ip为MQ的host</li><li>先断点到111行，接着启动程序</li></ul><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585131449012-9dfcd943-bf61-4827-83e7-67fa4b5f1aa8.png#align=left&display=inline&height=130&name=image.png&originHeight=130&originWidth=748&size=15506&status=done&style=none&width=748" alt="image.png"><br /></p><ul><li>当打到该断点的时候，看到帧大小比较大的时候，进入readInt()</li></ul><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585131606794-e80def82-36f6-40b8-ab8d-beb113afa79a.png#align=left&display=inline&height=274&name=image.png&originHeight=274&originWidth=1157&size=30045&status=done&style=none&width=1157" alt="image.png"><br /><br><br />可以看到此时读取的4个数值分别是80、47、49、46，由于是网络字节码转过来的，故转为16进制后，对应为<br /></p><pre class=" language-java"><code class="language-java">DEC<span class="token operator">:</span><span class="token number">80</span>    <span class="token number">47</span>    <span class="token number">49</span>    <span class="token number">46</span>HEX<span class="token operator">:</span><span class="token number">50</span>  <span class="token number">2F</span>    <span class="token number">31</span>    2E    </code></pre><ul><li>查看抓包</li></ul><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585132560127-4d4a3dc5-2de0-4f22-aadb-b7557b62093a.png#align=left&display=inline&height=542&name=image.png&originHeight=542&originWidth=717&size=57551&status=done&style=none&width=717" alt="image.png"><br /><br><br />从抓包可以看到，字节码对上了，而且看到响应码为400，Bad Request！！！<br /><br><br />这也验证了一开始提到的猜测：MQ账号有问题，于是咨询了中台组，最终发现，是因为1.0部门给的端口有问题，导致socket无法连接！<br /><br><br /></p>]]></content>
      
      
      <categories>
          
          <category> Rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器监控netdata</title>
      <link href="/2020/03/18/fu-wu-qi-jian-kong-netdata/"/>
      <url>/2020/03/18/fu-wu-qi-jian-kong-netdata/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Netdata"><a href="#什么是Netdata" class="headerlink" title="什么是Netdata"></a>什么是Netdata</h1><p>简单一句话，Netdata是一个分布式的实时健康监测系统。</p><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>对象</td><td>针对系统和应用程序的分布式，实时，性能和运行状况监视</td></tr><tr><td>可视化</td><td>Netdata使用高度互动的Web仪表板实时提供无与伦比的洞察力，以实时了解其运行的系统（包括Web服务器，数据库，应用程序）上发生的一切</td></tr><tr><td>自动化与集成化</td><td>它可以自动运行，无需任何第三方组件，也可以集成到现有的监视工具链（Prometheus，Graphite，OpenTSDB，Kafka，Grafana等）</td></tr><tr><td>高效</td><td>Netdata快速高效，旨在永久在所有系统（物理和虚拟服务器，容器，IoT设备）上运行，而不会中断其核心功能</td></tr><tr><td>分布式</td><td>可以针对多个节点进行统一管理</td></tr><tr><td>开源</td><td>Netdata是免费的开源软件，目前可在Linux，FreeBSD和MacOS上运行。</td></tr></tbody></table><p>Netdata诞生的背景，有兴趣的同学可以看看：<a href="https://blog.netdata.cloud/posts/redefining-monitoring-netdata/" target="_blank" rel="noopener">使用Netdata重新定义监视</a></p><p><a name="gXXM9"></a></p><h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>参考：<a href="https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually</a></p><p><a name="eRo7M"></a></p><h2 id="Netdata插件"><a href="#Netdata插件" class="headerlink" title="Netdata插件"></a>Netdata插件</h2><p>以下插件，在安装时可以选择启用或禁用</p><table><thead><tr><th>软件包名</th><th>描述</th></tr></thead><tbody><tr><td><code>bash</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>curl</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>iproute</code> 或 <code>iproute2</code></td><td>用于监控** Linux流量QoS **<br />如果<code>iproute</code>提示不可用或已过时，请使用<code>iproute2</code></td></tr><tr><td><code>python</code></td><td>这对于大多数外部插件来说都是必须的</td></tr><tr><td><code>python-yaml</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-beanstalkc</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-dnspython</code></td><td>用于监控DNS的查询时间</td></tr><tr><td><code>python-ipaddress</code></td><td>用于监控** DHCPd **<br />只有Python V2才需要此软件包。Python V3已经嵌入了此功能</td></tr><tr><td><code>python-mysqldb</code><br />或<br /><code>python-pymysql</code></td><td>用于监控<strong>mysql</strong>或<strong>mariadb</strong> 数据库<br /><code>python-mysqldb</code>会运行地更快，所以它是首选</td></tr><tr><td><code>python-psycopg2</code></td><td>用于监控<strong>postgresql</strong>数据库</td></tr><tr><td><code>python-pymongo</code></td><td>用于监控<strong>mongodb</strong>数据库</td></tr><tr><td><code>nodejs</code></td><td>用于<code>node.js</code>插件来监控<strong>named</strong>和<strong>SNMP</strong>设备</td></tr><tr><td><code>lm-sensors</code></td><td>用于监控<strong>hardware sensors</strong></td></tr><tr><td><code>libmnl</code></td><td>用于收集netfilter指标</td></tr><tr><td><code>netcat</code></td><td>用于从远程系统中收集指标的Shell插件</td></tr></tbody></table><p>如果安装了上述软件包，Netdata功能将大大增加，但如果没有它们，Netdata仍然可以正常工作</p><p><a name="byYm9"></a></p><h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><blockquote><p>要在任何Linux系统（物理，虚拟，容器，IoT，边缘）上从源代码安装Netdata并使其与最新的版本自动保持最新，请运行以下命令</p></blockquote><pre class=" language-shell"><code class="language-shell"># make sure you run `bash` for your shellbash# install Netdata directly from GitHub sourcebash <(curl -Ss https://my-netdata.io/kickstart.sh)</code></pre><p>自动安装后，netdata默认的配置文件放在<code>/etc/netdata/netdata.conf</code>中</p><p>如果自动安装不顺利的同学， 可以采用手动安装的方式。</p><p><a name="2RgXA"></a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p><a name="deBqx"></a></p><h3 id="安装Netdata所需的软件包"><a href="#安装Netdata所需的软件包" class="headerlink" title="安装Netdata所需的软件包"></a>安装Netdata所需的软件包<br /></h3><p><a name="djGNn"></a></p><h4 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h4><p>系统监控和许多应用程序监控，它没有mysql /mariadb，postgres，named，硬件监控和SNMP。</p><pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata</code></pre><br /><a name="G0hej"></a>#### 完整安装<pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata-all</code></pre><br /><a name="eEtu9"></a>### 安装Netdata<pre class=" language-shell"><code class="language-shell"># 下载Netdata（同时创建netdata目录）git clone https://github.com/netdata/netdata.git --depth=1cd netdata# 运行具有root权限的脚本来编译安装Netdata并启动它./netdata-installer.sh</code></pre><p>注意</p><ul><li>如果不想安装完后启动Netdata，加上<code>--dont-start-it</code> 参数</li><li>如果不想安装在默认目录，则可以这样，<code>./netdata-installer.sh --install /opt</code>，即可安装到<code>/opt/netdata</code> 中</li><li>安装完后， <code>/opt/netdata/etc/netdata/netdata.conf</code>配置文件会自动被创建，可以编辑此文件以更改设置首选项。一个最常见被调整选项是history，它控制Netdata将使用的内存数据库大小。其默认情况下应为“3600”秒（图表中一小时的数据），这使得Netdata将使用大约10-15MB的RAM（取决于系统检测到的图表数量）。请检查内存要求。  当修改配置后，需要重启</li></ul><p><a name="HBX6N"></a></p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>启动，停止和重新启动Netdata</p><pre class=" language-shell"><code class="language-shell">service netdata startservice netdata stopservice netdata restart</code></pre><p>当使用<code>service</code>（系统首选基于系统启动或停止的方法）无法实现的时候，可以尝试对<code>systemd</code>和<code>init.d</code>使用等效命令</p><pre class=" language-shell"><code class="language-shell">systemctl start netdatasystemctl stop netdatasystemctl restart netdata/etc/init.d/netdata start/etc/init.d/netdata stop/etc/init.d/netdata restart</code></pre><p><a name="OpWZX"></a></p><h2 id="访问Netdata仪表盘"><a href="#访问Netdata仪表盘" class="headerlink" title="访问Netdata仪表盘"></a>访问Netdata仪表盘</h2><p>打开<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><br />当出现无法访问的时候，检查下防火墙的状态，测试环境下将它关闭即可（生产环境不建议）。或者查看安全组是否屏蔽了该端口</p><pre class=" language-shell"><code class="language-shell"># 查看防火墙状态firewall-cmd --state# 关闭，或者指定开启某个端口的入站systemctl stop firewalld.service</code></pre><p><a name="qIvfM"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th>路径</th><th>所有者</th><th>权限</th><th>Netdata</th><th>注释</th></tr></thead><tbody><tr><td><code>/etc/netdata</code></td><td>用户  <code>root</code><br />组 <code>netdata</code></td><td>目录<code>0755</code><br />文件<code>0640</code></td><td>读</td><td><strong>Netdata配置文件</strong><br />可能包含敏感信息，因此<code>netdata</code>允许组读取它们。</td></tr><tr><td><code>/usr/libexec/netdata</code></td><td>用户  <code>root</code><br />组 <code>root</code></td><td>任何人都可以执行<br />dirs <code>0755</code><br />文件<code>0644</code>或<code>0755</code></td><td>执行</td><td><strong>Netdata插件</strong><br />权限取决于文件-并非所有<strong>插件</strong>都应具有可执行标志。<br />有一些带有升级权限（Linux功能或<code>setuid</code>）的插件-这些插件应该仅按组可执行<code>netdata</code>。</td></tr><tr><td><code>/usr/share/netdata</code></td><td>用户  <code>root</code><br />组 <code>netdata</code></td><td>任何人的<br />目录<code>0755</code><br />文件都可读<code>0644</code></td><td>通过网络读取和发送</td><td><strong>Netdata Web静态文件</strong><br />这些文件通过网络发送给有权访问Netdata Web服务器的任何人。Netdata会检查这些文件的所有权（使用的<code>[web]</code>部分的设置<code>netdata.conf</code>），如果文件所有权不正确，则拒绝提供这些文件。不支持符号链接。Netdata也拒绝提供<code>..</code>名称中的URL 。</td></tr><tr><td><code>/var/cache/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>netdata</code></td><td>目录<code>0750</code><br />文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata临时数据库文件</strong><br />Netdata在此处存储其临时实时数据库。</td></tr><tr><td><code>/var/lib/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>netdata</code></td><td>目录<code>0750</code><br />文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata永久数据库文件</strong><br />Netdata在此处存储注册表数据，运行状况警报日志db等。</td></tr><tr><td><code>/var/log/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>root</code></td><td>目录<code>0755</code><br />文件<code>0644</code></td><td>写，创造</td><td><strong>Netdata日志记录</strong><br />所有Netdata应用程序，将它们的错误或其他参考消息记录到此目录中的文件中。这些文件应进行日志轮换。</td></tr></tbody></table><p><a name="wvtdc"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a name="5aT8C"></a></p><h2 id="netdata-conf"><a href="#netdata-conf" class="headerlink" title="netdata.conf"></a>netdata.conf</h2><p>参考<a href="https://docs.netdata.cloud/daemon/config/" target="_blank" rel="noopener">https://docs.netdata.cloud/daemon/config/</a><br />可通过<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><a href="http://your_server_ip:19999/netdata.conf" target="_blank" rel="noopener">/netdata.conf</a> 查看netdata的配置信息，注释的配置使用对应的默认值<br />包含了很多配置项，如global、web、plugins、health、registry、cloud、backend、statsd等。每一个配置项下，有key-value的配置，通过key我们能比较快速地知道其含义。</p><p><a name="JP3Wj"></a></p><h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>默认端口为19999</p><pre class=" language-shell"><code class="language-shell">[web]        # default port = 19999</code></pre><p><a name="5EehV"></a></p><h3 id="修改左上角hostname"><a href="#修改左上角hostname" class="headerlink" title="修改左上角hostname"></a>修改左上角hostname</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350636961-acbafd22-e45c-43f3-ad1c-e21b62fe18f5.png#align=left&display=inline&height=81&name=image.png&originHeight=162&originWidth=438&size=11915&status=done&style=none&width=219" alt="image.png"></p><pre class=" language-shell"><code class="language-shell">[global]        hostname = localhost-1</code></pre><p><a name="6QA90"></a></p><h3 id="当配置多个节点后，修改注册节点的名称"><a href="#当配置多个节点后，修改注册节点的名称" class="headerlink" title="当配置多个节点后，修改注册节点的名称"></a>当配置多个节点后，修改注册节点的名称</h3><p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350889946-22b8be07-eb61-41c8-9d86-d355b365c606.png#align=left&display=inline&height=170&name=image.png&originHeight=340&originWidth=558&size=28206&status=done&style=none&width=279" alt="image.png"></strong></p><pre class=" language-shell"><code class="language-shell">[registry]        registry hostname = local192.168.2.57</code></pre><p><a name="jcWWM"></a></p><h3 id="修改内存使用"><a href="#修改内存使用" class="headerlink" title="修改内存使用"></a>修改内存使用</h3><p>Netdata使用history标签作为配置内存使用的key，默认为3996秒，即在图表中你能看到的条目数。</p><p>参考以下估算标准，条目数与对应使用的内存</p><ul><li>3600秒（图表数据保留1小时）使用15 MB RAM</li><li>7200秒（图表数据保留2小时）使用30 MB RAM</li><li>14400秒（图表数据保留4小时）使用60 MB RAM</li><li>28800秒（图表数据保留8小时）使用120 MB RAM</li><li>43200秒（图表数据保留12小时）使用180 MB RAM</li><li>86400秒（24小时图表数据保留）使用360 MB RAM</li></ul><p>假设我想让Netdata保留2个小时的图表数据，则可以配置为</p><pre class=" language-shell"><code class="language-shell">[global]        history = 7200</code></pre><p><a name="3doYv"></a></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>参考<a href="https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start" target="_blank" rel="noopener">https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start</a><br />为了提高性能和安全性，Netdata官方十分建议在Netdata前面添加一个代理。在这里，我们通常使用Nginx作为代理工具，并结合Cerbot来使用。</p><blockquote><p>什么是Cerbot？<br>Certbot是一种工具，可帮助您为您的域创建和续订证书+密钥对，注意，它是免费的！</p></blockquote><p><a name="18wXs"></a></p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>怎么安装和配置Nginx就不说了，这里贴一下官方建议的代理Netdata的配置<br />创建一个文件/etc/nginx/sites-available/netdata，内容如下 </p><pre class=" language-shell"><code class="language-shell">upstream backend {    server 127.0.0.1:19999;    keepalive 64;}server {    listen 80;    # Change `example.com` to match your domain name.    server_name netdata.example.com;    location / {        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://backend;        proxy_http_version 1.1;        proxy_pass_request_headers on;        proxy_set_header Connection "keep-alive";        proxy_store off;    }}</code></pre><p>运行测试配置文件是否正常</p><pre class=" language-shell"><code class="language-shell">sudo nginx -t</code></pre><p>如果没返回错误，再运行以下命令，在<code>sites-enabled</code>目录中创建软链接，重启以生效</p><pre class=" language-shell"><code class="language-shell">sudo ln -s /etc/nginx/sites-available/netdata /etc/nginx/sites-enabled/netdata</code></pre><p><a name="Dcdvn"></a></p><h3 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h3><p>Netdata还建议我们尽可能最大化地使用好代理：加密的HTTPS连接。所以Netdata给我们提供了一个免费的证书生成工具Certbot，使用它，我们将能自动生成证书，并能够支持自动地更新证书，运行以下命令</p><pre class=" language-shell"><code class="language-shell">sudo certbot --nginx</code></pre><p>系统会提示您一些问题。在Which names would you like to activate HTTPS for?提问时，点击 Enter。接下来是这个问题：</p><pre class=" language-shell"><code class="language-shell">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you're confident your site works on HTTPS. You can undo thischange by editing your web server's configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</code></pre><p>如果确定想要强制使用HTTPS的话，则选择2，并且确定。</p><p>这样，我们就真正完成了代理的配置。</p><p><a name="FoKgv"></a></p><h3 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h3><p>当我们把代理设置完后，我们可能还需要一个密码验证，运行以下命令</p><pre class=" language-shell"><code class="language-shell"># 指定用户名为user，添加到.htpasswd文件中sudo sh -c "echo -n 'user:' >> /etc/nginx/.htpasswd"# 创建密码，系统将提示您创建一个密码sudo sh -c "openssl passwd -apr1 >> /etc/nginx/.htpasswd"</code></pre><p>打开Nginx配置文件，添加权限校验的配置吗，授权用户文件指向刚才创建的.htpasswd</p><pre class=" language-shell"><code class="language-shell">location / {        auth_basic "Restricted Content";        auth_basic_user_file /etc/nginx/.htpasswd;        ...}</code></pre><p>接着再重启nginx，即可开启密码校验功能。</p><p><a name="AOm0c"></a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a name="q69aK"></a></p><h2 id="仪表板区域"><a href="#仪表板区域" class="headerlink" title="仪表板区域"></a>仪表板区域</h2><p>Netdata的仪表板主要分为了三个区域：栏目、菜单、节点菜单<br><a name="n4R4n"></a></p><h3 id="栏目"><a href="#栏目" class="headerlink" title="栏目"></a>栏目</h3><p>分为多个部分，例如系统概述，CPU，磁盘，内存等<br />例如下面的内存栏目<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091930943-803eeaa8-14b8-46e2-83cd-e7b6987b027a.png#align=left&display=inline&height=1747&name=memorysection.png&originHeight=1747&originWidth=1108&size=218059&status=done&style=none&width=1108" alt="memorysection.png"></p><p><a name="up7Ct"></a></p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>菜单显示在标准仪表板的右侧，Netdata为每个部分生成一个菜单，菜单链接到它们所关联的部分。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091853647-8a8daaf5-edd2-4864-aa2c-05f7987dca3c.png#align=left&display=inline&height=823&name=menu.png&originHeight=823&originWidth=218&size=29721&status=done&style=none&width=218" alt="menu.png"></p><p><a name="8SCAR"></a></p><h3 id="节点菜单"><a href="#节点菜单" class="headerlink" title="节点菜单"></a>节点菜单</h3><p>节点菜单出现在标准仪表板的左上角，并标有Netdata正在监视的系统的主机名。<br />单击它会显示一个下拉菜单，其中包含您可能已通过Netdata注册表连接的所有节点。<br />默认情况下，“我的节点”标题下没有任何内容，但是您可以尝试使用任何演示Netdata节点来查看节点菜单的工作方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091944663-e505e9ef-b2fc-4fa7-bf7e-87dabde524f7.png#align=left&display=inline&height=527&name=nodemenu.png&originHeight=527&originWidth=498&size=53129&status=done&style=none&width=498" alt="nodemenu.png"></p><p>通过Netdata Cloud或专用注册表添加节点后，您将看到它们出现在“我的节点”标题下。</p><p><a name="RA1Ep"></a></p><h2 id="自定义仪表板"><a href="#自定义仪表板" class="headerlink" title="自定义仪表板"></a>自定义仪表板</h2><p>Netdata将有关各个图表的信息存储在/netdata/web/dashboard_info.js文件中。<br />例如，以下是dashboard_info.js如何定义“系统概述”部分的方式。</p><pre class=" language-shell"><code class="language-shell">netdataDashboard.menu = {  'system': {    title: 'System Overview',    icon: '<i class="fas fa-bookmark"></i>',    info: 'Overview of the key system metrics.'  },</code></pre><p>注意，不能直接更改dashboard_info.js，而是应另外新建一个文件，Netdata已经提供了一个示例文件：dashboard_info_custom_example.js</p><pre class=" language-shell"><code class="language-shell">cd /netdata/web/sudo cp dashboard_info_custom_example.js your_dashboard_info_file.js</code></pre><p>自定义文件编写完后，在/netdata/web的目录下使用新建自定义文件的名称即可。</p><pre class=" language-shell"><code class="language-shell">[web] custom dashboard_info.js = your_dashboard_info_file.js</code></pre><p><a name="T1J1H"></a></p><h2 id="使用Netdata-Cloud监视多个系统"><a href="#使用Netdata-Cloud监视多个系统" class="headerlink" title="使用Netdata Cloud监视多个系统"></a>使用Netdata Cloud监视多个系统</h2><p>在第一个节点的仪表板上右上角点击登录按钮，此时Netdata将会发送一封验证邮件，点击链接后，该节点将自动链接到Netdata Cloud的账户，并重定向回仪表板。<br />其他节点也按同样的操作，即可。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584331860428-276e3ea3-bfc4-4150-b9e5-186ecc0dc38b.png#align=left&display=inline&height=228&name=image.png&originHeight=456&originWidth=1903&size=112935&status=done&style=none&width=951.5" alt="image.png"></p><p><a name="MTK90"></a></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><a name="MFI0z"></a></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p><a name="Nnxqc"></a></p><h3 id="无需配置"><a href="#无需配置" class="headerlink" title="无需配置"></a>无需配置</h3><p><a name="Giiq1"></a></p><h3 id="长期指标存储"><a href="#长期指标存储" class="headerlink" title="长期指标存储"></a>长期指标存储</h3><p>使用我们的新数据库引擎，您可以存储每秒数天，数周或数月的历史指标。或者，您可以将指标归档到另一个数据库，例如MongoDB或Prometheus。</p><p><a name="bySdN"></a></p><h3 id="分布式，按系统安装"><a href="#分布式，按系统安装" class="headerlink" title="分布式，按系统安装"></a>分布式，按系统安装</h3><p>您无需将度量标准集中在一个位置，而是在每个系统上安装Netdata ，每个系统负责其度量标准。拥有分布式代理可以降低成本，并使Netdata可以在资源很少的设备（例如IoT和边缘设备）上运行，而不会影响其核心目的。</p><p><a name="jlznB"></a></p><h3 id="完善的健康监控功能"><a href="#完善的健康监控功能" class="headerlink" title="完善的健康监控功能"></a>完善的健康监控功能</h3><p>可确保您始终知道异常发生的时间</p><p><a name="HYtLj"></a></p><h3 id="高速，资源少的收集器"><a href="#高速，资源少的收集器" class="headerlink" title="高速，资源少的收集器"></a><strong>高速，资源少的收集器</strong></h3><p>每秒可以收集数千个指标，同时仅使用系统CPU资源的一小部分和少量MiB RAM。</p><p><a name="ghJbb"></a></p><h3 id="Netdata-Cloud"><a href="#Netdata-Cloud" class="headerlink" title="Netdata Cloud"></a>Netdata Cloud</h3><p>可帮助Netdata用户监视整个基础结构的运行状况和性能，无论它们是两千个（或两千个（或更多）！）系统。<br />如果使用Netdata监视多个系统，则Netdata Cloud可以提供集中监控解决方案的所有优势，同时又可以将工作负载分配给每个代理。<br />而且，更好的是，Netdata Cloud不存储系统的任何指标。它存储有关系统IP，主机名和随机创建的GUID的元数据，仅此而已。指标从系统直接流式传输到Web浏览器。<br />本质上，Web浏览器托管一个SaaS应用程序，并将Netdata Cloud的所有功能直接嵌入到仪表板中。<br />**<br><a name="mA1hH"></a></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>祥见：<a href="https://docs.netdata.cloud/zh/docs/netdata-security/" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/docs/netdata-security/</a></p><p><a name="1KwLD"></a></p><h3 id="数据安全性"><a href="#数据安全性" class="headerlink" title="数据安全性"></a>数据安全性</h3><p>Netdata连接的数据源获取的原始数据只会保留在收集的主机，暴露出去的数据是图表元数据和度量标准值。</p><p><a name="Dwlwi"></a></p><h3 id="系统安全性"><a href="#系统安全性" class="headerlink" title="系统安全性"></a>系统安全性</h3><ul><li>Netdata守护程序，在收集系统以及因应用程序的各项指标时，以普通系统用户身份运行，没有构造特殊的特权。</li><li>从Netdata插件到Netdata守护程序，是通讯单向的，原始数据的不会离开收集过程，不会被保存；</li></ul><p><a name="KlAz0"></a></p><h3 id="只读收集指标"><a href="#只读收集指标" class="headerlink" title="只读收集指标"></a>只读收集指标</h3><p>Netdata只可以读取收集的指标，但是不能进行其他操作，也不会公开敏感信息和业务数据，如内核版本、O/S版本，应用程序版本等</p><p><a name="N0MJH"></a></p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>作为一个监视系统，查看者可以看到监视器上的所有的指标信息，此时应当受到保护，否则会出现 </p><ul><li><p>根据视图内容，进行探索测试DDOS攻击的入口</p><blockquote><p>什么是DDOS攻击？<br>分布式拒绝服务。短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线</p></blockquote></li><li><p>使用Netdata本身来给服务器施加压力，尽管只具有最低的进程优先级，仍可以导致OOM</p></li></ul><p><a name="e9VtT"></a></p><h1 id="github传送门"><a href="#github传送门" class="headerlink" title="github传送门"></a><a href="https://github.com/netdata/netdata/" target="_blank" rel="noopener">github传送门</a></h1><p><a name="bmtLw"></a></p><h1 id="Netdata中文汉化版"><a href="#Netdata中文汉化版" class="headerlink" title="Netdata中文汉化版"></a><a href="https://github.com/Fhaohaizi/netdata" target="_blank" rel="noopener">Netdata中文汉化版</a></h1>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务调度平台XXL-JOB</title>
      <link href="/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/"/>
      <url>/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/</url>
      
        <content type="html"><![CDATA[<h1 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h1><p>以往系统中的周期性任务执行，一般有以下几种方式</p><ul><li>引入quartz or spring-task ，每一个任务对应编写一个执行类，配置调度规则执行</li><li>使用系统的执行器，比如centos的crontab，每一个任务对应编写一个执行类，并在crontab 配置调度规则</li></ul><p>此时，又会出现以下的问题</p><ul><li>任务出现异常，需增加报警功能</li><li>任务出现阻塞，比如上一次任务没执行完，下次任务会排队等待，以此累积</li><li>任务超时，需自己主动中断任务</li><li>单机任务调度下，系统出现异常，比如内存爆掉，磁盘空间不够用</li><li>任务失败，需hardcode 指定次数重试</li><li>在没有配日志可视化的前提下，查看日志需要去服务器上敲命令，面临rm -rf *的风险</li><li>…</li></ul><p><a name="03456e8f"></a></p><h1 id="二、什么是xxl-job"><a href="#二、什么是xxl-job" class="headerlink" title="二、什么是xxl-job"></a>二、什么是xxl-job</h1><p>XXL-JOB是一个轻量级分布式任务调度平台，支持通过 Web 页面对任务进行 CRUD 操作，支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，支持在线配置调度任务入参和在线查看调度结果。</p><p>它的特点有：</p><p>平台：</p><ul><li>调度中心式设计</li><li>解耦</li><li>用DB实现注册中心，实现轻量级部署</li><li>弹性扩、缩容</li><li>故障转移：执行器集群某台机器出现故障，能够自动切换正常的执行器</li><li>分片广播：且支持动态分片，提升任务运行效率</li><li>路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li><li>全异步化：异步调度和异步执行。</li></ul><p>任务：</p><ul><li>任务分布式执行</li><li>简单：支持通过web对任务进行crud</li><li>灵活：动态修改任务状态，自定义失败重试次数等，且即时生效</li><li>告警：任务失败，支持邮件告警</li></ul><p><a name="4a91069d"></a></p><h1 id="三、概念说明"><a href="#三、概念说明" class="headerlink" title="三、概念说明"></a>三、概念说明</h1><p><a name="0e46d8d6"></a></p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>调度任务，系统角色中的最小单元、</p><ul><li>可通过webide（GLUE模式） 或者ide（BEAN模式）自定义任务内容</li><li>支持多种路由策略和阻塞处理策略的选择</li><li>支持自定义失败重试次数和任务超时时间</li><li>支持任务失败告警</li><li>支持动态修改任务状态和各个配置策略的修改</li></ul><p><a name="f59ddb66"></a></p><h2 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h2><p>统一管理任务调度平台上的调度任务，负责触发调度执行，并提供可视化平台管理</p><p><a name="96a9b743"></a></p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>主要负责接收“调度中心”的调度并执行</p><p><a name="4e82ca40"></a></p><h1 id="四、安装启动"><a href="#四、安装启动" class="headerlink" title="四、安装启动"></a>四、安装启动</h1><p><a name="f26ef914"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job</a></p><p><a name="b6780d84"></a></p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Maven3+</li><li>JDK1.7+</li><li>MYSQL5.6+</li></ul><p><a name="1fa42afe"></a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a name="XzoRW"></a></p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>sql脚本在源码内，用navicat工具导入即可</p><pre class=" language-go"><code class="language-go">doc<span class="token operator">/</span>db<span class="token operator">/</span>tables_xxl_job<span class="token punctuation">.</span>sql</code></pre><p><a name="XHMkH"></a></p><h3 id="调度数据库配置说明"><a href="#调度数据库配置说明" class="headerlink" title="调度数据库配置说明"></a>调度数据库配置说明</h3><pre class=" language-go"><code class="language-go"><span class="token operator">-</span> xxl_job_lock：任务调度锁表；<span class="token operator">-</span> xxl_job_group：执行器信息表，维护任务执行器信息；<span class="token operator">-</span> xxl_job_info：调度扩展信息表： 用于保存XXL<span class="token operator">-</span>JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；<span class="token operator">-</span> xxl_job_log：调度日志表： 用于保存XXL<span class="token operator">-</span>JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；<span class="token operator">-</span> xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；<span class="token operator">-</span> xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；<span class="token operator">-</span> xxl_job_user：系统用户表；</code></pre><p><a name="WnTWG"></a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre class=" language-go"><code class="language-go">xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin：调度中心xxl<span class="token operator">-</span>job<span class="token operator">-</span>core：公共依赖xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>spring：Spring版本，通过Spring容器管理执行器，比较通用；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>frameless：无框架版本；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>jfinal：JFinal版本，通过JFinal管理执行器；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>nutz：Nutz版本，通过Nutz管理执行器；</code></pre><p><a name="UuWM4"></a></p><h3 id="配置部署“调度中心”（xxl-job-admin）"><a href="#配置部署“调度中心”（xxl-job-admin）" class="headerlink" title="配置部署“调度中心”（xxl-job-admin）"></a>配置部署“调度中心”（xxl-job-admin）</h3><p><a name="8rQNF"></a></p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">### web</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080</span><span class="token attr-name">server.context-path</span><span class="token punctuation">=</span><span class="token attr-value">/xxl-job-admin</span><span class="token comment" spellcheck="true">### resources</span><span class="token attr-name">spring.mvc.static-path-pattern</span><span class="token punctuation">=</span><span class="token attr-value">/static/**</span><span class="token attr-name">spring.resources.static-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/static/</span><span class="token comment" spellcheck="true">### freemarker</span><span class="token attr-name">spring.freemarker.templateLoaderPath</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/templates/</span><span class="token attr-name">spring.freemarker.suffix</span><span class="token punctuation">=</span><span class="token attr-value">.ftl</span><span class="token attr-name">spring.freemarker.charset</span><span class="token punctuation">=</span><span class="token attr-value">UTF-8</span><span class="token attr-name">spring.freemarker.request-context-attribute</span><span class="token punctuation">=</span><span class="token attr-value">request</span><span class="token attr-name">spring.freemarker.settings.number_format</span><span class="token punctuation">=</span><span class="token attr-value">0.##########</span><span class="token comment" spellcheck="true">### mybatis</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/mybatis-mapper/*Mapper.xml</span><span class="token comment" spellcheck="true">### xxl-job, datasource</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">123456</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.tomcat.jdbc.pool.DataSource</span><span class="token attr-name">spring.datasource.tomcat.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">10000</span><span class="token attr-name">spring.datasource.tomcat.max-active</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">spring.datasource.tomcat.test-on-borrow</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.datasource.tomcat.validation-query</span><span class="token punctuation">=</span><span class="token attr-value">SELECT 1</span><span class="token attr-name">spring.datasource.tomcat.validation-interval</span><span class="token punctuation">=</span><span class="token attr-value">30000</span><span class="token comment" spellcheck="true">### xxl-job email</span><span class="token attr-name">spring.mail.host</span><span class="token punctuation">=</span><span class="token attr-value">smtp.qq.com</span><span class="token attr-name">spring.mail.port</span><span class="token punctuation">=</span><span class="token attr-value">25</span><span class="token attr-name">spring.mail.username</span><span class="token punctuation">=</span><span class="token attr-value">xxx@qq.com</span><span class="token attr-name">spring.mail.password</span><span class="token punctuation">=</span><span class="token attr-value">xxx</span><span class="token attr-name">spring.mail.properties.mail.smtp.auth</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.enable</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.required</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.socketFactory.class</span><span class="token punctuation">=</span><span class="token attr-value">javax.net.ssl.SSLSocketFactory</span><span class="token comment" spellcheck="true">### xxl-job, access token</span><span class="token attr-name">xxl.job.accessToken</span><span class="token punctuation">=</span><span class="token comment" spellcheck="true">### xxl-job, i18n (default empty as chinese, "en" as english)</span><span class="token attr-name">xxl.job.i18n</span><span class="token punctuation">=</span></code></pre><p><a name="z5SBq"></a></p><h4 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h4><p><a name="KcwZA"></a></p><h5 id="方式一：项目打包部署"><a href="#方式一：项目打包部署" class="headerlink" title="方式一：项目打包部署"></a>方式一：项目打包部署</h5><ul><li>打包xxl-job-admin</li><li>调度中心访问地址：<a href="http://localhost:8080/xxl-job-admin" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin</a> (该地址执行器将会使用到，作为回调地址)<br><br />默认登录账号：admin    默认登录密码：123456</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786646307-a2fc191b-157e-4652-bd27-4a04bb881c71.jpeg#align=left&display=inline&height=689&name=center.jpg&originHeight=689&originWidth=1274&size=49771&status=done&style=none&width=1274" alt="center.jpg"></p><p><a name="d4afdc1b"></a></p><h5 id="方式二：Docker镜像搭建"><a href="#方式二：Docker镜像搭建" class="headerlink" title="方式二：Docker镜像搭建"></a>方式二：Docker镜像搭建</h5><ul><li><p>下载镜像</p><pre class=" language-shell"><code class="language-shell">docker pull xuxueli/xxl-job-admin</code></pre></li><li><p>创建容器</p><blockquote><p>由于官方镜像的配置文件（application.properties）是默认的，这里需要通过 “PARAMS” 指定，参数格式 RAMS=”–key=value  –key2=value2” 去修改；</p></blockquote></li></ul><pre class=" language-shell"><code class="language-shell">docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&characterEncoding=UTF-8" -p 8082:8080 -v /tmp:/data/applogs --name xxl-job-admin  -d xuxueli/xxl-job-admin</code></pre><ul><li>运行<pre class=" language-shell"><code class="language-shell">mvn clean packagedocker build -t xuxueli/xxl-job-admin ./xxl-job-admindocker run --name xxl-job-admin -p 8080:8080 -d xuxueli/xxl-job-admin</code></pre><a name="f68af6d7"></a><h5 id=""><a href="#" class="headerlink" title=""></a></h5><a name="hg5x5"></a><h5 id="调度中心集群（可选-）"><a href="#调度中心集群（可选-）" class="headerlink" title="调度中心集群（可选 ）"></a>调度中心集群（可选 ）</h5></li></ul><p>调度中心支持集群部署，提升调度系统容灾和可用性。<br />调度中心集群部署时，几点要求和建议：</p><ul><li>DB配置保持一致；</li><li>登陆账号配置保持一致；</li><li>集群机器时钟保持一致（单机集群忽视）；</li><li>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。</li></ul><p><a name="vz4xh"></a></p><h3 id="配置部署“执行器项目”（xxl-job-executor-sample）"><a href="#配置部署“执行器项目”（xxl-job-executor-sample）" class="headerlink" title="配置部署“执行器项目”（xxl-job-executor-sample）"></a>配置部署“执行器项目”（xxl-job-executor-sample）</h3><ul><li>执行器配置application.properties</li></ul><pre class=" language-go"><code class="language-go"># web portserver<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">8081</span># log configlogging<span class="token punctuation">.</span>config<span class="token operator">=</span>classpath<span class="token punctuation">:</span>logback<span class="token punctuation">.</span>xml### 调度中心部署跟地址 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行<span class="token string">"执行器心跳注册"</span>和<span class="token string">"任务结果回调"</span>；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>addresses<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin### 执行器AppName <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：执行器心跳注册分组依据；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>appname<span class="token operator">=</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample### 执行器IP <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 <span class="token string">"执行器注册"</span> 和 <span class="token string">"调度中心请求并触发任务"</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>ip<span class="token operator">=</span>### 执行器端口号 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：小于等于<span class="token number">0</span>则自动获取；默认端口为<span class="token number">9999</span>，单机部署多个执行器时，注意要配置不同执行器端口xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">9999</span>### 执行器通讯TOKEN <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：非空时启用xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>accessToken<span class="token operator">=</span>### 执行器运行日志文件存储磁盘路径 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：需要对该路径拥有读写权限；为空则使用默认路径xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logpath<span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>applogs<span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">/</span>jobhandler### 执行器日志保存天数 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：值大于<span class="token number">3</span>时生效，启用执行器Log文件定期清理功能，否则不生效xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logretentiondays<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span></code></pre><ul><li>部署项目<br />官方提供了多种执行器的示例项目，这里默认使用springboot。<br>执行器集群（可选）<br /><br><br />执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。<br><br />执行器集群部署时，几点要求和建议：<ul><li>执行器回调地址（xxl.job.admin.addresses）需要保持一致；执行器根据该配置进行执行器自动注册等操作。</li><li>同一个执行器集群内AppName（xxl.job.executor.appname）需要保持一致；调度中心根据该配置动态发现不同集群的在线执行器列表。</li></ul></li></ul><p><a name="26cc147d"></a></p><h1 id="五、开发"><a href="#五、开发" class="headerlink" title="五、开发"></a>五、开发</h1><blockquote><p>任务运行模式主要有Bean模式和Gule模式（理解为脚本）</p></blockquote><p><a name="048b136f"></a></p><h2 id="BEAN模式"><a href="#BEAN模式" class="headerlink" title="BEAN模式"></a>BEAN模式</h2><blockquote><p>在该模式下，任务的具体实现逻辑是 以JobHandler的形式存在于“执行器项目”中。</p></blockquote><ul><li>步骤一：新建执行器项目</li></ul><p>这里只要copy 项目<code>xxl-job-executor-sample-springboot</code> 即可</p><ul><li>步骤二：修改执行器appname</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> <span class="token string">"classpath:logback.xml"</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">xxl</span><span class="token punctuation">:</span>  <span class="token key atrule">job</span><span class="token punctuation">:</span>    <span class="token key atrule">accessToken</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">addresses</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8080/xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>admin    <span class="token key atrule">executor</span><span class="token punctuation">:</span>      <span class="token key atrule">appname</span><span class="token punctuation">:</span> xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>executor<span class="token punctuation">-</span>test      <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">''</span>      <span class="token key atrule">logpath</span><span class="token punctuation">:</span> /data/applogs/xxl<span class="token punctuation">-</span>job/jobhandler      <span class="token key atrule">logretentiondays</span><span class="token punctuation">:</span> <span class="token number">-1</span>      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9999</span></code></pre><ul><li>步骤三：新建一个任务Handler：TestJobHandler</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>ReturnT<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>IJobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>JobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>log<span class="token punctuation">.</span>XxlJobLogger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p>Title:lyy-modular-saas-api&lt;/p> * &lt;p>Desc: 运行模式为Bean模式&lt;/p> * 开发步骤： * 1、继承"IJobHandler"：“com.xxl.job.core.handler.IJobHandler”； * 2、注册到Spring容器：添加“@Component”注解，被Spring容器扫描为Bean实例； * 3、注册到执行器工厂：添加“@JobHandler(value="自定义jobhandler名称")”注解，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 4、执行日志：需要通过 "XxlJobLogger.log" 打印执行日志； * @author Jerry * @version 1.0 * @since 2019/8/8 */</span><span class="token annotation punctuation">@JobHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"testJobHandler"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJobHandler</span> <span class="token keyword">extends</span> <span class="token class-name">IJobHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execute</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# start to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"beat at:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# end to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>步骤四：执行器管理，新增执行器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786788896-d5796647-8a22-4b58-95dd-10dff177e364.jpeg#align=left&display=inline&height=472&name=actuator.jpg&originHeight=472&originWidth=601&size=11783&status=done&style=none&width=601" alt="actuator.jpg"></p><ul><li>步骤五：任务管理，新建调度任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786798752-af536e8e-0f70-4e85-a1a2-d9bdc2218c98.jpeg#align=left&display=inline&height=533&name=task.jpg&originHeight=533&originWidth=901&size=23727&status=done&style=none&width=901" alt="task.jpg"></p><ul><li>步骤六：执行任务，并查看日志</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786809410-16cd6399-94c2-44b3-8f79-41e91ddff21d.jpeg#align=left&display=inline&height=414&name=console_log.jpg&originHeight=414&originWidth=891&size=36655&status=done&style=none&width=891" alt="console_log.jpg"></p><p>可以看到，这里成功执行了先前自定义的调度任务，并输出了log，结合代码分析，任务执行的log通过<code>XxlJobLogger.log</code>记录并写到日志表内，调度中心后台读取日志表得到详细的log</p><p><a name="958f5368"></a></p><h2 id="GLUE模式"><a href="#GLUE模式" class="headerlink" title="GLUE模式"></a>GLUE模式</h2><blockquote><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定JobHandler</p></blockquote><p>拿GULE模式（JAVA）来解释，每一个GLUE模式的代码，在“执行器”接受到调度请求时，会通过Groovy类加载器加载出代码，并实例化成Java对象，同时注入此代码中声明的Spring服务（这里要确保代码中所引用的类或服务在“执行器项目中存在”），接着调用该对象的execute方法，执行具体的任务逻辑。</p><ul><li>步骤一：任务管理，新建调度任务<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786826556-7207d017-d8a7-4837-aabd-48381a7d4824.jpeg#align=left&display=inline&height=533&name=task_glue.jpg&originHeight=533&originWidth=902&size=24651&status=done&style=none&width=902" alt="task_glue.jpg"></p><ul><li>步骤二：点击操作，选择GLUE IDE，进入Web Ide界面<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786835674-f696b25f-cb86-48ff-ae46-f60eb95a042e.jpeg#align=left&display=inline&height=408&name=web_ide.jpg&originHeight=408&originWidth=694&size=13347&status=done&style=none&width=694" alt="web_ide.jpg"></p><p><a name="21449655"></a></p><h2 id="任务执行失败-邮件告警"><a href="#任务执行失败-邮件告警" class="headerlink" title="任务执行失败-邮件告警"></a>任务执行失败-邮件告警</h2><ul><li>步骤一：在之前 <code>3.3.1 更改配置</code>中，有相关邮件报警的发送方配置，配置即可</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">### 这里是用腾讯企业邮箱测试</span>spring.mail.host=smtp.exmail.qq.comspring.mail.port=465spring.mail.username=error@qq.comspring.mail.password=123456</code></pre><ul><li>步骤二：在 <code>任务管理，新建调度任务</code>中，配置接收告警邮件的邮箱，多个用“,”隔开即可</li></ul><p>相关的处理逻辑在调度中心的<code>JobFailMonitorHelper</code>类中</p><p><a name="6911d0e4"></a></p><h2 id="分片广播-amp-动态分片"><a href="#分片广播-amp-动态分片" class="headerlink" title="分片广播&amp;动态分片"></a>分片广播&amp;动态分片</h2><blockquote><p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。<br>使用场景：</p><ol><li>分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；</li><li>广播任务场景：广播执行器机器运行shell脚本、广播集群节点进行缓存更新等</li></ol></blockquote><p><a name="z07er"></a></p><h3 id="步骤一：执行器集群部署，暂设置为2个节点"><a href="#步骤一：执行器集群部署，暂设置为2个节点" class="headerlink" title="步骤一：执行器集群部署，暂设置为2个节点"></a>步骤一：执行器集群部署，暂设置为2个节点</h3><p>执行器管理可以看到：一个APP有两个机器地址</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786903400-2e72b744-8d2d-42d5-bc4f-1bea33e059f3.jpeg#align=left&display=inline&height=337&name=actuators.jpg&originHeight=337&originWidth=1528&size=21343&status=done&style=none&width=1528" alt="actuators.jpg"></p><p><a name="A7kJB"></a></p><h3 id="步骤二：新增or更新任务，更改路由策略为分片广播"><a href="#步骤二：新增or更新任务，更改路由策略为分片广播" class="headerlink" title="步骤二：新增or更新任务，更改路由策略为分片广播"></a>步骤二：新增or更新任务，更改路由策略为分片广播</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786916544-715046ad-6150-40bb-a59b-01918374aa3c.jpeg#align=left&display=inline&height=531&name=broadcast.jpg&originHeight=531&originWidth=898&size=23259&status=done&style=none&width=898" alt="broadcast.jpg"></p><p><a name="02TFX"></a></p><h3 id="步骤三：编写业务代码"><a href="#步骤三：编写业务代码" class="headerlink" title="步骤三：编写业务代码"></a>步骤三：编写业务代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分片参数</span>ShardingUtil<span class="token punctuation">.</span>ShardingVO shardingVO <span class="token operator">=</span> ShardingUtil<span class="token punctuation">.</span><span class="token function">getShardingVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"分片参数1：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 业务逻辑</span><span class="token comment" spellcheck="true">// ...</span></code></pre><p><a name="wybCl"></a></p><h3 id="步骤四：执行任务，查看运行日志"><a href="#步骤四：执行任务，查看运行日志" class="headerlink" title="步骤四：执行任务，查看运行日志"></a>步骤四：执行任务，查看运行日志</h3><pre class=" language-verilog"><code class="language-verilog"># 节点<span class="token number">1</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 分片参数：当前分片序号 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 命中分片开始处理<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 忽略# 节点<span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 分片参数<span class="token number">1</span>：当前分片序号 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 忽略<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 命中分片开始处理</code></pre><p>可以看到一个集群的两个节点都收到了分片调度请求，业务逻辑即可针对对应的分片序号进行业务逻辑分片处理！</p><p><a name="6346b6d9"></a></p><h1 id="六、架构设计"><a href="#六、架构设计" class="headerlink" title="六、架构设计"></a>六、架构设计</h1><p><a name="41db83b4"></a></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>实现 调度+任务 两者解耦</li><li>调度行为在调度中心（admin后台），负责发起调度请求</li><li>任务抽象化为一个个JobHandler，交由“<code>执行器</code>”统一管理，“<code>执行器</code>”负责接收调度请求并找到对应的JobHandler，执行具体的业务逻辑（execute）</li></ul><p><a name="ff23e032"></a></p><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><ul><li><strong>调度模块（调度中心）</strong>： 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块； 支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>： 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效； 接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p><a name="65aa05f0"></a></p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582786987822-69688faa-9f2b-4d55-aea8-012599876e51.png#align=left&display=inline&height=822&name=architecture.png&originHeight=822&originWidth=1562&size=376301&status=done&style=none&width=1562" alt="architecture.png"></p><p><a name="ec0ef4cd"></a></p><h3 id="架构特性"><a href="#架构特性" class="headerlink" title="架构特性"></a>架构特性</h3><ul><li>解耦<br><br /><code>调度中心</code> 通过类rpc的调用模式，调用<code>执行器</code>暴露的远程服务；<br><br />详见日志远程调用源码：</li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>invoker<span class="token punctuation">.</span>reference<span class="token punctuation">.</span>XxlRpcReferenceBean#getObject</code></pre><ul><li><p>线程池<br><br />调度采用线程池方式实现，避免用单线程出现阻塞而导致任务调度延迟；</p></li><li><p>并行调度<br><br />调度模块采用并行机制，而调度传递到<code>执行器</code>则是串行执行</p></li><li><p>多种路由策略</p></li><li><p>过期处理策略<br><br />过期5s内立即触发一次，过期超5s则忽略</p></li><li><p>日志回调服务<br><br /><code>“执行器”</code>在收到调度请求并执行任务后，会将任务的执行结果回调通知给调度中心，调度中心再对应更新日志表。<br><br />执行器触发回调线程处理源码：</p></li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>TriggerCallbackThread#doCallback</code></pre><ul><li><p>调度中心接受回调源码：</p><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>AdminBizImpl#<span class="token function">callback</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>HandleCallbackParam<span class="token punctuation">)</span></code></pre></li><li><p>任务集群<br><br />执行器如若集群部署，调度中心将会感知到在线的所有执行器</p></li><li><p>全异步化</p><ul><li>异步调度：调度中心每次任务触发时仅发送一次调度请求，该调度请求首先推送“异步调度队列”，然后异步推送给远程执行器</li><li>异步执行：执行器会将请求存入“异步执行队列”并且立即响应调度中心，异步运行。</li></ul></li><li><p>轻量级设计<br><br />XXL-JOB调度中心中每个JOB逻辑非常 “轻”，在全异步化的基础上，单个JOB一次运行平均耗时基本在 “10ms” 之内（基本为一次请求的网络开销）；因此，可以保证使用有限的线程支撑大量的JOB并发运行</p></li></ul><p><a name="ab715697"></a></p><h3 id="通讯流程分析"><a href="#通讯流程分析" class="headerlink" title="通讯流程分析"></a>通讯流程分析</h3><ul><li><code>调度中心</code>向<code>执行器</code>发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌Server，默认端口9999;</li><li><code>执行器</code>执行任务逻辑</li><li><code>执行器</code>http回调<code>调度中心</code>调度结果: <code>调度中心</code>中接收回调的服务，是针对<code>执行器</code>开放一套API服务;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> XXL-JOB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（二）初识Netty</title>
      <link href="/2020/02/21/netty-wa-jue-ji-er-chu-shi-netty/"/>
      <url>/2020/02/21/netty-wa-jue-ji-er-chu-shi-netty/</url>
      
        <content type="html"><![CDATA[<p>上一遍大致讲了Netty的基础：JAVA NIO，和最早的BIO</p><p>这一回开始着手聊一下Netty的特性及实现流程</p><p>Netty 是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器<br />和客户端。</p><p><a name="79d24e74"></a></p><h2 id="Netty的特性"><a href="#Netty的特性" class="headerlink" title="Netty的特性"></a>Netty的特性</h2><p>以下内容摘自《Netty 实战》</p><table><thead><tr><th>分类</th><th>Netty 的特性</th></tr></thead><tbody><tr><td>设计</td><td>统一的 API，支持多种传输类型，阻塞的和非阻塞的；简单而强大的线程模型；真正的无连接数据报套接字支持；链接逻辑组件以支持复用</td></tr><tr><td>易于使用</td><td>-</td></tr><tr><td>性能</td><td>拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟；得益于池化和复用，拥有更低的资源消耗；最少的内存复制</td></tr><tr><td>健壮性</td><td>不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError；消除在高速网络中 NIO 应用程序常见的不公平读/写比率</td></tr><tr><td>安全性</td><td>完整的 SSL/TLS 以及 StartTLS 支持；可用于受限环境下，如 Applet 和 OSGI</td></tr></tbody></table><p><a name="fed85108"></a></p><h2 id="Netty服务端实现流程"><a href="#Netty服务端实现流程" class="headerlink" title="Netty服务端实现流程"></a>Netty服务端实现流程</h2><p><a name="7ea27cc2"></a></p><h3 id="实现自定义的handler"><a href="#实现自定义的handler" class="headerlink" title="实现自定义的handler"></a>实现自定义的handler</h3><p>每个服务都会有自己内部的处理逻辑，Netty内置了handler处理I/O事件。</p><p>我们先尝试实现一个handler，逻辑是接受入站数据并返回</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>ByteBuf<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>Unpooled<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelFutureListener<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelHandlerContext<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelInboundHandlerAdapter<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelHandler<span class="token punctuation">.</span>Sharable<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>util<span class="token punctuation">.</span>CharsetUtil<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpChannelInboundHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ByteBuf in <span class="token operator">=</span> <span class="token punctuation">(</span>ByteBuf<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Server received:"</span> <span class="token operator">+</span> in<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CharsetUtil<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将消息写入缓冲区，并调用flush强行输出到远端节点</span>        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 出现异常则关闭连接</span>        cause<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，我们的处理器HttpChannelInboundHandler继承了ChannelInboundHandlerAdapter，而ChannelInboundHandlerAdapter是Netty 提供的ChannelInboundHandler的实现类之一。所以我们可以通过覆盖它们的方法来实现自己的业务逻辑处理。关于Handler这块具体的内容我们后面再细讲</p><p><a name="channelRead"></a></p><h4 id="channelRead"><a href="#channelRead" class="headerlink" title="channelRead"></a>channelRead</h4><pre><code>客户端发送数据包过来时，在收到该数据包时，该方法会被调用。当前我们定义的接收数据类型为ByteBufChannelHandlerContext对象提供了许多操作。我们这里是将接收到的数据写入到缓冲区，再调用flush()将其冲刷到通道</code></pre><p><a name="exceptionCaught"></a></p><h4 id="exceptionCaught"><a href="#exceptionCaught" class="headerlink" title="exceptionCaught"></a>exceptionCaught</h4><pre><code>当服务出现异常时，会调用该方法。通常我们会在这里记录异常信息，并关闭对应的通道。</code></pre><p><a name="33d81c9d"></a></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>    EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1.</span>        bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2.</span>            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3.</span>            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 4.</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel channel<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 5.</span>                    <span class="token keyword">new</span> <span class="token class-name">HttpChannelInboundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6.</span>            <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 7</span>        ChannelFuture future <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 8.</span>        <span class="token comment" spellcheck="true">//            future.channel().closeFuture(); // 9.</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        boss<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        worker<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="ServerBootstrap"></a></p><h4 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h4><p>启动引导类，Netty 需要实例化一个ServerBootstrap来启动服务并配置相关参数</p><p><a name="f4ed49db"></a></p><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><p>分配组，服务端的启动服务需要两个组协同工作来处理IO，一个boss组用于accept（接受）连接，一个worker组用于handle（处理）连接</p><p><a name="27c8bb5b"></a></p><h4 id="channel"><a href="#channel" class="headerlink" title="channel()"></a>channel()</h4><p>这里我们使用NioServerSocketChannel的实例化对象来设置ServerBootstrap实例</p><p><a name="b5484671"></a></p><h4 id="childHandler"><a href="#childHandler" class="headerlink" title="childHandler()"></a>childHandler()</h4><p>添加处理器</p><p><a name="7cc2732b"></a></p><h4 id="initChannel"><a href="#initChannel" class="headerlink" title="initChannel()"></a>initChannel()</h4><p>对channel进行初始化配置，而这里我们没有自定义ChannelInitializer的实现类来添加具体的配置项到channel的pipeline上。因为我仅添加了一个处理器，没有太复杂的逻辑。这个处理器用于处理channel上的事件</p><p><a name="44e83e30"></a></p><h4 id="option"><a href="#option" class="headerlink" title="option()"></a>option()</h4><p>指定要应用到新创建的 ServerChannel 的 ChannelConfig 的 ChannelOption。这些选项将会通过 bind()方法设置到 Channel。在 bind()方法被调用之后，设置或者改变 ChannelOption 都不会有任何的效果</p><p>SO_BAKCLOG:设置排队的连接数。</p><p><a name="69be5557"></a></p><h4 id="childOption"><a href="#childOption" class="headerlink" title="childOption()"></a>childOption()</h4><p>指定当子 Channel 被接受时，应用到子 Channel 的 ChannelConfig 的ChannelOption。所支持的 ChannelOption 取决于所使用的 Channel 的类型。</p><p><a name="67110355"></a></p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>绑定端口并返回一个ChannelFuture，将在绑定完成后收到回调通知</p><p><a name="9ebc9139"></a></p><h4 id="closeFuture"><a href="#closeFuture" class="headerlink" title="closeFuture()"></a>closeFuture()</h4><p>优雅地关停服务，按需用。</p><p>下一篇会开始分析Netty的核心API</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（一）初识JAVA_NIO</title>
      <link href="/2020/02/21/netty-wa-jue-ji-yi-chu-shi-java-nio/"/>
      <url>/2020/02/21/netty-wa-jue-ji-yi-chu-shi-java-nio/</url>
      
        <content type="html"><![CDATA[<p>推荐阅读：<a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">美团技术团队对NIO的浅析</a></p><p>众所周知，Netty是基于JAVA NIO 而封装的网络通讯框架。</p><p>官网介绍：Netty is <em>an asynchronous event-driven network application framework</em><br />for rapid development of maintainable high performance protocol servers &amp; clients.</p><p>本人打着想重新梳理一遍Netty的知识体系的心态，来写Netty挖掘机这一系列的文章。我相信一步步深入到源码后，会有收获的！</p><p><a name="AntXF"></a></p><h1 id="什么是阻塞和非阻塞、同步和异步IO"><a href="#什么是阻塞和非阻塞、同步和异步IO" class="headerlink" title="什么是阻塞和非阻塞、同步和异步IO"></a>什么是阻塞和非阻塞、同步和异步IO</h1><p>一个IO操作分为先发起IO请求、再进行实际的IO操作</p><ul><li><p>阻塞、非阻塞IO：发起IO请求时线程是否会阻塞直到完成</p></li><li><p>同步、异步IO：真正IO实际读写操作 过程 是否会阻塞请求线程</p><pre><code>             同步需要等待（线程阻塞时）或轮询（线程非阻塞时）内核完成IO操作             异步是系统等内核完成IO操作后（被调用者）再主动通知程序（通知 或者 回调）</code></pre></li><li><p>同步阻塞：发起一个IO请求时，线程阻塞，直到等待实际的内核IO读写操作完成才放开线程</p></li><li><p>同步非阻塞：发起一个IO请求时，线程非阻塞，但是线程需要去定时轮询内核IO操作是否完成</p></li><li><p>异步非阻塞：发起一个IO请求时，线程非阻塞，不等待内核IO操作完成，也不用进程花费CPU资源去轮询，而是系统（被调用者）主动通知程序（调用者）</p></li></ul><blockquote><p>为什么说NIO是同步非阻塞？<br>NIO它的实际内核I/O操作（读read、写write、接受accept）会阻塞请求线程，所以是同步的；但是它的发起请求这一步，不会导致线程阻塞，而会通过多路复用器select进行轮询获取实际内核I/O操作完成的信息</p></blockquote><p><a name="P0Ae1"></a></p><h1 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO?"></a>什么是BIO?</h1><blockquote><p>即面向流的同步阻塞IO， Client、Server基于输入流、输出流进行通信</p></blockquote><p><a name="YUPa0"></a></p><h2 id="单线程BIO"><a href="#单线程BIO" class="headerlink" title="单线程BIO"></a>单线程BIO</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277115922-ff1a9c62-543b-4f7d-8352-0708c7baa785.png#align=left&display=inline&height=332&name=bio_single.png&originHeight=332&originWidth=630&size=17138&status=done&style=none&width=630" alt="bio_single.png"></p><p><a name="SbTeF"></a></p><h2 id="多线程版BIO"><a href="#多线程版BIO" class="headerlink" title="多线程版BIO"></a>多线程版BIO</h2><p>典型的C/S模型。它是由Server开启accept线程进行监听Client的连接请求，一个请求对应创建一个新的线程进行处理，并通过输出流返回给客户端。</p><pre><code>优点：支持同一时间内多个客户端并行请求服务端缺点：不具备弹性伸缩能力。当面对海量连接时，意味着线程数膨胀，与其同时造成的是系统性能的急剧下降（因为线程也是宝贵的系统资源），进而会发生句柄溢出、线程堆栈溢出，甚至造成服务器宕机。    ![bio1.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582277133782-0e1c8f64-5f58-44e7-98a2-f73031c00d7c.png#align=left&amp;display=inline&amp;height=271&amp;name=bio1.png&amp;originHeight=271&amp;originWidth=635&amp;size=32253&amp;status=done&amp;style=none&amp;width=635)    代码示例：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    ServerSocket server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"# Server start，the port:"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"### start listener client connect..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Socket client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"### now accept one client connect, start handler..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">handler</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket client<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        InputStream stream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="6NJgt"></a></p><h2 id="线程池版BIO"><a href="#线程池版BIO" class="headerlink" title="线程池版BIO"></a>线程池版BIO</h2><p>在多线程的基础上，增加了线程池的概念，可以避免线程频繁创建。<br />线程池本身就是一个天然的漏斗，可以在特殊情况下解决一些系统无法处理的问题<br />然而还是逃不开一个事实：把线程当做命根子。。。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277645931-6a7e0c01-182a-494d-86ba-2de6d2cf7dd9.png#align=left&display=inline&height=375&name=bio_pool.png&originHeight=375&originWidth=871&size=30321&status=done&style=none&width=871" alt="bio_pool.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建容量为100的线程池</span>    ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerSocket server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"# Server start，the port:"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 循环等待新连接</span>            Socket client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">handler</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket client<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        InputStream stream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="q7BRH"></a></p><h1 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h1><blockquote><p>即面向缓冲区的同步非阻塞IO。<br>从jdk1.4开始，增加了与原标准IO API 不同使用方式的NIO(NO BLOCK IO)<br>jdk1.5_update10 版本使用 epoll 替代了传统的 select/poll，极大的提升了 NIO 通信的性能。</p></blockquote><p><a name="Reo4X"></a></p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><pre><code>在BIO中使用字节流or字符流来传输数据；而在NIO中使用通道和缓冲区来传输数据Channel将数据读入Buffer， Buffer将数据写入Channel&lt;br /&gt;![channelbuffer.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582277715014-6ffaf053-475c-4489-b408-66d2f0077609.png#align=left&amp;display=inline&amp;height=214&amp;name=channelbuffer.png&amp;originHeight=214&amp;originWidth=296&amp;size=6493&amp;status=done&amp;style=none&amp;width=296)    </code></pre><p><a name="xJwy7"></a></p><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p><a name="W0vhy"></a></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote><p>即数据通道，不同于单向io（读和写需要不同的通道），这里的通道支持双向，即可从通道内读写数据。<br>实际Channel与Buffer结合使用：从通道读数据到缓冲区，缓冲区向通道写入数据</p></blockquote><p>JAVA NIO Channel 主要有以下几种<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278275822-0e90293f-ce44-4b56-be38-ba163a72452f.jpeg#align=left&display=inline&height=305&name=channel.jpg&originHeight=305&originWidth=940&size=15719&status=done&style=none&width=940" alt="channel.jpg"></p><ul><li>FileChannel 读写文件时用的通道（仅它无法设置非阻塞模式，默认阻塞）</li><li>SocketChannel 客户端传输TCP连接数据时的通道，与JAVA IO中的Socket对应</li><li>DatagramChannel 传输UDP连接数据时的通道，与Java IO中的DatagramSocket对应</li><li>ServerSocketChannel 服务端监听进入的TCP连接的通道，与Java IO中的ServerSocket对应</li></ul><p>以下是使用FileChannel 读取文件的Demo</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer json <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        json <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> br <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读入缓冲区</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>br <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 缓冲区读取就绪</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                json<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            buf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            br <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="5TwOz"></a></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>即缓冲区。本质上是一块 可以从中读取数据，或写入数据 的内存，在JAVA NIO中提供了具体的方法来访问内存中的数据</p></blockquote><p>Channel将数据读入Buffer， Buffer将数据写入Channel<br><br /></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277902479-3a118472-9512-406d-82b6-0a39e79df07c.png#align=left&display=inline&height=214&name=channelbuffer.png&originHeight=214&originWidth=296&size=6493&status=done&style=none&width=296" alt="channelbuffer.png"></p><p>Channel读入Buffer：</p><pre class=" language-java"><code class="language-java">FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bread <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Buffer写入Channel:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要有写入权限，否则会抛异常</span><span class="token comment" spellcheck="true">// RandomAccessFile fc = new RandomAccessFile("test.json", "rw")</span>FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bread <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="usZY8"></a></p><h4 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h4><ul><li><p>Capacity（容量）</p></li><li><p>Limit（限制）</p></li><li><p>Position（位置）<br><a name="KmpOl"></a></p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4></li><li><p>allocate(int capacity) 分配指定容量（字节）的缓冲区.</p></li><li><p>allocateDirect(int capacity) 分配指定容量的直接缓冲区</p></li><li><p>flip() 翻转缓冲区，使得limit变为当前位置position，position变为0，常用于Channel读入Buffer或Buffer写入Channel操作后</p></li><li><p>rewind() 倒带缓冲区，将当前位置position设置为0，limit不变，常用于通道读入缓冲区后，要读取缓冲区的数据</p></li></ul><p>举个栗子</p><pre class=" language-java"><code class="language-java">StringBuffer json <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    json <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> size <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 倒带buffer，将position设置为0</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 遍历buffer 的数据</span>        json<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>clear() 清除缓冲区，将缓冲区置于写入模式</li><li>compact() 压缩缓冲区，将缓冲区未读部分复制到缓冲区索引为0的区域，且下一次读入缓冲区时从未读部分的索引+1开始</li></ul><p><a name="k65gV"></a></p><h3 id="Selector（多路复用）"><a href="#Selector（多路复用）" class="headerlink" title="Selector（多路复用）"></a>Selector（多路复用）</h3><blockquote><p>即选择器<br>在java nio中，可以通过Selector用单个线程来管理多个通道。它能够检测n个Nio通道的状态（连接就绪、接收就绪、读就绪、写就绪）<br>现代操作系统的多任务处理上，开销貌似变得越来越小，但程序上仍要控制使用线程的频率，因为线程的切换开销是很昂贵的</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278370902-80bcb3f2-759f-4d3b-ae9c-b9e99b2dc258.jpeg#align=left&display=inline&height=410&name=selector.jpg&originHeight=410&originWidth=581&size=13430&status=done&style=none&width=581" alt="selector.jpg"></p><p><a name="gGpTB"></a></p><h4 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h4><p>我们说NIO 本身是基于事件驱动思想来处理IO的。这里的事件即我们通过Selector注册对应的事件在Channel上。它的事件主要有<br />连接就绪    SelectionKey.OP_ACCEPT<br />读就绪    SelectionKey.OP_READ<br />写就绪    SelectionKey.OP_WRITE<br />以下文字是摘自美团技术团队 《Java Nio浅析》中的一段</p><blockquote><p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。<br>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。<br>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p></blockquote><p><a name="qgjQt"></a></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><a name="LKb9O"></a></p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><pre class=" language-java"><code class="language-java">Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="lTBGh"></a></p><h5 id="注册Channel"><a href="#注册Channel" class="headerlink" title="注册Channel"></a>注册Channel</h5><p>要注意的是使用的Channel必须设置非阻塞模式，否则会抛出IllegalBlockingModeException异常。<br />why？<br />翻看了javadoc 后，找到这么一句：Non-blocking mode is most useful in conjunction with selector-based multiplexing，意思是认为非阻塞模式与基于选择器的多路复用结合使用最为有用。想想当Channel是阻塞模式的话，那多路复用其实也没啥意思了…<br />以ServerSocketChannel来举栗。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 打开通道</span>ServerSocketChannel server <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 绑定端口</span>server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置阻塞模式，false:nio style</span>server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建选择器</span>selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用给定的选择器注册此通道</span>server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="BfYUo"></a></p><h5 id="轮询获取channel状态"><a href="#轮询获取channel状态" class="headerlink" title="轮询获取channel状态"></a>轮询获取channel状态</h5><p>通过调用某个select方法，获取就绪的channel。<br />int select()：获取就绪的key个数，阻塞直到获取至少一个就绪的channel<br />int select(long timeout)：获取就绪的key个数，阻塞直到时间达到指定timeout<br />int selectNow()：非阻塞获取就绪的key个数<br />通过以上可得到就绪的key个数，再调用selectedKeys获取所有的事件key，迭代获取key对应的通道即可</p><p>完整代码如下：</p><pre class=" language-java"><code class="language-java">Selector selector<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">NioServer</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">NioServer</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 打开通道</span>    ServerSocketChannel server <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 绑定端口</span>    server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置阻塞模式，false:nio style.true:oio style.</span>    server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建选择器</span>    selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用给定的选择器注册此通道</span>    server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端已启动，端口"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 阻塞，获取已就绪的key个数</span>        <span class="token keyword">int</span> wait <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wait <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取所有的事件key</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> readykeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> readykeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移除已处理数据</span>            iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 处理逻辑</span>            <span class="token function">process</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 业务逻辑方法* @param key*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>SelectionKey key<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断客户端是否已确认连接并且可交互</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ServerSocketChannel server <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SocketChannel client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置阻塞模式</span>        client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 非阻塞</span>        <span class="token comment" spellcheck="true">// 注册选择器，设置读模式，告诉client端下次进来便要读取数据</span>        client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">,</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HI!\r\n"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//            // 将此对应的channel设置为准备接受其他客户端的连接请求</span>        <span class="token comment" spellcheck="true">//            key.interestOps(SelectionKey.OP_ACCEPT);</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受连接来自 "</span><span class="token operator">+</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 处理数据读取请求</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取数据</span>        <span class="token comment" spellcheck="true">// 返回该读key 对应的channel</span>        SocketChannel client <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取channel内的数据</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 翻转缓冲区</span>                buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                content<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将channel设置为准备下一次读取</span>            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            key<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="OIs1D"></a></p><h3 id="scatter-gather-I-O-（也叫Vectored-I-O）"><a href="#scatter-gather-I-O-（也叫Vectored-I-O）" class="headerlink" title="scatter/gather I/O （也叫Vectored I/O）"></a>scatter/gather I/O （也叫Vectored I/O）</h3><p>Channel内置scatter/gather I/O功能</p><ul><li><p>scatter read：分散读入<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278733492-e46d63cb-4632-4aa5-92ac-491ae21c1481.jpeg#align=left&display=inline&height=300&name=scatter_io.jpg&originHeight=300&originWidth=360&size=9337&status=done&style=none&width=360" alt="scatter_io.jpg"></p><pre class=" language-java"><code class="language-java">Charset charset <span class="token operator">=</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ByteBuffer headBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头部缓冲区固定大小8字节</span>  <span class="token keyword">long</span> size <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer bodyBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 剩下的归为body</span>  ByteBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>headBuf<span class="token punctuation">,</span> bodyBuf<span class="token punctuation">}</span><span class="token punctuation">;</span>  fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>  headBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"head buffer data "</span> <span class="token operator">+</span> charset<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>headBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"body buffer data "</span> <span class="token operator">+</span> charset<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>bodyBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>gather write：聚集写入<br /><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582278758175-3c131229-a597-40ec-9c3f-25ab82873eb7.png#align=left&display=inline&height=301&name=gather_io.png&originHeight=301&originWidth=333&size=8981&status=done&style=none&width=333" alt="gather_io.png"><br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>RandomAccessFile accessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FileChannel fc <span class="token operator">=</span> accessFile<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ByteBuffer headBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头部缓冲区固定大小8字节</span>  headBuf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer bodyBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 剩下的归为body</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>headBuf<span class="token punctuation">,</span> bodyBuf<span class="token punctuation">}</span><span class="token punctuation">;</span>  headBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> length <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"buffer data write to channel length "</span> <span class="token operator">+</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p>分散/聚集 IO支持，针对的是通道和buffer间的交互<br />通道可以将数据分散读入多个缓冲区，多个缓冲区可以将数据聚集写入单个通道</p><table><thead><tr><th>说明</th><th>特性</th></tr></thead><tbody><tr><td>连接输出</td><td>在内存中写入非顺序放置数据的应用程序可以在一个向量I / O操作中执行此操作。</td></tr><tr><td>效率</td><td>一个向量I / O读取或写入可以替换许多普通读取或写入，从而节省系统调用所涉及的开销</td></tr><tr><td>拆分输入</td><td>需要单独处理传输数据的各个部分的情况。例如，如果消息由标题和正文组成，则可以将标题和正文保留在单独的缓冲区中。这样做可以使您更容易分别使用标题和正文</td></tr></tbody></table><p><a name="6NDuL"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a name="USMzu"></a></p><h2 id="为什么NIO会替代BIO？"><a href="#为什么NIO会替代BIO？" class="headerlink" title="为什么NIO会替代BIO？"></a>为什么NIO会替代BIO？</h2><pre><code>可以从两个角度出发</code></pre><ul><li>jdk序列化（BIO面向流传输）<ol><li>不支持跨语言工作。即当跨应用调服务时，A应用（Python），B应用（JAVA），此时A应用发送到B应用的序列化对象，B应用无法对其反序列化</li><li>就算是同语言工作。效率低下，即码流太大，无论是网络传输or持久化到磁盘，会导致额外的系统占用。实际测试远低于ByteBufffer（java.nio包）</li><li>性能差。占用CPU资源高</li></ol></li><li>线程（BIO严重依赖线程工作）<ol start="4"><li>创建和销毁的成本高。在Linux系统中，线程本质上是一个轻量级的进程，这种系统级别的开销是挺大的</li><li>吃内存</li><li>线程切换的成本高。</li><li>易造成生产&gt;消费。即外部网络请求的频率远大于线程的创建及销毁。每个TCP连接即占用一个线程，此时当遇到IO读写阻塞导致线程无法及时释放等情况时，会导致性能下降，甚至宕机。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈（一）TCP与UDP</title>
      <link href="/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/"/>
      <url>/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了更进一步了解网络层面的知识，先晒出一张网络体系结构图，加深理解。</p></blockquote><p><a name="0qP7n"></a></p><h1 id="计算机网络体系结构图"><a href="#计算机网络体系结构图" class="headerlink" title="计算机网络体系结构图"></a>计算机网络体系结构图</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582188081209-c85b7515-50d4-42c9-baf8-702116242721.png#align=left&display=inline&height=621&name=all.png&originHeight=621&originWidth=1041&size=251518&status=done&style=none&width=1041" alt="all.png"><br /><br><a name="4Wa7C"></a></p><h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h1><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接的协议。基于这种连接方式， 通信设备应在传输数据前建立连接，并应在传输数据后关闭连接</td><td>面向数据报的协议。意味着打开、维护、终止连接不会有开销。UDP对于广播和多播类型的网络传输是有效的</td></tr><tr><td>点对点通信，连接两端的socket</td><td></td></tr><tr><td>面向字节流。TCP把传输的各种数据当做无结构的字节流来用</td><td></td></tr><tr><td>可靠性。它能够保证向目标路由器的数据传输</td><td>不可靠性。不能保证向目的地传送数据</td></tr><tr><td>错误检测机制。TCP提供了广泛的错误检查机制，这是因为它提供流量控制和数据确认。</td><td>UDP只有使用校验和的基本错误检查机制</td></tr><tr><td>数据排序。数据包能够按照顺序到达接收器</td><td>没有数据排序。若有需求，则需要再应用程序层进行管理</td></tr><tr><td>速度较慢。相对UDP而言速度较慢。</td><td>快、简单、高效</td></tr><tr><td>重传机制。支持重传丢失的数据包</td><td>无重传机制</td></tr><tr><td>标头大小为20个字节</td><td>标头大小为8个字节</td></tr><tr><td>重量级</td><td>轻量级</td></tr><tr><td>用于HTTP，HTTP，FTP，SMTP和Telnet</td><td>用于DNS，DHCP，TFTP，SNMP，RIP和VoIP</td></tr></tbody></table><p>注：本文所指的Client 均为发送方，Server为接收方</p><p><a name="wXUm8"></a></p><h1 id="TCP-三次握手、四次挥手"><a href="#TCP-三次握手、四次挥手" class="headerlink" title="TCP 三次握手、四次挥手"></a>TCP 三次握手、四次挥手</h1><p><a name="N7y6K"></a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><p>建立一个TCP连接时，需要Client和Server总共发送3个包。<br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191193844-5cd363e1-ca8f-42bc-8541-c6882e2d5ffe.jpeg#align=left&display=inline&height=421&name=3-way-handshake_1.jpg&originHeight=421&originWidth=572&size=35580&status=done&style=none&width=572" alt="3-way-handshake_1.jpg"></p><ul><li>Step 1（SYN）.<br />Client 端要和Server端 建立连接，所以要发一个SYN（即同步序列号）的包，初始序号x，保存在包头的序列号（Sequence Number）字段里，指明打算连接的Service port，。<br />用于告知Server：我（Client）可能要与你开始通讯了，现在发给你一个我（Client）启动段的序列号。<br />此时Client进入<code>SYN_SEND</code>状态<br /></li><li>Step 2（SYN+ACK）.<br>Server 端 接收到数据包（通知）后<br />使用一个SYN-ACK信号位设置，来响应Client 端的请求。<br />即发送了自己的序列号（SVN），初始序号为y，和确认号（ACK，即Client发来的序列号递增1， 即x + 1）。<br />此时Server进入 <code>SYN_RCVD</code> 状态<br /></li><li>Step 3（ACK）.<br />Client接收到Server端的响应后<br />发送确认包（ACK，即Server 发来的序列号递增1， 即y + 1）来确认收到响应，此时Client 进入 <code>ESTABLISHED</code> 状态，当Server 接收到该ACK包后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p><a name="2kajc"></a></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)。<br>需要四个包的原因是是因为TCP的半关闭引起的<br>客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p></blockquote><p>下面假设Client主动发起挥手动作<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191219910-edfed3ce-3fd3-42a2-97be-5274cc01272f.jpeg#align=left&display=inline&height=450&name=4-way-connect-termination.jpg&originHeight=450&originWidth=571&size=36350&status=done&style=none&width=571" alt="4-way-connect-termination.jpg"></p><ul><li>Step 1（FIN）.<br />Client 端（发起方）要关闭TCP连接，所以要发一个FIN包，序号为x。<br />发送完毕后，此时Client进入 <code>FIN_WAIT_1</code> 状态（此时表明无数据可发送，但仍可接受数据）<br /></li><li>Step 2（ACK）.<br />当Server 端 接收到FIN包后，立即向Client发送确认包（即Client发来的FIN包的序号递增1，x + 1）。<br />发送完毕后，此时Server 进入 <code>CLOSE_WAIT</code> 状态（此时表明接收到了Client的关闭，但还没做好“思想准备“关闭连接）<br />当Client 端 接收到ACK包后，进入 <code>FIN_WAIT_2</code> 状态<br /></li><li>Step 3（FIN）.<br />Server 端 发送ACK包一段时间（这段时间它有一些关闭过程）后，开始发送FIN包，序号为y<br />发送完毕后，此时Server 进入 <code>LAST_ACK</code> 状态<br /></li><li>Step 4（ACK）.<br />当Client 端 接收到FIN包，即关闭请求后，发送一个确认包（即Server发来的FIN包的序号递增1，y + 1）<br />发送完毕后，此时Client  进入 <code>TIME_WAIT</code> 状态，目的在于在时间周期n内，允许Client 在发送的ACK包丢失的情况下重新发<br />当Server 端接收到ACK包后，连接正式关闭，此时Server进入 <code>CLOSED</code> 状态。Client资源（包括端口号、缓冲区数据）都被释放<br />当Client在时间周期n结束后，仍没收到Server 发的ACK包，则认为已正常关闭连接，此时Client 也进入 <code>CLOSE</code> 状态</li></ul><p><a name="EdGau"></a></p><h1 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h1><blockquote><p>从上面的体系图可以看到，TCP（即运输层）的报文信息最终会交付到网际层。而网际层不会提供可靠的服务。所以还是要TCP来保证可靠的传输，才能最终保证数据服务的可靠</p></blockquote><p><a name="ojMfe"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code>宏观上看，从TCP的特性可以得知，它有自己的错误检测机制、数据按序传输、确认应答+序列号、支持重传的功能。然后具体的内部处理是怎样的呢？主要有以下两点</code></pre><ul><li>停止等待协议这是最简单的保证可靠传输的协议以下会发生两种情况<ul><li>无差错<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191248595-92370406-641f-497b-a9c8-b50d1b81d4a7.jpeg#align=left&display=inline&height=452&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E6%97%A0%E5%B7%AE%E9%94%99.jpg&originHeight=452&originWidth=511&size=27921&status=done&style=none&width=511" alt="停止等待协助-无差错.jpg"><br />可以看到Client 在发送分组M1(即数据单元)后，暂停，等到Server发回确认后，继续发送下一个分组…<br />这是理想条件下的无差错情况</li><li>有差错</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191306837-86029c09-7535-4067-ad2a-84a581932092.jpeg#align=left&display=inline&height=451&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg&originHeight=451&originWidth=513&size=33516&status=done&style=none&width=513" alt="停止等待协助-超时重传.jpg"><br />当Client 发送 分组M1（会先设置一个计时器，在此计时器内M1仍存在，以便重传）时，可能会遇到数据无法到达Server，或者Server 检测出问题并丢弃了它，在指定时间内Client 如果未收到来自Server 的确认，则会重传M1，即人们常说的<code>超时重传</code>超时重传会有以下情况</p><pre><code>  - 确认丢失（发回延迟）&lt;br /&gt;Client发送分组M1,Server收到M1并发送确认分组，而在指定的时间内Client没有收到确认，后会重传M1.&lt;br /&gt;而由于Server 已经收到过M1了， 所以此时它需要 丢弃M1分组, 发送确认分组&lt;br /&gt;  - 确认迟到（发送延迟）&lt;br /&gt;由于网络延迟等原因，Client发送的分组M1，在指定时间后才到Server， 此时Client 还没来得及收到确认，再次发送分组M1&lt;br /&gt;而由于Server 刚好收到了M1，所以此时它需要 丢弃M1分组, 发送确认分组，&lt;br /&gt;Client 收到&gt;=2个以上的确认，会执行丢弃操作，并且停止发送&lt;br /&gt;</code></pre><ul><li>连续ARQ协议<br />由于停止等待协议对信道的利用率太低，故可以采用流水线的方式来传输，即连续ARQ协议。<br />这里需要提到一个<code>发送窗口</code>的概念。发送窗口支持滑动，所以也有<code>滑动窗口</code>这么一个概念<br />    Client 会维护一个发送窗口，一个窗口内可以有多个连续分组进行发送，而不必等待对方的确认一条条分组发。<br />    Server 亦不会对每个分组进行回传确认，而是在按需发送到达的最后一个分组到达之后，发送确认，代表这个窗口的分组已经发送成功</li></ul><p><a name="1Ljjk"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><a name="3vTak"></a></p><h3 id="1-使用滑动窗口"><a href="#1-使用滑动窗口" class="headerlink" title="1. 使用滑动窗口"></a>1. 使用滑动窗口</h3><pre><code>窗口主要分为接收窗口和发送窗口</code></pre><ul><li>接收窗口<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582191463835-75b3e1a7-bae5-40e1-b310-3efe8b95950f.png#align=left&display=inline&height=104&name=%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png&originHeight=104&originWidth=636&size=21213&status=done&style=none&width=636" alt="接收窗口.png"></li></ul><p>“接收窗口”大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。图中，接收窗口是31~50，大小为20。<br />　　在接收窗口中，黑色的表示已收到的数据，白色的表示未收到的数据。<br />　　当收到窗口左边的数据，如27，则丢弃，因为这部分已经交付给主机；<br />　　当收到窗口右边的数据，如52，则丢弃，因为还没轮到它；<br />　　当收到已收到的窗口中的数据，如32，丢弃；<br />　　当收到未收到的窗口中的数据，如35，缓存在窗口中。</p><ul><li><p>发送窗口<br /></p><pre><code>  ![发送窗口.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191487752-d6496e44-5da6-4121-922b-845d2dfbcf60.png#align=left&amp;display=inline&amp;height=126&amp;name=%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png&amp;originHeight=126&amp;originWidth=636&amp;size=20821&amp;status=done&amp;style=none&amp;width=636)</code></pre></li></ul><p>发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制，暂时可以理解swnd= rwnd =20。<br />　　图中分为四个区段，其中P1到P3是发送窗口。<br />　　tips：发送窗口以字节为单位。为了方便画图，图中展示得像以报文为单位一样。但这不影响理解。</p><p><a name="eXF2w"></a></p><h3 id="2-重传与确认"><a href="#2-重传与确认" class="headerlink" title="2. 重传与确认"></a>2. 重传与确认</h3><ul><li>确认<br />这里主要是通过累计确认的方式<br /></li><li>重传<br />这里主要是上面说的<code>超时重传</code>，每一个报文都会有超时计数器，当超过指定时间后，Client（发送方）会触发重传报文</li></ul><p><a name="x3Wpy"></a></p><h3 id="3-流量控制（基于滑动窗口）"><a href="#3-流量控制（基于滑动窗口）" class="headerlink" title="3. 流量控制（基于滑动窗口）"></a>3. 流量控制（基于滑动窗口）</h3><pre><code>流量即发送方发送的报文流量。当接收方来不及处理数据时，通过滑动窗口，告诉发送方能够接受的单位字节是多少，以降低发送的频率，防止包丢失&lt;br /&gt;![流量控制.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191515681-2b00f8b3-3584-415e-9fb8-061bc3b5e8cc.png#align=left&amp;display=inline&amp;height=367&amp;name=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png&amp;originHeight=367&amp;originWidth=619&amp;size=98699&amp;status=done&amp;style=none&amp;width=619)</code></pre><ul><li><p>在建立连接时,接收方(B),告诉了发送方(A):<code>我的接收窗口是400(单位字节)</code>.<br /></p></li><li><p>图中的<code>ACK</code>为TCP首部的ACK字段,<code>ack</code>为首部的确认号字段.<br /></p></li><li><p>流量控制体现在:<code>rwnd=300, rwnd=100, rwnd=0</code>.在确认报文的窗口字段设定了发送方能够发出的数据多少,从而控制流量.注意只有到首部的<code>ACK</code>字段值为1,窗口字段的值才有效.<br /></p></li><li><p>假设在B发送了<code>rwnd=0</code>之后,过段时间由于自己又希望接收到数据,于是发出<code>rwnd=400</code>的报文,但是该报文丢失了,这样A依然无法发送数据,B希望接收但接收不到数据.<br /></p><p>  为解决该问题,TCP为每个链接都设有一个<code>持续计时器</code>.只要接收到对方窗口为0的通知,就启动持续计时器.在计时器到期后,就发送<code>探测报文</code>,对方可以在该报文的确认中告知当前的窗口值.若窗口任然为0,那么就重新设定计时器,若不为0,那么上述的问题就解决了。</p></li></ul><p><a name="V732a"></a></p><h3 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h3><pre><code>拥塞是指对网络某一资源(带宽,缓存等)的需求超过了可提供的部分,从而使网络中传送的数据不能按时到达,网络性能变差的情况.&lt;br /&gt;拥塞控制就是防止过多的数据注入到网络中,这样网络中的资源压力就小了.&lt;br /&gt;流量控制和拥塞控制似乎很相似,但是他们不同.前者立足于接收和发送者双方的情况;而后者注重的是数据量对网络环境的影响</code></pre><p><a name="CwpQP"></a></p><h1 id="TCP-粘包、拆包"><a href="#TCP-粘包、拆包" class="headerlink" title="TCP 粘包、拆包"></a>TCP 粘包、拆包</h1><blockquote><p>由于TCP 是一个面向字节流的协议，这也决定了它的数据是无结构的。所以TCP无法得知应用层对于这快数据的定义，而是基于自身缓冲区的实际情况进行数据包的拆分，或者将多个数据包进行合并来发送。</p></blockquote><p>参考下图，在不同的条件下，会发生多种现象</p><ul><li>Server 分别接收P1,P2，没有发生粘包、拆包<br /></li><li>Server 一次接收P1+P2两个报文，发生了粘包<br /></li><li>Server 先接收P2, 再分别接收了P1_1, P1_2，发生了拆包<br /></li><li>Server 先接收了P2+P1_2，再接收了P1_1，发生了粘包、拆包<br /></li><li>另一种极端情况，当窗口非常小，恰逢P1又很大时，可能会发生多次对P1进行拆包<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191541317-f601cb98-df74-4f9f-af86-e6a992687057.jpeg#align=left&display=inline&height=482&name=%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.jpg&originHeight=482&originWidth=601&size=22960&status=done&style=none&width=601" alt="粘包与拆包.jpg"></p><p>首先我们要知道，发送的数据会先传入发送缓冲区，再通过网络传输发送到接收端的缓冲区<br />以上现象发生的原因主要是</p><ul><li>发送的字节 大于 TCP发送缓冲区的大小，会发生拆包<br /></li><li>发送的报文 大于 MSS(最大报文长度)，会发生拆包<br /></li><li>发送的字节 小于 TCP发送缓冲区的大小，会将多次写入缓冲区的报文一并发送，即发生粘包<br /></li></ul><p>解决方案，需要上层应用程序做对应的处理</p><ul><li><code>规定报文长度</code>。例如设定每条报文固定长度为200字节，当不够时，用空格填充<br /></li><li><code>报文末尾添加回车换行符</code>。例如FTP协议<br /></li><li><code>将报文分为header and body</code>，在头部中声明报文长度，然后根据这个长度来获取报文<br /></li></ul><p>我们常用的Netty 已经帮我们处理好这些问题，我们仅需调用特定的方法即可。这个在后续的Netty挖掘机系列文章会提到栗子。<br />比如有：</p><ul><li><code>LineBasedFrameDecoder</code>  基于换行符解决<br /></li><li><code>DelimiterBasedFrameDecoder</code> 基于分隔符解决<br /></li><li><code>FixedLengthFrameDecoder</code> 指定长度解决</li></ul><p>参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">【读】这一次,让我们再深入一点 - TCP协议</a><br />参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">什么是 TCP 拆、粘包？如何解决？</a></p>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
