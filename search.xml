<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring缓存挖掘机（三）- 自定义缓存</title>
      <link href="/2020/07/15/spring-huan-cun-wa-jue-ji-3-zi-ding-yi-huan-cun/"/>
      <url>/2020/07/15/spring-huan-cun-wa-jue-ji-3-zi-ding-yi-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring缓存挖掘机（三）-自定义缓存"><a href="#Spring缓存挖掘机（三）-自定义缓存" class="headerlink" title="Spring缓存挖掘机（三）- 自定义缓存"></a>Spring缓存挖掘机（三）- 自定义缓存</h1><h2 id="如何实现多级缓存"><a href="#如何实现多级缓存" class="headerlink" title="如何实现多级缓存"></a>如何实现多级缓存</h2><p>参考上一篇的源码分析，Spring提供了缓存实现接口，并且又在support包中实现了几种缓存方案，但都仅支持单一缓存。<br>这时，我们可以把需要的几种缓存组件组装起来，新建一个缓存类Cache 和缓存处理器类CacheManager。<br>其中Cache类同样继承<code>AbstractValueAdaptingCache</code>，重写其方法，将几种缓存的功能实现封装起来<br>CacheManager类同样实现<code>CacheManager</code>，重写其方法，在创建缓存实例的地方，改为创建多种缓存实例。</p><h2 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCache</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractValueAdaptingCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>SaasCache<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存名称     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 缓存级别：1级读本地，2级读redis     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Integer cacheLevel<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> RedisCache rediscache<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> CaffeineCache caffeineCache<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *     * @param name     * @param cacheLevel     * @param allowNullValues     * @param caffeineCache 不传，则表示不存本地     * @param rediscache    不传，则表示不存redis     */</span>    <span class="token keyword">protected</span> <span class="token function">SaasCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer cacheLevel<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowNullValues<span class="token punctuation">,</span> CaffeineCache caffeineCache<span class="token punctuation">,</span> RedisCache rediscache<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>allowNullValues<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">=</span> cacheLevel<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>rediscache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"at least one cache!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>rediscache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"redis cache cannot be empty when setting cache level to 2!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLevel <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"caffeine cache cannot be empty when setting cache level to 1!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>caffeineCache <span class="token operator">=</span> caffeineCache<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rediscache <span class="token operator">=</span> rediscache<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * spring 内部根据key获取缓存时用到     * @param key     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">lookup</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getNativeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> V <span class="token function">getIfPresent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_1</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_2</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            V v <span class="token operator">=</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> <span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                v <span class="token operator">=</span> callable<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ValueWrapper <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"setting key {}, value {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            caffeineCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cacheLevel <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            rediscache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ValueWrapper <span class="token function">putIfAbsent</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Object o1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除指定key，当使用@CacheEvict注解后调用     * @see org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts(java.util.Collection, boolean, java.lang.Object)     * @param key     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        caffeineCache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        rediscache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        caffeineCache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rediscache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 这里获取二级缓存有点区别，当获取不到二级缓存的时候，会尝试去获取一级缓存     */</span>    <span class="token keyword">private</span> V <span class="token function">getLevel_2</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> rediscache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            ValueWrapper valueWrapper <span class="token operator">=</span> rediscache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> valueWrapper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"query level_2 key: {}, value: {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">isNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>caffeineCache<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token function">getLevel_1</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> V <span class="token function">getLevel_1</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Callable callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> caffeineCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            ValueWrapper valueWrapper <span class="token operator">=</span> caffeineCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> valueWrapper<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"query level_1 key: {}, value: {}"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>V<span class="token punctuation">)</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br /><h2 id="重新实现RedisCache"><a href="#重新实现RedisCache" class="headerlink" title="重新实现RedisCache"></a>重新实现RedisCache</h2><blockquote><p>重新实现的目的是为了使用它的构造函数，RedisCache默认的构造函数是protected的，自定义缓存管理器无法去加载redis缓存实例</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">public class SaasRedisCache extends RedisCache {    /**     * Create new {@link RedisCache}.     *     * @param name        must not be {@literal null}.     * @param cacheWriter must not be {@literal null}.     * @param cacheConfig must not be {@literal null}.     */    protected SaasRedisCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) {        super(name, cacheWriter, cacheConfig);    }}</code></pre><br /><h2 id="自定义缓存管理器"><a href="#自定义缓存管理器" class="headerlink" title="自定义缓存管理器"></a>自定义缓存管理器</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheManager</span> <span class="token keyword">implements</span> <span class="token class-name">CacheManager</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">SaasCacheManager</span><span class="token punctuation">(</span>RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>redisConnectionFactory <span class="token operator">=</span> redisConnectionFactory<span class="token punctuation">;</span>        Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames <span class="token operator">=</span> SaasCacheNameConfig<span class="token punctuation">.</span><span class="token function">getCacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缓存开启，缓存名称列表：{}"</span><span class="token punctuation">,</span> cacheNames<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setCacheNames</span><span class="token punctuation">(</span>cacheNames<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCacheNames</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">newCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> SaasCacheNameConfig<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Cache <span class="token function">newCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> SaasCacheNameData cacheExpire<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"缓存名称：{}，缓存级别：{}，设置缓存时间：{}"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaasCache</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token function">newCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">newRedisCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheExpire<span class="token punctuation">.</span><span class="token function">getCacheExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br /><h2 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h2><blockquote><p>这里主要配置redis</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 193.112.7.209    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">10000</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">100</span>        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> <span class="token number">-1</span>        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span></code></pre><pre class=" language-java"><code class="language-java">@<span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    RedisConnectionFactory redisConnectionFactory<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaasCacheManager</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class DemoServiceImpl implements DemoService {    @Cacheable(value = SaasCacheConfig.cacheName, key = "#s1.concat(#s2)", sync = true)    @Override    public String getData(String s1, String s2, Integer i1) {        System.out.println("none cache, start to save...");        return "success";    }    @CacheEvict(value = SaasCacheConfig.cacheName, key = "#s1.concat(#s2)", beforeInvocation = false)    @Override    public void clearData(String s1, String s2, Integer i1) {        // empty list    }}</code></pre><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><pre class=" language-JAVA"><code class="language-JAVA">@Testpublic void demo() throws Exception {    demoService.clearData("1", "2", 3);    for(int i = 0; i < 10; i++) {        new Thread(() -> {            System.out.println(demoService.getData("1", "2", 3));        }).start();    }    Thread.sleep(10*1000);    demoService.clearData("1", "2", 3);    System.out.println(demoService.getData("1", "2", 3));}</code></pre><h3 id="测试结果打印"><a href="#测试结果打印" class="headerlink" title="测试结果打印"></a>测试结果打印</h3><pre><code>none cache, start to save...2020-07-16 11:48:59.442  INFO 21882 --- [       Thread-5] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.480  INFO 21882 --- [       Thread-6] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.496  INFO 21882 --- [       Thread-7] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.516  INFO 21882 --- [       Thread-8] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.535  INFO 21882 --- [       Thread-2] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.553  INFO 21882 --- [       Thread-4] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.571  INFO 21882 --- [      Thread-11] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.591  INFO 21882 --- [      Thread-10] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.607  INFO 21882 --- [       Thread-3] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess2020-07-16 11:48:59.615  INFO 21882 --- [       Thread-9] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccessnone cache, start to save...2020-07-16 11:49:09.445  INFO 21882 --- [           main] source.cache.springcache.SaasCache       : query level_2 key: 12, value: successsuccess</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring缓存挖掘机（二）- 缓存及管理器</title>
      <link href="/2020/07/12/spring-huan-cun-wa-jue-ji-2-huan-cun-ji-guan-li-qi/"/>
      <url>/2020/07/12/spring-huan-cun-wa-jue-ji-2-huan-cun-ji-guan-li-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h2><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212726143_1059579798.png" alt="缓存管理器"></p><p>Spring提供了中央缓存管理器的底层SPI接口：<code>org.springframework.cache.CacheManager</code>，在spring-context 模块内。</p><p>以上是CacheManager 以及不同的缓存方案的管理器实现类</p><p>Spring提供的缓存管理器的SPI接口很简单，仅仅提供了两个待实现的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CacheManager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过指定缓存名称获取关联的缓存     */</span>    <span class="token annotation punctuation">@Nullable</span>    Cache <span class="token function">getCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取此缓存管理器已知的缓存名称的集合     */</span>    Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200711230414394_1325718760.png" alt="cache"></p><p>了解下Spring 提供的缓存接口<code>org.springframework.cache.Cache</code>，在<strong>spring-context</strong> 模块内，里面主要提供了存取缓存的方法，这里就不贴代码了</p><p>接下来讲一下几种缓存方案的接入和实现源码</p><br /><h2 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h2><blockquote><p>Caffeine，基于JAVA8的一个高性能缓存库，类似于<code>ConcurrentMap</code>，但不同的一点在于Caffeine可以基于一定规则动态清除缓存，而<code>ConcurrentMap</code>只能手动清除<br>github地址：<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">https://github.com/ben-manes/caffeine</a></p></blockquote><p><br /><a href="https://cloud.tencent.com/developer/article/1497595" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497595</a></p><h3 id="引入Caffeine依赖"><a href="#引入Caffeine依赖" class="headerlink" title="引入Caffeine依赖"></a>引入Caffeine依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.ben-manes.caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="声明缓存类型"><a href="#声明缓存类型" class="headerlink" title="声明缓存类型"></a>声明缓存类型</h3><blockquote><p>这里的声明主要有两种方式，Spring 提供的配置声明，自定义bean声明</p></blockquote><h4 id="配置声明"><a href="#配置声明" class="headerlink" title="配置声明"></a>配置声明</h4><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> caffeine    <span class="token key atrule">cache-names</span><span class="token punctuation">:</span> <span class="token string">"saas-cache"</span></code></pre><h4 id="自定义声明"><a href="#自定义声明" class="headerlink" title="自定义声明"></a>自定义声明</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String cacheName <span class="token operator">=</span> <span class="token string">"saas-cache"</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCacheManager</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br/><h3 id="CaffeineCacheConfiguration"><a href="#CaffeineCacheConfiguration" class="headerlink" title="CaffeineCacheConfiguration"></a>CaffeineCacheConfiguration</h3><blockquote><p>顾名思义，它是一个Caffeine缓存配置类，主要用来创建Caffeine缓存管理器，<br>需要在配置文件上添加相应的配置，如上面的配置声明。</p></blockquote><p>该类上添加了条件注解@Conditional***，如果条件不生效，则不会创建该bean。</p><pre class=" language-JAVA"><code class="language-JAVA">@Configuration(proxyBeanMethods = false)@ConditionalOnClass({ Caffeine.class, CaffeineCacheManager.class })@ConditionalOnMissingBean(CacheManager.class)@Conditional({ CacheCondition.class })class CaffeineCacheConfiguration {    /**     * @param cacheProperties    在上面声明缓存类型中的配置声明，则会一一匹配到CacheProperties     */    @Bean    CaffeineCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers customizers,            ObjectProvider<Caffeine<Object, Object>> caffeine, ObjectProvider<CaffeineSpec> caffeineSpec,            ObjectProvider<CacheLoader<Object, Object>> cacheLoader) {        CaffeineCacheManager cacheManager = createCacheManager(cacheProperties, caffeine, caffeineSpec, cacheLoader);        // 这里读取配置中配置的cache-names        List<String> cacheNames = cacheProperties.getCacheNames();        if (!CollectionUtils.isEmpty(cacheNames)) {            cacheManager.setCacheNames(cacheNames);        }        return customizers.customize(cacheManager);    }}</code></pre><br/><h3 id="CaffeineCacheManager"><a href="#CaffeineCacheManager" class="headerlink" title="CaffeineCacheManager"></a>CaffeineCacheManager</h3><h4 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h4><ul><li>存放的缓存名称cacheMap，默认设置初始容量为16<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> ConcurrentMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Cache<span class="token operator">></span> cacheMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>默认缓存模式为静态模式，即不支持动态创建<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li><li>默认允许缓存null值<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> allowNullValues <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="设置缓存模式，及指定缓存名称"><a href="#设置缓存模式，及指定缓存名称" class="headerlink" title="设置缓存模式，及指定缓存名称"></a>设置缓存模式，及指定缓存名称</h4><p>这一步主要用于声明缓存管理器时调用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCacheNames</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果指定了一组缓存名称，则模式固定为静态模式，此时无法再动态创建其他的缓存区域</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String name <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 反之不指定则为动态模式，允许再次添加缓存</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 为指定的缓存名称创建一个CaffeineCache实例</span><span class="token keyword">protected</span> Cache <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createNativeCaffeineCache</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">isAllowNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">createNativeCaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLoader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果是动态模式，在接下来获取缓存实例时，则会根据定义好的缓存名称动态创建缓存实例。<br>所以这里需要明白系统中所需的是静态还是动态模式！</p><h4 id="加载缓存实例"><a href="#加载缓存实例" class="headerlink" title="加载缓存实例"></a>加载缓存实例</h4><p>这一步主要用于在<code>CacheAspectSupport</code>中构造缓存操作上下文时，指定缓存名称获取缓存实例存入上下文，同个缓存名称只会保存一次</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Cache <span class="token function">getCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cacheMap<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> cacheName <span class="token operator">-</span><span class="token operator">></span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dynamic <span class="token operator">?</span> <span class="token function">createCaffeineCache</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h3 id="CaffeineCache"><a href="#CaffeineCache" class="headerlink" title="CaffeineCache"></a>CaffeineCache</h3><blockquote><p>Spring在<strong>spring-context-support</strong>中提供了Caffeine 的默认实现，要使用它的前提是项目中引入Caffeine的依赖，并显示地声明缓存管理器为<code>CaffeineCacheManager</code></p></blockquote><h4 id="构造缓存实例"><a href="#构造缓存实例" class="headerlink" title="构造缓存实例"></a>构造缓存实例</h4><blockquote><p>这一步主要用于声明缓存管理器时调用，在管理器中获取Caffeine缓存实例，再构造基于Sping cache的一个缓存实例<br>注意：这里默认拿到的Caffeine缓存实例是无界的，即UnboundedLocalManualCache，而想要获得有界缓存实例的条件是，指定一定的有界条件，如maximumSize，详细查看com.github.benmanes.caffeine.cache.Caffeine#isBounded</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CaffeineCache</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> cache<span class="token punctuation">,</span>        <span class="token keyword">boolean</span> allowNullValues<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>allowNullValues<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"Name must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span> <span class="token string">"Cache must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> cache<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取缓存"><a href="#获取缓存" class="headerlink" title="获取缓存"></a>获取缓存</h4><h5 id="获取底层使用的缓存"><a href="#获取底层使用的缓存" class="headerlink" title="获取底层使用的缓存"></a>获取底层使用的缓存</h5><blockquote><p>Caffeine底层有多种类型的缓存实现，如有界缓存和无界缓存等</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> cache<span class="token punctuation">;</span> <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>github<span class="token punctuation">.</span>benmanes<span class="token punctuation">.</span>caffeine<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>Cache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getNativeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="获取缓存-1"><a href="#获取缓存-1" class="headerlink" title="获取缓存"></a>获取缓存</h5><blockquote><p>这一步主要用于执行缓存注解的方法前，同步/异步获取缓存，如若获取不到则调取注解方法获取最新结果</p></blockquote><ul><li>非同步获取</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key获取缓存，并对其包装成ValueWrapper */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> ValueWrapper <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token keyword">instanceof</span> <span class="token class-name">LoadingCache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>LoadingCache<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">toValueWrapper</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * 查找指定key的缓存 */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> Object <span class="token function">lookup</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>同步获取</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key获取缓存，如果缓存不存在，则同步调用底层的get(K key, Function&lt;? super K, ? extends V> mappingFunction) * 一般缓存框架都默认实现了同步逻辑，如Caffeine cache 底层就使用了ConcurrentHashMap实现的同步处理，详细可看源码com.github.benmanes.caffeine.cache.UnboundedLocalCache#computeIfAbsent */</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token keyword">final</span> Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> valueLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token function">fromStoreValue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LoadFunction</span><span class="token punctuation">(</span>valueLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="存储缓存"><a href="#存储缓存" class="headerlink" title="存储缓存"></a>存储缓存</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 将值与指定key进行关联缓存 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">toStoreValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 若值与指定key关联缓存则直接返回，否则以原子操作 将两者进行关联，其底层使用了get(Object key, final Callable&lt;T> valueLoader) */</span><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> ValueWrapper <span class="token function">putIfAbsent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token keyword">final</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获得一个可调用的方法</span>    PutIfAbsentFunction callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PutIfAbsentFunction</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> callable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>callable<span class="token punctuation">.</span>called <span class="token operator">?</span> null <span class="token operator">:</span> <span class="token function">toValueWrapper</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="逐出缓存"><a href="#逐出缓存" class="headerlink" title="逐出缓存"></a>逐出缓存</h4><blockquote><p>适用于注解@CacheEvict，根据属性beforeInvocation 确定是在调用方法之前还是成功之后逐出缓存</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定key逐出缓存 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">invalidate</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 指定key逐出缓存，如果该key存在并且逐出成功，则返回true */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">evictIfPresent</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><br /><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><blockquote><p>关于redis就不必多介绍了，大家经常用哈哈<br>Spring 将redis相关的 都放在 spring-data-redis中，如果是Springboot应用需要引入spring-boot-starter-data-redis</p></blockquote><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 要引入，用作redis连接池，否则会报错 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="声明缓存类型-1"><a href="#声明缓存类型-1" class="headerlink" title="声明缓存类型"></a>声明缓存类型</h3><h4 id="配置声明-1"><a href="#配置声明-1" class="headerlink" title="配置声明"></a>配置声明</h4><pre class=" language-YAML"><code class="language-YAML">spring:  cache:    type: redis  redis:    host: 127.0.0.1    port: 6379    timeout: 10000    database: 0    lettuce:      pool:        max-active: 100        max-wait: -1        max-idle: 8        min-idle: 0</code></pre><br /><h3 id="RedisCacheConfiguration"><a href="#RedisCacheConfiguration" class="headerlink" title="RedisCacheConfiguration"></a>RedisCacheConfiguration</h3><blockquote><p>Redis缓存配置类，主要用来创建Redis缓存管理器，需要结合上面的配置 才能正常创建 bean</p></blockquote><p>同样在该类上也做了约束，如Redis的连接工厂的class需要在类路径上，需要在redis配置bean加载后再加载该类，需要先在当前上下文中加载Redis连接工厂后再加载该类。</p><pre class=" language-JAVA"><code class="language-JAVA">@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisConnectionFactory.class)@AutoConfigureAfter(RedisAutoConfiguration.class)@ConditionalOnBean(RedisConnectionFactory.class)@ConditionalOnMissingBean(CacheManager.class)@Conditional(CacheCondition.class)class RedisCacheConfiguration {    @Bean    RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,            ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,            ObjectProvider<RedisCacheManagerBuilderCustomizer> redisCacheManagerBuilderCustomizers,            RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) {        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(                determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));        List<String> cacheNames = cacheProperties.getCacheNames();        if (!cacheNames.isEmpty()) {            builder.initialCacheNames(new LinkedHashSet<>(cacheNames));        }        redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));        return cacheManagerCustomizers.customize(builder.build());    }}</code></pre><br /><h3 id="RedisCacheManager"><a href="#RedisCacheManager" class="headerlink" title="RedisCacheManager"></a>RedisCacheManager</h3><blockquote><p>在上面的RedisCacheConfiguration中，它负责加载RedisCacheManager，通过<code>builder.build()</code></p></blockquote><h4 id="加载缓存管理器"><a href="#加载缓存管理器" class="headerlink" title="加载缓存管理器"></a>加载缓存管理器</h4><blockquote><p>这一步主要在Spring初始化的过程中，先指定一定约束条件加载RedisCacheConfiguration，再再加载缓存管理器。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> RedisCacheManager <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    RedisCacheManager cm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisCacheManager</span><span class="token punctuation">(</span>cacheWriter<span class="token punctuation">,</span> defaultCacheConfiguration<span class="token punctuation">,</span> initialCaches<span class="token punctuation">,</span>            allowInFlightCacheCreation<span class="token punctuation">)</span><span class="token punctuation">;</span>    cm<span class="token punctuation">.</span><span class="token function">setTransactionAware</span><span class="token punctuation">(</span>enableTransactions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> cm<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="加载缓存实例-1"><a href="#加载缓存实例-1" class="headerlink" title="加载缓存实例"></a>加载缓存实例</h4><blockquote><p>这一步主要在前文提到的，在CacheAspectSupport类中构造缓存上下文的过程（祥看<code>org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContext#CacheOperationContext</code>）创建的</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">@Overrideprotected RedisCache getMissingCache(String name) {    return allowInFlightCacheCreation ? createRedisCache(name, defaultCacheConfig) : null;}</code></pre><br /><h3 id="RedisCache"><a href="#RedisCache" class="headerlink" title="RedisCache"></a>RedisCache</h3><h4 id="构造缓存实例-1"><a href="#构造缓存实例-1" class="headerlink" title="构造缓存实例"></a>构造缓存实例</h4><blockquote><p>上面提到，在CacheAspectSupport类中构造缓存上下文的过程中，会同时加载缓存实例，下面看如何创建</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">protected RedisCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) {    super(cacheConfig.getAllowCacheNullValues());    Assert.notNull(name, "Name must not be null!");    Assert.notNull(cacheWriter, "CacheWriter must not be null!");    Assert.notNull(cacheConfig, "CacheConfig must not be null!");    this.name = name;    this.cacheWriter = cacheWriter;    this.cacheConfig = cacheConfig;    this.conversionService = cacheConfig.getConversionService();}</code></pre><h4 id="获取缓存-2"><a href="#获取缓存-2" class="headerlink" title="获取缓存"></a>获取缓存</h4><pre class=" language-JAVA"><code class="language-JAVA">/** * Caffeine的同步方式是基于ConcurrentHashMap实现的，而基于Redis的同步方式是使用synchronized实现 * 注意，这里我们可以看到，无论是否能获取缓存，这里始终是同步的 * @param valueLoader    待执行的注解方法，在无缓存时调用 */public synchronized <T> T get(Object key, Callable<T> valueLoader) {    // 将缓存包装成ValueWrapper，存在则直接返回    ValueWrapper result = get(key);    if (result != null) {        return (T) result.get();    }    T value = valueFromLoader(key, valueLoader);    put(key, value);    return value;}protected Object lookup(Object key) {    byte[] value = cacheWriter.get(name, createAndConvertCacheKey(key));    if (value == null) {        return null;    }    // 使用反序列化器将值进行反序列化    return deserializeCacheValue(value);}</code></pre><h4 id="存储缓存-1"><a href="#存储缓存-1" class="headerlink" title="存储缓存"></a>存储缓存</h4><blockquote><p>在上一步获取不到缓存，进而调用注解方法得到结果后，开始存储缓存</p></blockquote><pre class=" language-JAVA"><code class="language-JAVA">public void put(Object key, @Nullable Object value) {    // 这里会做校验，是否配置了运行存储NULL值，如果不支持NULL值并且结果为NULL，则将其置为NullValue    Object cacheValue = preProcessCacheValue(value);    if (!isAllowNullValues() && cacheValue == null) {        throw new IllegalArgumentException(String.format(                "Cache '%s' does not allow 'null' values. Avoid storing null via '@Cacheable(unless=\"#result == null\")' or configure RedisCache to allow 'null' via RedisCacheConfiguration.",                name));    }    cacheWriter.put(name, createAndConvertCacheKey(key), serializeCacheValue(cacheValue), cacheConfig.getTtl());}</code></pre><h4 id="逐出缓存-1"><a href="#逐出缓存-1" class="headerlink" title="逐出缓存"></a>逐出缓存</h4><blockquote><p>适用于注解@CacheEvict，根据属性beforeInvocation 确定是在调用方法之前还是成功之后逐出缓存<br>调用方法详细可查看：<code>org.springframework.cache.interceptor.CacheAspectSupport#execute(org.springframework.cache.interceptor.CacheOperationInvoker, java.lang.reflect.Method, org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContexts)</code></p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指定缓存名称和key逐出缓存 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">evict</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cacheWriter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token function">createAndConvertCacheKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于其他缓存及其处理器，方式差不多和以上两个一样，这里就不一一列举了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>可以发现，Spring内置的缓存处理机制，只适用于单个缓存的场景之下。而当我们需要考虑多级缓存的时候，貌似很难着手，这时可以通过以上的源码分析思考下，如何自定义（多级）缓存。</p><p>在下一篇中，我将会进行实战如何自定义（多级）缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring缓存挖掘机（一）- demo及源码剖析</title>
      <link href="/2020/07/10/spring-huan-cun-wa-jue-ji-1-demo-ji-yuan-ma-pou-xi/"/>
      <url>/2020/07/10/spring-huan-cun-wa-jue-ji-1-demo-ji-yuan-ma-pou-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于系统中存在多方请求设备服务获取设备运行状态的现象，易出现重复请求的问题，故需要使用缓存去减缓调取频率，具体的方案是多级缓存操作<br />本地缓存+redis缓存+调设备服务（慢，耗资源）<br />先查本地缓存，若无则查redis缓存，否则再调服务<br /><br><br /></p><h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><p>先看下市面上现有的缓存框架有哪些<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1592883820155-ce76c20f-9f94-46a0-9a19-c36155b8a577.png#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=594&size=23107&status=done&style=none&width=594#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&originHeight=363&originWidth=594&status=done&style=none&width=594" alt="image.png"><br /><br><br /></p><p><a name="4b87a15b"></a></p><h2 id="Spring-内置缓存组件"><a href="#Spring-内置缓存组件" class="headerlink" title="Spring 内置缓存组件"></a>Spring 内置缓存组件</h2><p><br />先阅读下官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-caching" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-caching</a><br /></p><h3 id="Spring缓存管理器"><a href="#Spring缓存管理器" class="headerlink" title="Spring缓存管理器"></a>Spring缓存管理器</h3><p>阅读文档可知，Spring提供了中央缓存管理器的底层SPI接口：<code>org.springframework.cache.CacheManager</code>，，在spring-context 模块内。<br>基于它可由各种第三方的缓存管理器去实现和扩展，目前Spring 同样内置了以下几种第三方缓存组件管理器，命名规范为***Manager<br /></p><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212726143_1059579798.png" alt="缓存管理器"></p><br /><h3 id="Spring缓存"><a href="#Spring缓存" class="headerlink" title="Spring缓存"></a>Spring缓存</h3><p>Spring 也提供了缓存通用操作接口<code>org.springframework.cache.Cache</code>，在spring-context 模块内<br>而在Cache接口下，Spring内置了几种市面上常见缓存方案的实现，命名规范为<code>***Cache</code></p><p><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200711230414394_1325718760.png" alt="cache"></p><p>以上，RedisCache位于spring-data-redis，其他的都在spring-context-support中。<br>注意，可以看到，在Spring5 中 已经没了GuavaCache的身影，取而代之的是Caffeine。</p><table><thead><tr><th>缓存</th><th>说明</th></tr></thead><tbody><tr><td>CaffeineCache</td><td>是通过JAVA8对Guava缓存的重写版本，（在Spring5）取代了对Guava缓存的支持，在5.2.4中要求Caffeine版本为2.1或以上</td></tr><tr><td>ConcurrentMapCache</td><td>基于ConcurrentMap实现的缓存技术，无过期时间，需手动删除</td></tr><tr><td>JCacheCache</td><td>基于JCache标准的实现作为缓存技术</td></tr><tr><td>RedisCache</td><td>基于Redis实现的缓存技术</td></tr><tr><td>EhCacheCache</td><td>基于EhCache实现的缓存技术</td></tr><tr><td>NoOpCache</td><td>不会实际存储缓存，适用于禁用缓存的无操作实现</td></tr></tbody></table><p>而在Springboot中，通过<code>org.springframework.boot.autoconfigure.cache.CacheType</code>可以发现，Springboot还支持了其他类型的缓存框架</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> CacheType <span class="token punctuation">{</span>    GENERIC<span class="token punctuation">,</span>    JCACHE<span class="token punctuation">,</span>    EHCACHE<span class="token punctuation">,</span>    HAZELCAST<span class="token punctuation">,</span>    INFINISPAN<span class="token punctuation">,</span>    COUCHBASE<span class="token punctuation">,</span>    REDIS<span class="token punctuation">,</span>    CAFFEINE<span class="token punctuation">,</span>    SIMPLE<span class="token punctuation">,</span>    NONE<span class="token punctuation">}</span></code></pre><p>这里也大概说明一下</p><table><thead><tr><th>缓存</th><th>说明</th></tr></thead><tbody><tr><td>HAZELCAST</td><td>全称是Hazelcast IMDG (In-Memory Data Grid)，内存数据网格<br />是一个<strong>开源的分布式内存</strong>数据存储和计算平台<br />提供多种分布式数据结构如Map/Queue/Topic等<br /></td></tr><tr><td>INFINISPAN</td><td>是一款基于Apache v2.0版本的开源数据网格系统</td></tr><tr><td>COUCHBASE</td><td>是一款非关系型数据库，MemBase（存储键值对）与couchDb（存储json文档）这两个NoSQL数据库合并的产物，</td></tr></tbody></table></br><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>增加了对应的注解方式以支持缓存功能：@EnableCaching、@CacheConfig、@Cacheable、@CachePut、@CacheEvict等</p><h4 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h4><blockquote><p>启用Springboot 的缓存管理功能，等同于&lt;cache: * &gt; 的xml文件配置。当开启时，CacheManager的bean<strong>必须</strong>指定手动注册，目前暂未有合理的缓存框架可以用作惯例。<br>当要将 <code>@EnableCaching</code>与CacheManager等建立合理的联系时，Spring已经提供了接口<code>CachingConfigurer</code>用于实现</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>proxyTargetClass</td><td>是否要基于cglib的代理方式，缺省为false，即基于jdk动态代理</td></tr><tr><td>mode</td><td>代理实现方式（动态代理PROXY，静态代理ASPECTJ），缺省为动态代理</td></tr></tbody></table><h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><blockquote><p><strong>类级别</strong>的注解。用于提供一种在类级别共享与缓存相关的配置。当注解在类上时，会提供基于该类的默认配置，即可能被覆盖</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>cacheNames</td><td>缓存操作对应的名称，可多个</td></tr><tr><td>keyGenerator</td><td>要使用的自定义key生成器的bean名称，当缓存操作未设置任何值时，使用它替代默认值</td></tr><tr><td>cacheManager</td><td>要使用的自定义cacheManager的bean名称，当缓存操作未设置解析器和管理器时，且没通过cacheResolver属性设置解析器时，使用它替代默认值</td></tr><tr><td>cacheResolver</td><td>要使用的自定义cacheResolver的bena名称，当缓存操作未设置解析器和管理器时，使用它替代默认值</td></tr></tbody></table><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><blockquote><p>被注解的方法，支持在有缓存时直接返回，无缓存（或缓存过期）时执行方法，并在方法返回时指定缓存名称和key缓存最新数据<br>适用场景：注解方法需要做缓存以 缓解调用频率对底层service/db的影响，通过过期时间可灵活设置数据更新</p></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>cacheNames</td><td>缓存操作对应的名称，可多个</td></tr><tr><td>value</td><td>同上</td></tr><tr><td>key</td><td>默认使用方法参数作为key值，也可以借助SpEL表达式组装key值</td></tr><tr><td>keyGenerator</td><td>与key功能互斥，要使用的自定义cacheManager的bean名称，可以实现org.springframework.cache.interceptor.KeyGenerator使用</td></tr><tr><td>cacheManager</td><td>要使用的自定义cacheManager的bean名称</td></tr><tr><td>cacheResolver</td><td>与cacheManager互斥，要使用的自定义cacheResolver的bena名称</td></tr><tr><td>condition</td><td>缓存条件，使用SpEL表达式来实现，只有条件成立才会缓存</td></tr><tr><td>unless</td><td>否决缓存条件，使用SpEL表达式来实现，即在方法调用后执行该条件，只有条件不成立才会缓存</td></tr><tr><td>sync</td><td>是否开启同步调用，默认false，当为true时多线程执行时则会同步调用注解方法（注意，前提需要第三方缓存框架提供同步支持，自定义实现时也要考虑）</td></tr></tbody></table><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><blockquote><p>与@Cacheable相反，它会一直执行注解方法而不会跳过，并每次将结果存储在缓存中，底层触发Cache的put()<br>适用场景：注解方法需要被调用以及时更新缓存</p></blockquote><p>它的属性和@Cacheable 一样，只不过少了sync，因为它不需考虑是否要同步调用</p><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><blockquote><p> 被注解的方法，支持在调用方法前/后 执行缓存逐出操作，底层触发Cache的evict()<br>适用场景：注解方法需要在特定时间被调用以逐出缓存，例如一个设备启动并结束后，关乎它的某些状态已无需维护，故在结束那一刻逐出缓存</p></blockquote><p>它的属性和@Cacheable也差不多，下面看些不一样的属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>allEntries</td><td>是否逐出指定缓存名称下的所有key，缺省为false，仅逐出指定key的缓存；true则在方法执行成功后逐出所有key的缓存</td></tr><tr><td>beforeInvocation</td><td>是否在调用方法之前逐出指定key缓存，缺省为false，当方法执行成功后才会逐出缓存；true则无需关心方法的调用结果，直接逐出</td></tr></tbody></table></br><h2 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h2><p>在分析源码之前，先使用一个demo来分析（注意，这里要引入caffeine的依赖）<br /></p><ul><li>先定义了一个缓存的配置类CustomCacheConfig，使用@EnableCaching开启缓存支持，定义缓存名称，初始化缓存管理器CaffeineCacheManager，带入缓存名称。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaasCacheConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 全局缓存名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String cacheName <span class="token operator">=</span> <span class="token string">"saas-cache"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"cacheManager"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CacheManager <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCacheManager</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>编写一个service接口和实现类，在其接口方法上添加缓存注解，sync代表同步访问</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DemoService</span> <span class="token punctuation">{</span>    String <span class="token function">getData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clearData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">DemoService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> SaasCacheConfig<span class="token punctuation">.</span>cacheName<span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#s1.concat(#s2)"</span><span class="token punctuation">,</span> sync <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"none cache, start to save..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>value <span class="token operator">=</span> SaasCacheConfig<span class="token punctuation">.</span>cacheName<span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#s1.concat(#s2)"</span><span class="token punctuation">,</span> beforeInvocation <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearData</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span> String s2<span class="token punctuation">,</span> Integer i1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// empty method</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>编写测试用例，先调用带有@CacheEvict注解的方法进行缓存清除，再多线程执行带有@Cacheable注解的方法，测试是否支持同步访问</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"source.cache"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCache</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    DemoService demoService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoService<span class="token punctuation">.</span><span class="token function">clearData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demoService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>输出结果，验证了@Cacheable和@CacheEvict的作用</li></ul><pre><code>none cache, start to save...successsuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccesssuccessnone cache, start to save...success</code></pre><br /><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先在实现方法上打断点<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212815509_1714130693.png" alt="debug1"><br><br />运行测试用例，断点内容如下<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710212855279_1874790059.png" alt="debug2"><br />上图断点转换成大致流程如下<br /><img src="/images/Spring%E7%BC%93%E5%AD%98%E6%8C%96%E6%8E%98%E6%9C%BA/20200710213050157_990479030.png" alt="flow_chart"><br />Spring提供了<code>org.springframework.cache.interceptor.CacheInterceptor</code>和<code>org.springframework.cache.interceptor.CacheAspectSupport</code>用于声明式缓存<br /></p><h3 id="CacheAspectSupport"><a href="#CacheAspectSupport" class="headerlink" title="CacheAspectSupport"></a>CacheAspectSupport</h3><p>该类包含了与Spring基础的缓存api的集成功能。<br /><br>下面分析下源码<br /></p><h4 id="拦截器进入到execute"><a href="#拦截器进入到execute" class="headerlink" title="拦截器进入到execute()"></a>拦截器进入到execute()</h4><p>每次进行切面，都会执行execute()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">execute</span><span class="token punctuation">(</span>CacheOperationInvoker invoker<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取被代理类</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> <span class="token function">getTargetClass</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取可操作的缓存资源并指定被代理类+方法进行过滤，得到一个可操作集合</span>        CacheOperationSource cacheOperationSource <span class="token operator">=</span> <span class="token function">getCacheOperationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheOperationSource <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Collection<span class="token operator">&lt;</span>CacheOperation<span class="token operator">></span> operations <span class="token operator">=</span> cacheOperationSource<span class="token punctuation">.</span><span class="token function">getCacheOperations</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>operations<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">execute</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> method<span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">CacheOperationContexts</span><span class="token punctuation">(</span>operations<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> target<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面得到的缓存操作对象CacheOperation 如下</p><pre><code>Builder[public java.lang.String source.cache.service.DemoServiceImpl.getData(java.lang.String,java.lang.String,java.lang.Integer)] caches=[saas-cache] | key=&#39;#s1.concat(#s2)&#39; | keyGenerator=&#39;&#39; | cacheManager=&#39;&#39; | cacheResolver=&#39;&#39; | condition=&#39;&#39; | unless=&#39;&#39; | sync=&#39;true&#39;</code></pre><h4 id="构造缓存操作上下文"><a href="#构造缓存操作上下文" class="headerlink" title="构造缓存操作上下文"></a>构造缓存操作上下文</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CacheOperationContexts</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">CacheOperation</span><span class="token operator">></span> operations<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> Object target<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>contexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedMultiValueMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>operations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>CacheOperation op <span class="token operator">:</span> operations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>contexts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getOperationContext</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> target<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token function">determineSyncFlag</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">CacheOperationContext</span><span class="token punctuation">(</span>CacheOperationMetadata metadata<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>metadata <span class="token operator">=</span> metadata<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> <span class="token function">extractArgs</span><span class="token punctuation">(</span>metadata<span class="token punctuation">.</span>method<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>caches <span class="token operator">=</span> CacheAspectSupport<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCaches</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> metadata<span class="token punctuation">.</span>cacheResolver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cacheNames <span class="token operator">=</span> <span class="token function">createCacheNames</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>caches<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="创建缓存实例"><a href="#创建缓存实例" class="headerlink" title="创建缓存实例"></a>创建缓存实例</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// org.springframework.cache.interceptor.CacheAspectSupport#getCaches</span><span class="token keyword">protected</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> <span class="token function">getCaches</span><span class="token punctuation">(</span>        CacheOperationInvocationContext<span class="token operator">&lt;</span>CacheOperation<span class="token operator">></span> context<span class="token punctuation">,</span> CacheResolver cacheResolver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> caches <span class="token operator">=</span> cacheResolver<span class="token punctuation">.</span><span class="token function">resolveCaches</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>caches<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"No cache could be resolved for '"</span> <span class="token operator">+</span>                context<span class="token punctuation">.</span><span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"' using resolver '"</span> <span class="token operator">+</span> cacheResolver <span class="token operator">+</span>                <span class="token string">"'. At least one cache should be provided per cache operation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> caches<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// org.springframework.cache.interceptor.AbstractCacheResolver#resolveCaches</span><span class="token keyword">public</span> Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Cache</span><span class="token operator">></span> <span class="token function">resolveCaches</span><span class="token punctuation">(</span>CacheOperationInvocationContext<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> cacheNames <span class="token operator">=</span> <span class="token function">getCacheNames</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheNames <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collection<span class="token operator">&lt;</span>Cache<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>cacheNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String cacheName <span class="token operator">:</span> cacheNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取当前设置的缓存管理器中指定名称的缓存实例</span>        Cache cache <span class="token operator">=</span> <span class="token function">getCacheManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCache</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Cannot find cache named '"</span> <span class="token operator">+</span>                    cacheName <span class="token operator">+</span> <span class="token string">"' for "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="若开启了同步模式"><a href="#若开启了同步模式" class="headerlink" title="若开启了同步模式"></a>若开启了同步模式</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">final</span> CacheOperationInvoker invoker<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> CacheOperationContexts contexts<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果开启了同步（即sync=true），则进入if</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">isSynchronized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CacheOperationContext context <span class="token operator">=</span> contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当注解上添加条件condition时，这里需要校验是否通过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isConditionPassing</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 获取key值</span>            Object key <span class="token operator">=</span> <span class="token function">generateKey</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 得到具体的缓存对象，基于SPI机制，这里可以出现不同类型的缓存对象，如CaffeineCache</span>            Cache cache <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如何同步处理的核心就在cache.get这里，不同的缓存组件已经对应封装了同步逻辑，如果缓存存在则直接返回，不存在则同步获取资源</span>                <span class="token comment" spellcheck="true">// </span>                <span class="token keyword">return</span> <span class="token function">wrapCacheValue</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">unwrapReturnValue</span><span class="token punctuation">(</span><span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Cache<span class="token punctuation">.</span>ValueRetrievalException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// The invoker wraps any Throwable in a ThrowableWrapper instance so we</span>                <span class="token comment" spellcheck="true">// can just make sure that one bubbles up the stack.</span>                <span class="token keyword">throw</span> <span class="token punctuation">(</span>CacheOperationInvoker<span class="token punctuation">.</span>ThrowableWrapper<span class="token punctuation">)</span> ex<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 条件不通过，无需缓存直接调用基础方法</span>            <span class="token keyword">return</span> <span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="若是异步模式（默认）"><a href="#若是异步模式（默认）" class="headerlink" title="若是异步模式（默认）"></a>若是异步模式（默认）</h4><h5 id="执行前清除缓存"><a href="#执行前清除缓存" class="headerlink" title="执行前清除缓存"></a>执行前清除缓存</h5><pre class=" language-java"><code class="language-java"><span class="token function">processCacheEvicts</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheEvictOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>若方法注解是@CacheEvict，且设置了属性beforeInvocation为true，则会在执行注解方法之前清除缓存</p><p>清除代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doEvict</span><span class="token punctuation">(</span>Cache cache<span class="token punctuation">,</span> Object key<span class="token punctuation">,</span> <span class="token keyword">boolean</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">evictIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">evict</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleCacheEvictError</span><span class="token punctuation">(</span>ex<span class="token punctuation">,</span> cache<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>清除主要调用了缓存实现对应的<code>evictIfPresent</code>或<code>evict</code>方法</p><h5 id="缓存主逻辑"><a href="#缓存主逻辑" class="headerlink" title="缓存主逻辑"></a>缓存主逻辑</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">final</span> CacheOperationInvoker invoker<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> CacheOperationContexts contexts<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 校验上下文是否命中了缓存操作对象CacheableOperation，如果当前是清除操作则不命中</span>    Cache<span class="token punctuation">.</span>ValueWrapper cacheHit <span class="token operator">=</span> <span class="token function">findCachedItem</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果找不到则收集未命中的缓存</span>    List<span class="token operator">&lt;</span>CachePutRequest<span class="token operator">></span> cachePutRequests <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheHit <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">collectPutRequests</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheableOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                CacheOperationExpressionEvaluator<span class="token punctuation">.</span>NO_RESULT<span class="token punctuation">,</span> cachePutRequests<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Object cacheValue<span class="token punctuation">;</span>    Object returnValue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果命中缓存，并且没有收集缓存，则获取缓存数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheHit <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasCachePut</span><span class="token punctuation">(</span>contexts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cacheValue <span class="token operator">=</span> cacheHit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        returnValue <span class="token operator">=</span> <span class="token function">wrapCacheValue</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        returnValue <span class="token operator">=</span> <span class="token function">invokeOperation</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span><span class="token punctuation">;</span>        cacheValue <span class="token operator">=</span> <span class="token function">unwrapReturnValue</span><span class="token punctuation">(</span>returnValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 收集任何显式的 @CachePuts</span>    <span class="token function">collectPutRequests</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CachePutOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cacheValue<span class="token punctuation">,</span> cachePutRequests<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Process any collected put requests, either from @CachePut or a @Cacheable miss</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>CachePutRequest cachePutRequest <span class="token operator">:</span> cachePutRequests<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cachePutRequest<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="执行后清除缓存"><a href="#执行后清除缓存" class="headerlink" title="执行后清除缓存"></a>执行后清除缓存</h5><pre class=" language-java"><code class="language-java"><span class="token function">processCacheEvicts</span><span class="token punctuation">(</span>contexts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>CacheEvictOperation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> cacheValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>若方法注解是@CacheEvict，且设置了属性beforeInvocation为false（缺省），则会在执行注解方法<strong>成功</strong>后清除缓存<br><br /></p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>作为拦截器的角色，派生于<code>CacheAspectSupport</code>的，spring获取拦截链时，会拿到CacheInterceptor并执行切面逻辑<br><br /></p><p>下一篇继续研究几种缓存方案的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Spring缓存组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring cache </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS集成lambda+ApiGateway</title>
      <link href="/2020/06/04/aws-ji-cheng-lambda-apigateway/"/>
      <url>/2020/06/04/aws-ji-cheng-lambda-apigateway/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于项目不大，但是使用了AWS的服务，挺贵的。。咨询了AWS的技术人员后，他们提供了lambda + Apigateway的方案，可以节省很多的资源。<br /><br><br />尝试过以java为开发语言，springboot为函数框架，冷启动时间很长，响应慢的情况下，还会导致收费增加，故我这里改成脚本语言去实现<br /></p><p><a name="9cjSK"></a></p><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p><a name="nTF9S"></a></p><h3 id="1-创建lamda函数"><a href="#1-创建lamda函数" class="headerlink" title="1. 创建lamda函数"></a>1. 创建lamda函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1589954896351-0c676797-73b9-468b-af75-865b5be48f62.png#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&name=image.png&originHeight=367&originWidth=1795&size=33210&status=done&style=none&width=1795" alt="image.png"><br />下面创建了一个函数名为test-function，运行时为python<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663472276-7f372b8f-fd59-4c05-b1cc-238848425296.png#align=left&display=inline&height=755&margin=%5Bobject%20Object%5D&name=image.png&originHeight=755&originWidth=1794&size=84896&status=done&style=none&width=1794" alt="image.png"><br /></p><p><a name="M1May"></a></p><h3 id="2-配置测试事件"><a href="#2-配置测试事件" class="headerlink" title="2. 配置测试事件"></a>2. 配置测试事件</h3><p>主要用于测试这个函数有没有跑成功<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663537636-1b758b45-a1e5-4a1c-9c4a-afc530b3756a.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=117&originWidth=676&size=8127&status=done&style=none&width=676" alt="image.png"><br />下面配置了一个事件名称为test的测试事件<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1589956651446-b410c5f1-f57d-4718-a61e-08cfeac2cb38.png#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=826&size=32547&status=done&style=none&width=826" alt="image.png"><br /></p><p><a name="I7wNH"></a></p><h3 id="3-添加函数代码"><a href="#3-添加函数代码" class="headerlink" title="3. 添加函数代码"></a>3. 添加函数代码</h3><p>由于上面设置的运行时环境是JAVA8，AWS暂时不支持在面板上编辑代码，故我们可以通过本地写完代码后，上传到S3、或者直接手动上传。这个待定~~<br><a name="HdGAJ"></a></p><h4 id="使用python实现一个函数"><a href="#使用python实现一个函数" class="headerlink" title="使用python实现一个函数"></a>使用python实现一个函数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">handler</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'queryStringParameters'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span>    protocol <span class="token operator">=</span> <span class="token string">'http'</span>    domain_name <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'domainName'</span><span class="token punctuation">]</span>    request_url <span class="token operator">=</span> protocol <span class="token operator">+</span> <span class="token string">'://'</span> <span class="token operator">+</span> domain_name <span class="token operator">+</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'path'</span><span class="token punctuation">]</span>    request_ip <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'requestContext'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'identity'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'sourceIp'</span><span class="token punctuation">]</span>    param <span class="token operator">=</span> event<span class="token punctuation">[</span><span class="token string">'queryStringParameters'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> param <span class="token keyword">is</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"statusCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">'error.'</span><span class="token punctuation">}</span>    param_size <span class="token operator">=</span> len<span class="token punctuation">(</span>param<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> param_size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        param_str <span class="token operator">=</span> <span class="token string">'?'</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">in</span> param<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        param_str <span class="token operator">=</span> param_str <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">'='</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'&amp;'</span>    param_str <span class="token operator">=</span> param_str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    request_url <span class="token operator">=</span> request_url <span class="token operator">+</span> param_str    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'request url :'</span><span class="token punctuation">,</span> request_url<span class="token punctuation">,</span> <span class="token string">', request ip :'</span><span class="token punctuation">,</span> request_ip<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"statusCode"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">'success.'</span><span class="token punctuation">}</span></code></pre><p>注意，如果用到了其他需安装的依赖的话，需要先将依赖下载到和python文件同个文件夹下</p><pre class=" language-shell"><code class="language-shell">pip install pymsql -t .</code></pre><p>如下，我安装了pymsql的依赖到文件夹中，并将其和python文件一起打成zip包，用于上传到lambda后台<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663135995-fa241d55-774f-4a3a-8baf-acdc1561e52d.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=87&originWidth=261&size=4027&status=done&style=none&width=261" alt="image.png"><br />接着开始上传函数文件，后台支持在线编辑代码，但是由于函数引了其他依赖，故以zip包上传的形式打包上去<br />这里需要注意，处理程序要对应修改，形式为：文件名.方法名<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663678059-be7b88fd-7851-4e2a-b3e9-a1a373c5786a.png#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=1624&size=26931&status=done&style=none&width=1624" alt="image.png"><br /><br><br />上传后效果如下<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663787533-95eb8e9a-4cce-48d2-813a-2418eb03ed25.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&name=image.png&originHeight=586&originWidth=1488&size=70260&status=done&style=none&width=1488" alt="image.png"><br /></p><p><a name="pINrp"></a></p><h3 id="4-配置lambda环境"><a href="#4-配置lambda环境" class="headerlink" title="4. 配置lambda环境"></a>4. 配置lambda环境</h3><p><a name="GuVrW"></a></p><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p>可根据函数实际运行情况，对其分配超时时间和内存<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663814291-ed8334ee-9924-476e-83b6-fbe7318e7a50.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=248&originWidth=814&size=11185&status=done&style=none&width=814" alt="image.png"><br /></p><p><a name="RbgOX"></a></p><h4 id="并发设置"><a href="#并发设置" class="headerlink" title="并发设置"></a>并发设置</h4><p>可默认不改，使用预置并发需要收费<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663878594-1da573f8-941e-401c-abdf-b3f3ed2f1602.png#align=left&display=inline&height=548&margin=%5Bobject%20Object%5D&name=image.png&originHeight=548&originWidth=1596&size=43076&status=done&style=none&width=1596" alt="image.png"><br /></p><p><a name="OBySq"></a></p><h4 id="VPC设置"><a href="#VPC设置" class="headerlink" title="VPC设置"></a>VPC设置</h4><p>当需要调用其他aws服务时，需要配置再同个VPC下<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590663931128-187af22c-fbc8-4b6a-a41a-2a7fd45773cb.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=1642&size=17212&status=done&style=none&width=1642" alt="image.png"><br /></p><p><a name="FrfvT"></a></p><h3 id="5-API-Gateway创建一个API"><a href="#5-API-Gateway创建一个API" class="headerlink" title="5. API Gateway创建一个API"></a>5. API Gateway创建一个API</h3><ul><li>若用到了aws服务，则用REST API，否则可使用HTTP API</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664056048-cf85f66c-6f4f-477f-afae-d24f07ba096e.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=763&size=47464&status=done&style=none&width=763" alt="image.png"></p><ul><li>终端节点类型默认选择区域性，目前仅在一个区域内操作</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664187817-35fc3f99-41d8-4543-b18e-dec83f104548.png#align=left&display=inline&height=553&margin=%5Bobject%20Object%5D&name=image.png&originHeight=553&originWidth=935&size=40197&status=done&style=none&width=935" alt="image.png"><br><a name="xELRF"></a></p><h3 id="6-创建资源和方法"><a href="#6-创建资源和方法" class="headerlink" title="6. 创建资源和方法"></a>6. 创建资源和方法</h3><ul><li>先创建一个get请求的方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664293392-ccccd835-61cb-4d03-8ec1-92c0a216562d.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=442&originWidth=691&size=35170&status=done&style=none&width=691" alt="image.png"></p><ul><li>托管给lambda代理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664340173-05fe4e25-892d-4053-82a9-f4da56c0ff1e.png#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&name=image.png&originHeight=508&originWidth=918&size=26734&status=done&style=none&width=918" alt="image.png"></p><ul><li>再新创建一个资源</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664428852-cf003ceb-216e-4214-a9a5-637937880131.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=720&size=40343&status=done&style=none&width=720" alt="image.png"></p><ul><li>资源主要是对应一个路径参数，如<a href="http://localhost/pets/p，则需要先创建一个资源路径为pets，再创建一个资源路径为p，再在资源p下创建一个方法，用于访问该接口" target="_blank" rel="noopener">http://localhost/pets/p，则需要先创建一个资源路径为pets，再创建一个资源路径为p，再在资源p下创建一个方法，用于访问该接口</a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664452523-f1b8e30c-22b4-4f04-857d-7beef080a5d0.png#align=left&display=inline&height=415&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=1054&size=31713&status=done&style=none&width=1054" alt="image.png"></p><ul><li>最终效果如下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664613111-c9a88799-1a45-44cc-92d0-044daf10e2ac.png#align=left&display=inline&height=561&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1762&size=63494&status=done&style=none&width=1762" alt="image.png"></p><ul><li>可对每个方法进行测试，这里不多讲，主要讲部署</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664646244-9799a21d-afb5-4825-9197-99cb3ff4c23c.png#align=left&display=inline&height=565&margin=%5Bobject%20Object%5D&name=image.png&originHeight=565&originWidth=712&size=43518&status=done&style=none&width=712" alt="image.png"></p><ul><li>部署阶段名称为test，当发布生产时，可改为prod</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664658831-7d4d2e61-79bf-4889-9aa4-d6b0de36a6eb.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=600&size=21600&status=done&style=none&width=600" alt="image.png"></p><ul><li>部署成功，如下，</li></ul><p>访问url：<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test?data=1" target="_blank" rel="noopener">https://****.com/test?data=1</a>，可返回函数内定义的“success”<br />访问url：<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test/pets?data=1" target="_blank" rel="noopener">https://***m/test/pets?data=1</a>，同样可返回“success”<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664761645-44cb4f05-60bb-411f-8ca4-0f66f56adfb7.png#align=left&display=inline&height=745&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1508&size=77565&status=done&style=none&width=1508" alt="image.png"><br /><br><br /></p><p><a name="YGQO9"></a></p><h3 id="7-配置自定义域名"><a href="#7-配置自定义域名" class="headerlink" title="7. 配置自定义域名"></a>7. 配置自定义域名</h3><p>由于API Gateway 仅支持带证书的域名，所以这里我们要部署证书到aws<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590664939795-95c9247a-5466-42ae-b750-627d84fb00d2.png#align=left&display=inline&height=823&margin=%5Bobject%20Object%5D&name=image.png&originHeight=823&originWidth=1581&size=79195&status=done&style=none&width=1581" alt="image.png"><br />我使用的是腾讯云，故在腾讯云申请到免费证书后，上传到ACM后台：<a href="https://us-west-2.console.aws.amazon.com/acm/home?region=us-west-2" target="_blank" rel="noopener">https://us-west-2.console.aws.amazon.com/acm/home?region=us-west-2</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665143414-c869099e-e5b5-43d4-b532-a36c8720facd.png#align=left&display=inline&height=636&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1253&size=47713&status=done&style=none&width=1253" alt="image.png"><br /></p><p><a name="cgASv"></a></p><h3 id="8-域名映射路径"><a href="#8-域名映射路径" class="headerlink" title="8. 域名映射路径"></a>8. 域名映射路径</h3><p>开放接口有：/app/offers/get 和 /offers/get<br><a name="rpGXM"></a></p><h4 id="1-先配置API映射，路径为None"><a href="#1-先配置API映射，路径为None" class="headerlink" title="1. 先配置API映射，路径为None"></a>1. 先配置API映射，路径为None</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590831480790-cb5b3dec-fe08-4c5a-9395-040a0b0d9edd.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=1138&size=13714&status=done&style=none&width=1138" alt="image.png"><br><a name="3T6Tg"></a></p><h4 id="2-在API-内定好资源和方法"><a href="#2-在API-内定好资源和方法" class="headerlink" title="2. 在API 内定好资源和方法"></a>2. 在API 内定好资源和方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590831529725-4f9a134f-0b4e-4bf8-be0d-e876adef1990.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=216&size=6132&status=done&style=none&width=216" alt="image.png"><br /><br><br /><br><br /><del>这里我想实现的是，将原来的<a href="https://elxv6vagga.execute-api.us-west-2.amazonaws.com/test?data=1" target="_blank" rel="noopener">https://****.com/test?data=1</a>，通过自定义域名映射成，<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com?data=1</a></del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665287068-d22a62e2-22e2-4337-a9e0-e43361484313.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1637&size=32241&status=done&style=none&width=1637" alt="image.png"><br /><del>以上配置后发现不生效，只能<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com/test?data=1</a></del><br /><br><br /><del>查看资料发现，aws默认给我们生成的url是有特征的</del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665407264-05a69e95-2a46-4e60-87c7-66191b791f03.png#align=left&display=inline&height=467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=1195&size=60799&status=done&style=none&width=1195" alt="image.png"><br /><del>所以在API映射中，我们是无法做到把stage通过映射关系替代掉的</del><br /><br><br /><del>幸好，后面查阅资料，翻到网友已经找到解决方案了：</del><a href="https://www.stacknoob.com/s/jNBYcCaDDAR5e7Y7GLPHbk" target="_blank" rel="noopener"><del>https://www.stacknoob.com/s/jNBYcCaDDAR5e7Y7GLPHbk</del></a><br /><del>创建API（或使用现有的API，并修改资源）并为其提供代理资源，以及源自根路径的简单GET方法，即可实现自定义域名成功映射，不用被 阶段名state 所影响</del><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665560580-17ee7c74-f2ea-4d61-8a2b-54239687eb47.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image.png&originHeight=404&originWidth=969&size=32201&status=done&style=none&width=969" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1590665658504-b2207ca6-64a5-4b59-8f38-4c88f1a22169.png#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=1751&size=63806&status=done&style=none&width=1751" alt="image.png"><br /><br><br /><del>重新部署，访问<a href="https://custom_domain.com?data=1" target="_blank" rel="noopener">https://custom_domain.com?data=1</a>，即可成功返回“success”</del><br /><del><br /></del><br><a name="gKHWS"></a></p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p><a name="TZoII"></a></p><h3 id="1-Lambda存在函数有一定的约束条件"><a href="#1-Lambda存在函数有一定的约束条件" class="headerlink" title="1. Lambda存在函数有一定的约束条件"></a>1. Lambda存在函数有一定的约束条件</h3><p>参考<a href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/gettingstarted-limits.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/gettingstarted-limits.html</a><br />实际项目中遇到返回的包体字节太大，导致报错，报错原因是因为LAMBDA函数设置的调用负载同步请求是6MB，实际大于6MB。<br />解决方案：参考<a href="https://theburningmonk.com/2020/04/hit-the-6mb-lambda-payload-limit-heres-what-you-can-do/" target="_blank" rel="noopener">https://theburningmonk.com/2020/04/hit-the-6mb-lambda-payload-limit-heres-what-you-can-do/</a></p>]]></content>
      
      
      <categories>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> AWS Lambda </tag>
            
            <tag> AWS APIGateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（九）EventLoop底层原理-3章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-jiu-eventloop-di-ceng-yuan-li-3-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-jiu-eventloop-di-ceng-yuan-li-3-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p>上一章节《Netty挖掘机（八）EventLoop底层原理-2章节》，主要分析了EventLoop的创建流程。其中有一块还没讲到，处理IO事件和队列任务。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>            cancelledKeys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            needsToSelectAgain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> ioRatio <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ioRatio<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ioRatio <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> ioStartTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token keyword">final</span> <span class="token keyword">long</span> ioTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ioStartTime<span class="token punctuation">;</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span>ioTime <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> ioRatio<span class="token punctuation">)</span> <span class="token operator">/</span> ioRatio<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />当轮询到就绪的Channel时，则要开始进行处理I/O事件和执行非I/O操作的队列任务和定时任务。<br /></p><p><a name="fc9348f8"></a></p><h2 id="处理I-O事件"><a href="#处理I-O事件" class="headerlink" title="处理I/O事件"></a>处理I/O事件</h2><blockquote><p>如果有io事件的话，则遍历获取，其中会校验是连接就绪，写就绪或者读就绪。对应方法为<code>processSelectedKeys(</code>)。</p></blockquote><p><br />《EventLoop底层原理-2章节》中提到，在初始化NioEventLoop时，会创建选择器Selector，当判定开启了键集优化时，会通过使用反射将jdk原生Selector的selectedKeys、publicSelectedKeys改为Netty内部定义的SelectedSelectionKeySet。<br /></p><p><a name="346a0075"></a></p><h3 id="1-获取就绪状态的Socket附件"><a href="#1-获取就绪状态的Socket附件" class="headerlink" title="1. 获取就绪状态的Socket附件"></a>1. 获取就绪状态的Socket附件</h3><p><br />回来看处理I/O事件的代码，需要注意当程序启动的时候，内部逻辑是不会触发的，因为未产生就绪事件。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedKeys <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">processSelectedKeysOptimized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">processSelectedKeysPlain</span><span class="token punctuation">(</span>selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />Netty默认开启了键集优化，故<code>selectedKeys</code>不为null，会进入到<code>processSelectedKeysOptimized()</code>。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKeysOptimized</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> selectedKeys<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> SelectionKey k <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// null out entry in the array to allow to have it GC'ed once the Channel close</span>        <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/2363</span>        selectedKeys<span class="token punctuation">.</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">final</span> Object a <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">AbstractNioChannel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token punctuation">(</span>AbstractNioChannel<span class="token punctuation">)</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span> task <span class="token operator">=</span> <span class="token punctuation">(</span>NioTask<span class="token operator">&lt;</span>SelectableChannel<span class="token operator">></span><span class="token punctuation">)</span> a<span class="token punctuation">;</span>            <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needsToSelectAgain<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// null out entries in the array to allow to have it GC'ed once the Channel close</span>            <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/2363</span>            selectedKeys<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">selectAgain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />循环遍历<code>selectedKeys</code>，检索获取Socket附件，判断当前附件类型，<br /><br><br />若是<code>AbstractNioChannel</code>类型，则说明它是<code>NioServerSocketChannel</code> 或者<code>NioSocketChannel</code>（因为我们这里讲的都是TCP，所以排除<code>NioDatagramChannel</code>），此时需要执行I/O事件；<br /><br><br />否则认定它是<code>NioTask</code>类型，由于Netty并未有<code>NioTask</code>的相关实现类，所以这个逻辑片段一般不会执行。<br /></p><p><a name="1bd02ee0"></a></p><h3 id="2-执行I-O事件"><a href="#2-执行I-O事件" class="headerlink" title="2. 执行I/O事件"></a>2. 执行I/O事件</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKey</span><span class="token punctuation">(</span>SelectionKey k<span class="token punctuation">,</span> AbstractNioChannel ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AbstractNioChannel<span class="token punctuation">.</span>NioUnsafe unsafe <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果键集不可用了，则return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> EventLoop eventLoop<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            eventLoop <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// If the channel implementation throws an exception because there is no event loop, we ignore this</span>            <span class="token comment" spellcheck="true">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span>            <span class="token comment" spellcheck="true">// to close ch.</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span>        <span class="token comment" spellcheck="true">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span>        <span class="token comment" spellcheck="true">// still healthy and should not be closed.</span>        <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/5125</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop <span class="token operator">!=</span> <span class="token keyword">this</span> <span class="token operator">||</span> eventLoop <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// close the channel if the key is not valid anymore</span>        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> readyOps <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span>        <span class="token comment" spellcheck="true">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span>            <span class="token comment" spellcheck="true">// See https://github.com/netty/netty/issues/924</span>            <span class="token keyword">int</span> ops <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ops <span class="token operator">&amp;=</span> <span class="token operator">~</span>SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">;</span>            k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>ops<span class="token punctuation">)</span><span class="token punctuation">;</span>            unsafe<span class="token punctuation">.</span><span class="token function">finishConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span>            ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forceFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span>        <span class="token comment" spellcheck="true">// to a spin loop</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>获取Channel的内部类<code>Unsafe</code>；</li><li>判断当前键集是否可用，不可用则调用Unsafe类的close()关闭Channel，释放连接资源，并且立即返回；</li><li>当前键集可用，开始获取网络操作设置位，即获取当前Selector感兴趣的事件<ul><li>连接就绪：TCP连接已经建立。按位与操作追加操作设置位到该键集，并且必须使用unsafe注销到该事件，防止因为selector选择器一直处于无阻塞状态而立即返回，不断循环，可能导致CPU核心利用率到100%，这个和epoll的bug如出一辙；<br><br />对于这个点不太明白其因果关系，猜测是因为如果不注销的话，selector感兴趣的事件会一直是连接就绪，不会触发新的事件，从而导致cpu逐升到100%；</li><li>写就绪：即有发送包未发送完成，此时需要调用forceFlush()进行冲刷发送，冲刷完后一旦没有剩余数据可写，亦会注销写事件；</li><li>读就绪或接收连接就绪：调用read()，接收客户端的TCP连接。并且这里加多了个readyOps为0的条件，是因为Netty为了防止JDK导致的空论询的bug，和连接就绪后注销事件的处理方式相似。</li></ul></li></ul><p><a name="aa2afdc2"></a></p><h2 id="执行非I-O操作的队列任务和周期任务"><a href="#执行非I-O操作的队列任务和周期任务" class="headerlink" title="执行非I/O操作的队列任务和周期任务"></a>执行非I/O操作的队列任务和周期任务</h2><blockquote><p>回顾上一章，我们讲过在初始化事件循环器（线程）时，都维护了一个无锁队列taskQueue，内部堆放了待执行的队列任务；由于实现了ScheduledExecutorService，故还有一个周期任务队列scheduledTaskQueue。<br>这时候就要开始来执行任务了。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> fetchedAll<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        fetchedAll <span class="token operator">=</span> <span class="token function">fetchFromScheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runAllTasksFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ranAtLeastOne <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fetchedAll<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// keep on processing until we fetched all scheduled tasks.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ranAtLeastOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastExecutionTime <span class="token operator">=</span> ScheduledFutureTask<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">afterRunningAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ranAtLeastOne<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>断言判断是否当前线程是否在指定的事件循环器中执行，若false则抛出<code>AssertionError</code>异常；</p></li><li><p>从周期任务队列中取出任务添加到队列任务中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">fetchFromScheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 若周期任务队列为空，则返回true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTaskQueue <span class="token operator">==</span> null <span class="token operator">||</span> scheduledTaskQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">long</span> nanoTime <span class="token operator">=</span> AbstractScheduledEventExecutor<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 从周期队列任务队列中取出任务并返回，并且remove，此举是为了接下来马上执行任务</span>      Runnable scheduledTask <span class="token operator">=</span> <span class="token function">pollScheduledTask</span><span class="token punctuation">(</span>nanoTime<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTask <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 如果任务队列没有空间存放新的任务，则重新添加给周期队列任务</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>taskQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>scheduledTask<span class="token punctuation">)</span><span class="token punctuation">)</span>           scheduledTaskQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> scheduledTask<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>从任务队列中取出任务并执行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">runAllTasksFrom</span><span class="token punctuation">(</span>Queue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Runnable task <span class="token operator">=</span> <span class="token function">pollTaskFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">safeExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>      task <span class="token operator">=</span> <span class="token function">pollTaskFrom</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>从尾部队列中取出任务并执行，对应方法为afterRunningAllTasks()，为什么要执行这个目前还未研究<br><br />// TODO</p></li></ul><p><br />到这里，阿黑已经大致梳理了关于NioEventLoop相关的3个章节的相关源码剖析，接下来将解析ByteBuffer的实现机制。</p><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（八）EventLoop底层原理-2章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-ba-eventloop-di-ceng-yuan-li-2-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-ba-eventloop-di-ceng-yuan-li-2-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p>上一章节《Netty挖掘机（七）EventLoop底层原理-1章节》，主要分析了EventLoopGroup的创建流程，这一章继续讲后续操作，EventLoop的创建。<br /></p><p><a name="IwOIs"></a></p><h1 id="创建NioEventLoop时，发生了什么？"><a href="#创建NioEventLoop时，发生了什么？" class="headerlink" title="创建NioEventLoop时，发生了什么？"></a>创建NioEventLoop时，发生了什么？</h1><p><a name="RR3gQ"></a></p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p><a name="Rarq1"></a></p><h3 id="4-创建带有队列的事件循环器，并打开选择器"><a href="#4-创建带有队列的事件循环器，并打开选择器" class="headerlink" title="4. 创建带有队列的事件循环器，并打开选择器"></a>4. 创建带有队列的事件循环器，并打开选择器</h3><blockquote><p>Netty基于JDK原生NIO做了优化，以此提升了性能。具体优化内容看下面红色字体。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token function">NioEventLoop</span><span class="token punctuation">(</span>NioEventLoopGroup parent<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> SelectorProvider selectorProvider<span class="token punctuation">,</span>                 SelectStrategy strategy<span class="token punctuation">,</span> RejectedExecutionHandler rejectedExecutionHandler<span class="token punctuation">,</span>                 EventLoopTaskQueueFactory queueFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token function">newTaskQueue</span><span class="token punctuation">(</span>queueFactory<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">newTaskQueue</span><span class="token punctuation">(</span>queueFactory<span class="token punctuation">)</span><span class="token punctuation">,</span>          rejectedExecutionHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>selectorProvider <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"selectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>strategy <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"selectStrategy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取selector提供者信息，一般以操作系统做区分，如Linux一般用epoll机制</span>    provider <span class="token operator">=</span> selectorProvider<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打开选择器</span>    <span class="token keyword">final</span> SelectorTuple selectorTuple <span class="token operator">=</span> <span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    selector <span class="token operator">=</span> selectorTuple<span class="token punctuation">.</span>selector<span class="token punctuation">;</span>    unwrappedSelector <span class="token operator">=</span> selectorTuple<span class="token punctuation">.</span>unwrappedSelector<span class="token punctuation">;</span>    selectStrategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="oeoQI"></a></p><h4 id="创建周期任务"><a href="#创建周期任务" class="headerlink" title="创建周期任务"></a>创建周期任务</h4><p><br />回顾上一章的类图，我们可以知道NioEventLoop向上有一个接口是<code>ScheduledExecutorService</code>，即实现了定时任务的相关接口。<br /><br><br />在io.netty.util.concurrent.AbstractScheduledEventExecutor内，已经实现了schedule()，并且在其中创建了周期任务队列并按指定周期执行。<br /></p><pre class=" language-java"><code class="language-java">PriorityQueue<span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> scheduledTaskQueue<span class="token punctuation">;</span>PriorityQueue<span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token function">scheduledTaskQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledTaskQueue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        scheduledTaskQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultPriorityQueue</span><span class="token operator">&lt;</span>ScheduledFutureTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span><span class="token punctuation">(</span>            SCHEDULED_FUTURE_TASK_COMPARATOR<span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// Use same initial capacity as java.util.PriorityQueue</span>            <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> scheduledTaskQueue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="mbwjR"></a></p><h4 id="构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue-可看到"><a href="#构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue-可看到" class="headerlink" title="构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue()可看到"></a>构造的每个事件循环器（线程）还都维护了一个任务队列taskQueue和尾部队列tailTasks，通过newTaskQueue()可看到</h4><p><br />知识点来了，这里用到了JCTools的并发队列，对于JCTools的知识，后续开一篇文章讲解<br /><br><br />MPSC：用于多生产单消费者模式，且支持在多生产时是无锁操作以保证线程安全，同一时刻只支持单一消费者消费。<br /><br><br />为什么不用<code>LinkedBlockingQueue</code> 来做队列呢？<br /><br><br />无锁就是答案了，性能方面比jdk原生队列好太多了，而且Netty本身就是会存在多个生产者同时生产任务，而仅有EventLoop去处理队列中的任务，恰恰MPSC符合该场景。<br /></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// NioEventLoop.java</span><span class="token keyword">private</span> <span class="token keyword">static</span> Queue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">newTaskQueue0</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxPendingTasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This event loop never calls takeTask()</span>    <span class="token comment" spellcheck="true">// 默认采用无参构造方法</span>    <span class="token keyword">return</span> maxPendingTasks <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">?</span> PlatformDependent<span class="token punctuation">.</span>&lt;Runnable<span class="token operator">></span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">:</span> PlatformDependent<span class="token punctuation">.</span>&lt;Runnable<span class="token operator">></span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span>maxPendingTasks<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// PlatformDependent.java</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Queue<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Mpsc<span class="token punctuation">.</span><span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Mpsc.java</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Queue<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newMpscQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> USE_MPSC_CHUNKED_ARRAY_QUEUE <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">MpscUnboundedArrayQueue</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>MPSC_CHUNK_SIZE<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">MpscUnboundedAtomicArrayQueue</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>MPSC_CHUNK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="Fye5b"></a></p><h4 id="打开选择器"><a href="#打开选择器" class="headerlink" title="打开选择器"></a>打开选择器</h4><p>具体流程是：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094744230-420a4bd0-2186-4eb0-a3ae-9ac9cf558386.jpeg#align=left&display=inline&height=509&margin=%5Bobject%20Object%5D&name=open_selector.jpg&originHeight=509&originWidth=1085&size=51709&status=done&style=none&width=1085" alt="open_selector.jpg"><br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> SelectorTuple <span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Selector unwrappedSelector<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 根据系统底层io模型创建一个selector（Windows系统的话这里是WindowsSelectorImpl）</span>        unwrappedSelector <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token function">openSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ChannelException</span><span class="token punctuation">(</span><span class="token string">"failed to open a new selector"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 禁用键集优化，通过io.netty.noKeySetOptimization配置，默认false，即开启优化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>DISABLE_KEY_SET_OPTIMIZATION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SelectorTuple 类似一个持有selector引用的句柄</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用JAVA 安全模型中的特权手段，执行对应的“特权”，这里应该是指尝试获取特权读取java核心库下的class对象</span>    <span class="token comment" spellcheck="true">// 获取SelectorImpl 类对象</span>    Object maybeSelectorImplClass <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>                    <span class="token string">"sun.nio.ch.SelectorImpl"</span><span class="token punctuation">,</span>                    <span class="token boolean">false</span><span class="token punctuation">,</span>                    PlatformDependent<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> cause<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若不是一个class对象 或 不是unwrappedSelector的子类，则直接return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>maybeSelectorImplClass <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token comment" spellcheck="true">// ......</span>        <span class="token comment" spellcheck="true">// 直接返回未经优化selector的SelectorTuple</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> selectorImplClass <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> maybeSelectorImplClass<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化SelectedSelectionKeySet，内部定义了一个SelectionKey数组，长度为1024</span>    <span class="token keyword">final</span> SelectedSelectionKeySet selectedKeySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelectedSelectionKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用“特权”，获取类变量，</span>    Object maybeException <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Object <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Field selectedKeysField <span class="token operator">=</span> selectorImplClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"selectedKeys"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Field publicSelectedKeysField <span class="token operator">=</span> selectorImplClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"publicSelectedKeys"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>PlatformDependent<span class="token punctuation">.</span><span class="token function">javaVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">9</span> <span class="token operator">&amp;&amp;</span> PlatformDependent<span class="token punctuation">.</span><span class="token function">hasUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// jdk9 及以上版本，直接使用Unsafe类底层实现替换</span>                <span class="token punctuation">}</span>                Throwable cause <span class="token operator">=</span> ReflectionUtil<span class="token punctuation">.</span><span class="token function">trySetAccessible</span><span class="token punctuation">(</span>selectedKeysField<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> cause<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                cause <span class="token operator">=</span> ReflectionUtil<span class="token punctuation">.</span><span class="token function">trySetAccessible</span><span class="token punctuation">(</span>publicSelectedKeysField<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cause <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> cause<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 使用反射将jdk原生Selector的selectedKeys、publicSelectedKeys改为Netty内部定义的SelectedSelectionKeySet</span>                selectedKeysField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">;</span>                publicSelectedKeysField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maybeException <span class="token keyword">instanceof</span> <span class="token class-name">Exception</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ......</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    selectedKeys <span class="token operator">=</span> selectedKeySet<span class="token punctuation">;</span>    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"instrumented a special java.util.Set into: {}"</span><span class="token punctuation">,</span> unwrappedSelector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SelectorTuple</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span>                             <span class="token keyword">new</span> <span class="token class-name">SelectedSelectionKeySetSelector</span><span class="token punctuation">(</span>unwrappedSelector<span class="token punctuation">,</span> selectedKeySet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="U3Rxc"></a></p><h3 id="5-执行NioEventLoop的run"><a href="#5-执行NioEventLoop的run" class="headerlink" title="5. 执行NioEventLoop的run()"></a>5. 执行NioEventLoop的run()</h3><blockquote><p><strong>这是整一块体中最核心的方法！</strong><br>尝试启动有且仅有一个Eventloop线程（如果当前线程非Eventloop线程的话），并在程序运行期间死循环执行NioEventLoop的run()，检测当前队列中是否有任务要执行。</p></blockquote><p><br />执行run()的入口是SingleThreadEventExecutor的execute()，哪里触发execute()的执行？<br /><br><br />在Bootstrap绑定端口时，会初始化注册channel到EventLoop内，并且开始执行EventLoop的execute()；在连接进来时，数据写到Channel，触发执行EventLoop的execute()；在处理好连接并返回时，注销，触发执行EventLoop的execute()。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094818411-c7caeebf-a495-49ea-9048-57ffa957c023.jpeg#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&name=debug.jpg&originHeight=303&originWidth=392&size=21490&status=done&style=none&width=392" alt="debug.jpg">)<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094819754-98c9a687-5732-45c2-8a64-553a26ae11ba.jpeg#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=debug2.jpg&originHeight=301&originWidth=389&size=20406&status=done&style=none&width=389" alt="debug2.jpg">)<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094821128-a97dc731-8bf1-42cc-a8b4-7bae0083ed5b.jpeg#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=debug3.jpg&originHeight=298&originWidth=393&size=21082&status=done&style=none&width=393" alt="debug3.jpg"><br /><br><br />下面先看下run()涉及的一个流程图，理清下思路<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094829054-52adb1c8-ba13-41a9-b287-166afdfbab77.jpeg#align=left&display=inline&height=494&margin=%5Bobject%20Object%5D&name=eventloop_run.jpg&originHeight=494&originWidth=909&size=46758&status=done&style=none&width=909" alt="eventloop_run.jpg"><br /></p><p><a name="rNeFe"></a></p><h4 id="执行器开始执行"><a href="#执行器开始执行" class="headerlink" title="执行器开始执行"></a>执行器开始执行</h4><p><br />翻阅代码后，最终的execute()执行在<code>io.netty.util.concurrent.SingleThreadEventExecutor</code>内。<br /><br><br />过程主要是添加任务到队列，启动线程，轮询，执行任务<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断当前线程是否事件循环线程</span>    <span class="token keyword">boolean</span> inEventLoop <span class="token operator">=</span> <span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加任务到MPSC任务队列中</span>    <span class="token function">addTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若非事件循环线程，则执行开启事件循环线程逻辑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inEventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 通过Unsafe，将当前标识的线程状态从未启动变为已启动，并new线程，在线程内执行NioEventLoop的run()</span>        <span class="token function">startThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// inEventLoop为false，并且线程状态为shuttingdown，则唤醒以解除线程阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>addTaskWakesUp <span class="token operator">&amp;&amp;</span> <span class="token function">wakesUpForTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span>inEventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="h72m7"></a></p><h4 id="事件循环器轮询队列任务"><a href="#事件循环器轮询队列任务" class="headerlink" title="事件循环器轮询队列任务"></a>事件循环器轮询队列任务</h4><p><br />NioEventLoop本质上就是一个单线程去执行特定的任务，所以它的run()，我们需要留意。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 死循环，直到线程shutdown</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">switch</span> <span class="token punctuation">(</span>selectStrategy<span class="token punctuation">.</span><span class="token function">calculateStrategy</span><span class="token punctuation">(</span>selectNowSupplier<span class="token punctuation">,</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>CONTINUE<span class="token operator">:</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 不属于NIO的范畴，它不支持繁忙等待</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>BUSY_WAIT<span class="token operator">:</span>                    <span class="token keyword">case</span> SelectStrategy<span class="token punctuation">.</span>SELECT<span class="token operator">:</span>                        <span class="token function">select</span><span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            selector<span class="token punctuation">.</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 若出现IOException，则重新建立选择器</span>                <span class="token function">rebuildSelector0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">handleLoopException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cancelledKeys <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            needsToSelectAgain <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> ioRatio <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ioRatio<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ioRatio <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">long</span> ioStartTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">processSelectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Ensure we always run tasks.</span>                    <span class="token keyword">final</span> <span class="token keyword">long</span> ioTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> ioStartTime<span class="token punctuation">;</span>                    <span class="token function">runAllTasks</span><span class="token punctuation">(</span>ioTime <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> ioRatio<span class="token punctuation">)</span> <span class="token operator">/</span> ioRatio<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取消通道在Selector上的注册，关闭通道，并让NioEventLoop线程退出循环，结束运行...</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isShuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">closeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">confirmShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />文字流程如下：<br /></p><ul><li>Selector轮询检测。检测到队列中有任务，则当即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，若有通道准备（进行I/O操作）就绪则返回数&gt;0；检测到队列中没有任务，则直接返回-1，并调用select(wakenUp.getAndSet(false))；</li><li>获取ioRatio，即io比率。默认50，通过io比率可以控制执行任务的时长；</li><li>处理io事件。对应方法为processSelectedKeys()。如果有io事件的话，则遍历获取，其中会校验是连接就绪，写就绪或者读就绪；</li><li>运行队列任务。对应方法为runAllTasks()。如果io比率=100，则不限制任务的执行时长，确保执行完所有任务；否则通过io比率折算出时长，执行任务超过该时长则退出！</li></ul><p><a name="GnIF5"></a></p><h4 id="任务队列上未有任务，执行Netty的select"><a href="#任务队列上未有任务，执行Netty的select" class="headerlink" title="任务队列上未有任务，执行Netty的select"></a>任务队列上未有任务，执行Netty的select</h4><p><br />当检测到任务队列上未有任务时，会执行select(wakenUp.getAndSet(false));<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> oldWakenUp<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Selector selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> selectCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> currentTimeNanos <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> selectDeadLineNanos <span class="token operator">=</span> currentTimeNanos <span class="token operator">+</span> <span class="token function">delayNanos</span><span class="token punctuation">(</span>currentTimeNanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> timeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span>selectDeadLineNanos <span class="token operator">-</span> currentTimeNanos <span class="token operator">+</span> 500000L<span class="token punctuation">)</span> <span class="token operator">/</span> 1000000L<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timeoutMillis <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果先将wakeUp设置为true再有任务提交，此时必须会导致任务挂起，直到select操作超时（或者管道中存在IdleStateHandler，则要等到空闲超时）；所以在执行Selector.select操作之前，需再次检查任务队列！</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> wakenUp<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>            selectCnt <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedKeys <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> oldWakenUp <span class="token operator">||</span> wakenUp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasScheduledTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely because "</span> <span class="token operator">+</span>                                 <span class="token string">"Thread.currentThread().interrupt() was called. Use "</span> <span class="token operator">+</span>                                 <span class="token string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// epoll 空论询的检测逻辑代码</span>            <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">-</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span> <span class="token operator">>=</span> currentTimeNanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// timeoutMillis elapsed without anything selected.</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                       selectCnt <span class="token operator">>=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>                selector <span class="token operator">=</span> <span class="token function">selectRebuildSelector</span><span class="token punctuation">(</span>selectCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            currentTimeNanos <span class="token operator">=</span> time<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>selectCnt <span class="token operator">></span> MIN_PREMATURE_SELECTOR_RETURNS<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Selector.select() returned prematurely {} times in a row for Selector {}."</span><span class="token punctuation">,</span>                             selectCnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> selector<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>CancelledKeyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" raised by a Selector {} - JDK bug?"</span><span class="token punctuation">,</span>                         selector<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />文字流程如下<br /></p><ol><li>获得当前时间，加上即将执行定时任务的剩余时间，得到Selector执行的“预计”剩余时间selectDeadLineNanos；</li><li>selectDeadLineNanos减当前时间，加上0.5ms的缓冲值，再除以1ms得到的Selector.select的阻塞超时时间timeoutMillis</li><li>当timeoutMillis  &lt;= 0，说明定时任务准备执行了！（如果是第一次进方法，此时立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量），接着退出方法体；</li><li>若当前队列有任务，并且wakeUp通过cas设置为true，此时立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，接着退出方法体；（为什么要做这一步，代码注释已声明）</li><li>执行Select.select(timeoutMillis)，会一直阻塞直到超时，这里调用的是JDK原生的select；</li><li>执行select后，如果Selector被唤醒，或者队列有任务，或者定时任务开始执行，则退出方法体  ；</li><li>由于程序处理中可能出现错误，而导致线程被中断，此时Netty帮我们做了处理，记录日志，并退出方法体 ；</li><li>重点来了，当select实际的阻塞时间&lt;timeoutMillis，并且计数器selectCnt&gt;=SELECTOR_AUTO_REBUILD_THRESHOLD，即循环超过了重试次数阈值（默认512），则Netty认为JDK触发了epoll空论询的bug，于是重建选择器，并立即唤醒Selector，执行selectNow()并立即返回就绪的channel 数量，接着退出方法体；</li><li>退出方法体后，继续执行后续的处理I/O事件和执行队列任务；</li></ol><p><a name="D8jrw"></a></p><h4 id="处理IO事件和队列任务"><a href="#处理IO事件和队列任务" class="headerlink" title="处理IO事件和队列任务"></a>处理IO事件和队列任务</h4><p><br />这一块，等下一篇章继续讲解！<br /></p><p><a name="p9SwR"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a name="7SleK"></a></p><h2 id="Netty中是如何结合事件模型使用NIO同步非阻塞的特性"><a href="#Netty中是如何结合事件模型使用NIO同步非阻塞的特性" class="headerlink" title="Netty中是如何结合事件模型使用NIO同步非阻塞的特性"></a>Netty中是如何结合事件模型使用NIO同步非阻塞的特性</h2><ul><li>回顾BIO模型，由于单线程无法更好地利用CPU，socket的读写函数无法立即返回于是有了多线程，即一个请求对应一个处理线程，但还是同步阻塞的IO，发起请求同步，实际的IO操作阻塞，且线程的利用率非常地高，在海量请求下不切实际；</li><li>回到NIO，得益于Buffer、Channel、Selector三个组件，socket的读写函数可以立即返回。发起请求仍是同步，实际的I/O操作是非阻塞，它把数据交给Channel，进而有一个特定的线程去执行I/O操作。实现了“不用多开线程利用CPU”。<br><br />如何使用事件模型单线程处理所有I/O请求？<br><br />在NIO中主要有三个事件：连接就绪、读就绪、写就绪。首先需要注册这几个事件就绪时对应的处理器，接着用一个单线程死循环执行Selector.select 阻塞式地检测Channel的事件状态，等待并获取就绪事件的到来，当就绪事件到来时，告诉事件处理器。</li><li>来到Netty，在NIO的基础上，增加了Eventloop事件循环器，对原生Selector做了增强，不仅仅是一个死循环这么简单，在线程中断等用户行为错误、epoll空论询bug、适时唤醒Selector上下了很多功夫。还增加了JCTools 的无界队列MPSCQueue来存放待执行任务。</li></ul><p><a name="dBSB9"></a></p><h2 id="Netty解决了JDK的哪些bug"><a href="#Netty解决了JDK的哪些bug" class="headerlink" title="Netty解决了JDK的哪些bug"></a>Netty解决了JDK的哪些bug</h2><blockquote><p>在EventLoop的创建和执行过程中，Netty主要解决了哪些JDK的bug？</p></blockquote><ul><li>Netty优化JDK原生的Selector<br><br />通过Unsafe类或反射，去改动SelectorImpl中的变量值，如下，将数据结构从HashSet改为了数组，解决了遍历效率、HashSet因为扩容而带来的性能问题。</li></ul><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> selectedKeys<span class="token punctuation">;</span>Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> publicSelectedKeys</code></pre><ul><li>Netty解决了JDK NIO 中 臭名昭著的epoll空轮询的bug<br><br />回顾之前《Netty挖掘机（一）初识Java Nio》，里面写到了如何用JAVA NIO 来写服务端应用</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 阻塞，获取已就绪的key个数</span>        <span class="token keyword">int</span> wait <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wait <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取所有的事件key</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> readykeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> readykeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移除已处理数据</span>            iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 处理逻辑</span>            <span class="token function">process</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>在原生JDK NIO中，Selector.select()默认会一直阻塞直到有就绪事件进来。然而却可能出现没有任何就绪事件就直接返回，导致select外层的循环不断执行，最终导致服务器的CPU核心利用率飙涨到100%，即epoll空论询的bug，这是Linux系统下所导致的，不知最新版本是否处理了这个问题？<br><br />而在Netty中，实现了自定义的一个select方法，同样它会调用原生的Selector.select()，但是它做了向上增强的检测机制：<ul><li>检查实际超时时间是否小于预设超时时间；</li><li>检查循环次数是否超过设定重试次数阈值；</li><li>重建选择器</li></ul></li></ul><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（七）EventLoop底层原理-1章节</title>
      <link href="/2020/06/02/netty-wa-jue-ji-qi-eventloop-di-ceng-yuan-li-1-zhang-jie/"/>
      <url>/2020/06/02/netty-wa-jue-ji-qi-eventloop-di-ceng-yuan-li-1-zhang-jie/</url>
      
        <content type="html"><![CDATA[<p><a name="93tFv"></a></p><h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><blockquote><p>顾名思义，事件循环。在前面的文章已经讲到，NIO内部使用了Reactor模型，而Reactor模型的核心就是事件驱动。事件驱动中就有这么一个事件循环器在工作。<br>接下来我们开始从源码入手，了解Netty的EventLoop的机制。</p></blockquote><p><a name="M68ke"></a></p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><br />首先，我们先看下相关类图，主要有两个关键类：<code>NioEventLoop</code>和<code>NioEventLoopGroup</code>。类图可以看到<br /></p><ul><li>最顶层接口是Executor，即线程执行器，提供了execute()在将来执行某个task；</li><li>ExecutorService，即真正的线程池接口，继承了Executor，封装了更多的方法，如submit()提交任务后可回传结果；</li><li><code>NioEventLoop</code>继承了抽象基类<code>SingleThreadEventLoop</code>，在单线程中执行所有已提交的任务；</li><li><code>NioEventLoopGroup</code>继承了抽象基类<code>MultithreadEventLoopGroup</code>，可同时处理多个线程的任务</li></ul><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094002448-df99c196-2c67-49f9-b6dd-63b9b634acd9.jpeg#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=class_diagram.jpg&originHeight=699&originWidth=926&size=26782&status=done&style=none&width=926" alt="class_diagram.jpg"><br /></p><p><a name="9SLRH"></a></p><h1 id="创建NioEventLoopGroup时，发生了什么？"><a href="#创建NioEventLoopGroup时，发生了什么？" class="headerlink" title="创建NioEventLoopGroup时，发生了什么？"></a>创建NioEventLoopGroup时，发生了什么？</h1><p><a name="tKIyL"></a></p><h2 id="首先先看下简化后的流程图"><a href="#首先先看下简化后的流程图" class="headerlink" title="首先先看下简化后的流程图"></a>首先先看下简化后的流程图</h2><blockquote><p>初始化NioEventLoopGroup时，通过指定线程数，创建N个NioEventLoop执行器。</p></blockquote><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591094012869-c44b018c-b60f-4769-9bb0-c9e3b78e4375.jpeg#align=left&display=inline&height=616&margin=%5Bobject%20Object%5D&name=process.jpg&originHeight=616&originWidth=980&size=48925&status=done&style=none&width=980" alt="process.jpg"><br /></p><p><a name="77fGY"></a></p><h2 id="回到代码开发中"><a href="#回到代码开发中" class="headerlink" title="回到代码开发中"></a>回到代码开发中</h2><blockquote><p>我们在服务端的开发中，通常会引入两个独立的事件循环组，相当于两个Reactor线程池，一个boss用于accept连接，一个worker用于handle IO操作。只是两行代码，里面就做了足够多的逻辑。这两个组怎么创建得来呢？让我们从源码入手瞧一瞧。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="NXeqN"></a></p><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><p><a name="2wnx7"></a></p><h3 id="1-调用NioEventLoopGroup的构造方法"><a href="#1-调用NioEventLoopGroup的构造方法" class="headerlink" title="1. 调用NioEventLoopGroup的构造方法"></a>1. 调用<code>NioEventLoopGroup</code>的构造方法</h3><blockquote><p>在这里会先获取操作系统对应的实现NIO的方式。Linux2.6内核引入了epoll，替代了select和poll机制</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这里的nThreads默认为0</span><span class="token keyword">public</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> SelectorProvider<span class="token punctuation">.</span><span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />这里看到SelectorProvider类<br /></p><blockquote><p><code>SelectorProvider</code>类通过open*等方法，创建Selector、SocketChannel、ServerSocketChannel等。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>provider <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> provider<span class="token punctuation">;</span>        <span class="token keyword">return</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>            <span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>SelectorProvider<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> SelectorProvider <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ......</span>                    provider <span class="token operator">=</span> sun<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ch<span class="token punctuation">.</span>DefaultSelectorProvider<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> provider<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />对应不同的操作系统，<code>DefaultSelectorProvider</code>类有不同的Selector实现机制（SPI机制的体现）。<br /><br><br />Windows系统采用 IOCP机制（java8）<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSelectorProvider</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">DefaultSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />Linux系统采用了Epoll机制（java8）<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSelectorProvider</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">createProvider</span><span class="token punctuation">(</span>String paramString<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//......</span>      <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SelectorProvider <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GetPropertyAction</span><span class="token punctuation">(</span><span class="token string">"os.name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"SunOS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token function">createProvider</span><span class="token punctuation">(</span><span class="token string">"sun.nio.ch.DevPollSelectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Linux"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token function">createProvider</span><span class="token punctuation">(</span><span class="token string">"sun.nio.ch.EPollSelectorProvider"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PollSelectorProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="1V7Ws"></a></p><h3 id="2-调用父类MultithreadEventLoopGroup的构造方法"><a href="#2-调用父类MultithreadEventLoopGroup的构造方法" class="headerlink" title="2. 调用父类MultithreadEventLoopGroup的构造方法"></a>2. 调用父类<code>MultithreadEventLoopGroup</code>的构造方法</h3><blockquote><p>在这里主要是初始化EventLoop的线程数量。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> SelectorProvider selectorProvider<span class="token punctuation">,</span> SelectStrategyFactory selectStrategyFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> selectorProvider<span class="token punctuation">,</span> selectStrategyFactory<span class="token punctuation">,</span>RejectedExecutionHandlers<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="l31ax"></a></p><h4 id="查看父类"><a href="#查看父类" class="headerlink" title="查看父类"></a>查看父类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultithreadEventLoopGroup</span> <span class="token keyword">extends</span> <span class="token class-name">MultithreadEventExecutorGroup</span> <span class="token keyword">implements</span> <span class="token class-name">EventLoopGroup</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> InternalLogger logger <span class="token operator">=</span> InternalLoggerFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>MultithreadEventLoopGroup<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> NettyRuntime<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果线程数为0，则设定为一个由final定义的不可变常量</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> DEFAULT_EVENT_LOOP_THREADS <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当传入的线程数为0时，系统会主动分配一个默认线程数量<code>DEFAULT_EVENT_LOOP_THREADS</code>，若程序设置了系统属性<code>io.netty.eventLoopThreads</code>则用该值；若设置了系统属性<code>io.netty.availableProcessors</code>则用该值 _ 2；否则返回可用于Java虚拟机的处理器数量 _ 2；源码合并如下<br /></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 存在属性值io.netty.eventLoopThreads 则取，否则走下一步</span>SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"io.netty.eventLoopThreads"</span><span class="token punctuation">,</span> NettyRuntime<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NettyRuntime</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AvailableProcessorsHolder holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AvailableProcessorsHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AvailableProcessorsHolder</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@SuppressForbidden</span><span class="token punctuation">(</span>reason <span class="token operator">=</span> <span class="token string">"to obtain default number of available processors"</span><span class="token punctuation">)</span>        <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>availableProcessors <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用final保证结果不可变，存在属性值io.netty.availableProcessor则取，否则获取当前虚拟机的处理器数量</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> availableProcessors <span class="token operator">=</span>                        SystemPropertyUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>                                <span class="token string">"io.netty.availableProcessors"</span><span class="token punctuation">,</span>                                Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">setAvailableProcessors</span><span class="token punctuation">(</span>availableProcessors<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>availableProcessors<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> holder<span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="S0wTi"></a></p><h3 id="3-调用父类MultithreadEventExecutorGroup的构造方法"><a href="#3-调用父类MultithreadEventExecutorGroup的构造方法" class="headerlink" title="3. 调用父类MultithreadEventExecutorGroup的构造方法"></a>3. 调用父类<code>MultithreadEventExecutorGroup</code>的构造方法</h3><blockquote><p>在这里主要是遍历获取事件循环器对象。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token function">MultithreadEventExecutorGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// DefaultEventExecutorChooserFactory.INSTANCE：默认事件执行器选择器工厂</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> executor<span class="token punctuation">,</span> DefaultEventExecutorChooserFactory<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token function">MultithreadEventExecutorGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> Executor executor<span class="token punctuation">,</span>                                            EventExecutorChooserFactory chooserFactory<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// A. 创建每个任务执行程序的线程</span>        executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token function">newDefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新建事件执行器数组，指定长度；开始遍历拿到执行器对象</span>    children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventExecutor</span><span class="token punctuation">[</span>nThreads<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nThreads<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// B. 调用派生类NioEventLoopGroup的newChild()，得到一个事件循环器对象</span>            children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newChild</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO: Think about if this is a good exception type</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"failed to create a child event loop"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// C. 新建选择器</span>    chooser <span class="token operator">=</span> chooserFactory<span class="token punctuation">.</span><span class="token function">newChooser</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// D. 创建监听器，并遍历添加到事件执行器中</span>    <span class="token keyword">final</span> FutureListener<span class="token operator">&lt;</span>Object<span class="token operator">></span> terminationListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureListener</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ......</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>EventExecutor e<span class="token operator">:</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">terminationFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>terminationListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 去重，并返回只读集合</span>    Set<span class="token operator">&lt;</span>EventExecutor<span class="token operator">></span> childrenSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>EventExecutor<span class="token operator">></span><span class="token punctuation">(</span>children<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    Collections<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>childrenSet<span class="token punctuation">,</span> children<span class="token punctuation">)</span><span class="token punctuation">;</span>    readonlyChildren <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableSet</span><span class="token punctuation">(</span>childrenSet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="mlZKe"></a></p><h4 id="A-创建每个任务执行程序的线程"><a href="#A-创建每个任务执行程序的线程" class="headerlink" title="A. 创建每个任务执行程序的线程"></a>A. 创建每个任务执行程序的线程</h4><ul><li>获取默认的线程工厂实例</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> ThreadFactory <span class="token function">newDefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>线程工厂的构造逻辑</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// priority: 线程优先级，默认Thread.NORM_PRIORITY = 5</span><span class="token comment" spellcheck="true">// daemon: 是否守护线程，这里为false</span><span class="token comment" spellcheck="true">// threadGroup: 线程组</span><span class="token comment" spellcheck="true">// poolName: 线程池名称</span><span class="token keyword">public</span> <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span>String poolName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> daemon<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">,</span> ThreadGroup threadGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//......</span>    prefix <span class="token operator">=</span> poolName <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> poolId<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>daemon <span class="token operator">=</span> daemon<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">=</span> priority<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadGroup <span class="token operator">=</span> threadGroup<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> <span class="token function">newThread</span><span class="token punctuation">(</span>FastThreadLocalRunnable<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> prefix <span class="token operator">+</span> nextId<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> daemon<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>daemon<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> priority<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Doesn't matter even if failed to set.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>构造<code>ThreadPerTaskExecutor</code>，传入线程工厂，得到Executor线程执行器对象</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPerTaskExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ThreadFactory threadFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPerTaskExecutor</span><span class="token punctuation">(</span>ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 传入线程工厂</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadFactory <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"threadFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 调用线程工厂的newThread()新建一个线程，并启动</span>        threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">.</span>sta<span class="token operator">=</span><span class="token function">rt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="iWl9n"></a></p><h4 id="B-调用派生类NioEventLoopGroup的newChild"><a href="#B-调用派生类NioEventLoopGroup的newChild" class="headerlink" title="B. 调用派生类NioEventLoopGroup的newChild()"></a>B. 调用派生类NioEventLoopGroup的newChild()</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioEventLoopGroup</span> <span class="token keyword">extends</span> <span class="token class-name">MultithreadEventLoopGroup</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> EventLoop <span class="token function">newChild</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        EventLoopTaskQueueFactory queueFactory <span class="token operator">=</span> args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">?</span> <span class="token punctuation">(</span>EventLoopTaskQueueFactory<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoop</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> executor<span class="token punctuation">,</span> <span class="token punctuation">(</span>SelectorProvider<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>SelectStrategyFactory<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newSelectStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>RejectedExecutionHandler<span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queueFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />重点来了，这里新建了NioEventLoop事件循环器对象，相当于一个线程，也就是事件驱动思想。<br /></p><p><a name="Ec3w6"></a></p><h4 id="C-新建选择器"><a href="#C-新建选择器" class="headerlink" title="C. 新建选择器"></a>C. 新建选择器</h4><blockquote><p>选择器是用于从事件循环组中选取一个事件循环器，将连接注册到事件循环器中</p></blockquote><p><br />这里用了策略模式，若执行器数量是2的指数倍，则返回PowerOfTwoEventExecutorChooser，否则返回同样的实例 GenericEventExecutorChooser.<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> EventExecutorChooser <span class="token function">newChooser</span><span class="token punctuation">(</span>EventExecutor<span class="token punctuation">[</span><span class="token punctuation">]</span> executors<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>executors<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PowerOfTwoEventExecutorChooser</span><span class="token punctuation">(</span>executors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">GenericEventExecutorChooser</span><span class="token punctuation">(</span>executors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p>Ending……<br /><br><br />阿黑在下一章节继续分析Eventloop！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（六）什么是Reactor_IO_Style</title>
      <link href="/2020/06/02/netty-wa-jue-ji-liu-shi-me-shi-reactor-io-style/"/>
      <url>/2020/06/02/netty-wa-jue-ji-liu-shi-me-shi-reactor-io-style/</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章讲解的内容都是偏向表面，比如介绍了JAVA NIO，Netty的实现流程，实现一套基于Spring+Netty的API服务模块等。 接下来开始深入挖掘，汲取Netty底层的设计思想和引用的优秀的框架、原理等。</p><blockquote><p>总之，拭目以待吧！</p></blockquote><p><a name="70f1fd3b"></a></p><h2 id="Reactor模型（反应堆模型）"><a href="#Reactor模型（反应堆模型）" class="headerlink" title="Reactor模型（反应堆模型）"></a>Reactor模型（反应堆模型）</h2><blockquote><p>谈到Netty，Nio，就绕不开一个IO模型：Reactor Pattern。维基百科介绍“ The reactor <a href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" target="_blank" rel="noopener">design pattern</a> is an <a href="https://en.wikipedia.org/wiki/Event_handling" target="_blank" rel="noopener">event handling</a> pattern for handling service requests delivered <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" target="_blank" rel="noopener">concurrently</a> to a service handler by one or more inputs.  The service handler then <a href="https://en.wikipedia.org/wiki/Demultiplex" target="_blank" rel="noopener">demultiplexes</a> the incoming requests and dispatches them synchronously to the associated request handlers ”。</p></blockquote><p><br />即，Reactor模型的特性是：</p><ul><li>可处理同时多个请求</li><li>service handler可将传入的请求进行多路拆分，同步分发到对应的处理逻辑</li><li>事件驱动架构</li></ul><p><a name="ec6db9ae"></a></p><h3 id="什么是事件驱动？"><a href="#什么是事件驱动？" class="headerlink" title="什么是事件驱动？"></a>什么是事件驱动？</h3><blockquote><p>事件驱动（ Event-driven architecture，也叫EDA）是一种编程范式，用于生成高度可扩展的应用程序。</p></blockquote><p><br />事件驱动下的系统，程序的执行由外部事件决定。基本的架构思想是设计一个事件循环（Event Loop）所形成的程序，这个事件循环程序不断检测当前需要处理的消息，根据消息触发一个对应的动作/函数进行处理。这个消息可能来源于人为动作、程序动作、时间动作。<br /></p><p><a name="8640d52e"></a></p><h3 id="什么是I-O多路复用？"><a href="#什么是I-O多路复用？" class="headerlink" title="什么是I/O多路复用？"></a>什么是I/O多路复用？</h3><blockquote><p>操作系统内核提供一个功能，通过select、poll、epoll、kqueue之类的系统函数，监视进程指定的一个或多个IO处于就绪 or 读 or 写事件时，通知该进程。此举可减少系统创建线程的开销。</p></blockquote><ul><li>只有当系统通知进程哪个句柄可读，才去执行read操作；哪个句柄可写，才去执行write操作，在提升效率的同时，减少了无用功；</li><li>多个句柄在同一个线程内并发交替地按序完成；</li><li>多路复用遵循多对一的方式，即n条输入线和1条输出线；</li><li>执行多路复用的设备称为多路复用器（MUX），执行反向处理的设备称为解复用器</li></ul><p><a name="3fd5cb6b"></a></p><h3 id="它的思路是"><a href="#它的思路是" class="headerlink" title="它的思路是"></a>它的思路是</h3><ol><li>在基于Reactor模型的应用中，引入了一个单独的请求处理程序来处理这种类型的请求；</li><li>传入的请求被注册并排队等待处理，解复用or分配的任务通常在事件循环（Event Loop）中完成；</li><li>而事件循环在单线程中运行，检测事件发生的时机，这里表明无需阻塞调用，可以直接使用基础资源；</li><li>例如这些事件是在网络连接可用或文件准备从磁盘或网络读取等情况下，事件循环会将事件分派到关联的请求处理程序（Workers）；</li><li>该请求的整个操作以异步非阻塞方式执行；</li><li>从Client发起请求开始，即产生了事件，此时并没有用队列作为缓冲，而是直接通过service handler根据不同的事件类型进行分发。</li></ol><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093908390-a0dee3d2-d6fe-4b75-8a6f-8eb20219ca26.jpeg#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=model.jpg&originHeight=440&originWidth=841&size=81581&status=done&style=none&width=841" alt="model.jpg"><br /></p><p><a name="b6239956"></a></p><h3 id="它的架构是"><a href="#它的架构是" class="headerlink" title="它的架构是"></a>它的架构是</h3><blockquote><p>tips：参考文章最底的学术文章链接</p></blockquote><p><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093918897-7d822953-c442-4faf-aaa2-fc7316fa649f.jpeg#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=class_diagram.jpg&originHeight=436&originWidth=664&size=87008&status=done&style=none&width=664" alt="class_diagram.jpg"><br /></p><p><a name="ba88bcc6"></a></p><h4 id="参与者："><a href="#参与者：" class="headerlink" title="参与者："></a>参与者：</h4><ul><li><p>Handle<br><br />即句柄（也可以叫描述符），标识由操作系统管理的资源。这种资源可以是一个网络连接（网络句柄），打开文件（文件句柄）等。在网络编程中，一般是socket句柄，即一个网络连接。一个连接进来，便注册到多路分解器（Synchronous Event Demultiplexer）中，以监听Handle中发生的事件</p><blockquote><p>什么是句柄？<br>类似于Linux中的文件描述符，在Windows中主要用来标识所有资源，例如一个窗口、按钮、图标、字体等等。<br>它像指针，但是它不同于指针。<br>句柄是系统所管理的引用标识,该标识可被系统定位到一块内存地址上，通过句柄可以访问内核对象。它内部已经封装好了对应的操作逻辑，有一张句柄表的玩意，我们使用句柄局限在特定范围内（所以这种间接访问对象的方式，显示出了系统对于引用资源的控制）；<br>而指针是包含引用对象的内存地址，是指向一块内存的指针,它没有封装对应的操作逻辑，我们可以自由发挥地操作它。</p></blockquote></li><li><p>Synchronous Event Demultiplexer<br><br />多路分解器。监听并阻塞直到Handle（句柄）中的事件发生，若阻塞返回，则无阻塞地执行返回的事件类型对应的处理。一般使用的解复用器是select，Linux2.6内核中提出了epoll，在JAVA NIO中用了Selector做封装。<br><br />//TODO 后续针对epoll、select、poll做一篇文章理解）</p></li><li><p>Initiation Dispatcher<br><br />启动调度程序。定义用于注册、删除和分派事件处理程序的接口。<br><br />当同步事件多路分解器检测到新事件时，通知启动调度程序（Initiation Dispatcher）回调特定于应用的事件处理程序。<br><br />常见的事件有连接就绪、读、写、超时事件。</p></li><li><p>Event Handler<br><br />事件处理器。定义事件的处理方法handle_event()，该方法抽象地表示特定于服务的事件调度操作。主要是给启动调度程序使用。</p></li><li><p>Concrete Event Handler<br><br />具体事件处理器，也可以说是逻辑处理器，是事件处理器接口的实现。实现特定事件的处理方法，应用向启动调度程序（Initiation Dispatcher）注册具体事件处理器，告知处理某些类型的事件。当事件到达时，启动调度程序（Initiation Dispatcher）会回调具体的逻辑处理方法。<br><br />比如一个网关服务中有一个具体事件处理器：参数处理程序，用于接收和过滤非法的参数。</p></li></ul><p><a name="f630b9a4"></a></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1591093931408-4c368689-863b-4c88-b53e-94d243d3ea77.jpeg#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=flow_chart.jpg&originHeight=238&originWidth=464&size=26767&status=done&style=none&width=464" alt="flow_chart.jpg"><br /><br><br />流程：<br /></p><ol><li>应用将具体事件处理程序（器）注册到启动调度程序，告知程序这个handler要处理哪种event， 每个EventHandler包含对相应Handle的引用 ;</li><li>启动调度程序请求每个事件处理程序，传回其内部句柄，该句柄向OS标识事件处理程序；</li><li>注册完所有事件处理程序后， 应用程序将调用处理事件，以启用事件循环（EventLoop），启动调度程序将来自每个已注册的事件处理程序的句柄进行组合，调用同步事件多路分解器的select()阻塞直到事件发生在这些句柄上；</li><li>当对应事件源的句柄变成“就绪”时（即某个或某些句柄的event发生后），比如TCP套接字已“就绪以供读取”，此时触发select()返回，通知启动调度程序；</li><li>启动调度程序响应事件处理程序上的的钩子方法，即执行对应的Event Handler来处理event。</li></ol><p><a name="af267e91"></a></p><h3 id="Reactor模型的优缺点"><a href="#Reactor模型的优缺点" class="headerlink" title="Reactor模型的优缺点"></a>Reactor模型的优缺点</h3><p><a name="52b8c184"></a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>异步非阻塞I/O。发起I/O请求非阻塞，实际的I/O操作交给了事件线程异步处理；</li><li>解耦。解耦了应用程序的实际处理逻辑，与应用不相关的解复用、调度机制，各司其职；</li><li>模块化。可以定义多个service，每个service负责自己的工作（逻辑），在模块化的同时，增强了复用性；</li><li>可移植性。不受限于特定OS，UNIX、Linux、Windows均支持Handle；</li><li>按序执行事件处理程序。启动调度程序的事件循环，是按序调用事件处理程序的，以减少复杂的同步机制。</li></ul><p><a name="2e769a75"></a></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>非抢占式的进程调度方式，在单线程的应用中，Event Handler执行是无法被中断而去做其他事，所以Event Handler处理event 时不能被block住，需要较长时间处理event的应用不适合Reactor模型。</li></ul><p><a name="21e37caf"></a></p><h3 id="为什么要用反应堆？"><a href="#为什么要用反应堆？" class="headerlink" title="为什么要用反应堆？"></a>为什么要用反应堆？</h3><blockquote><p>操作系统提供的系统函数select、epoll，本就可以使服务器维持较高TPS，承受并发十几万的连接（据说），在技术层面是满足性能要求；但是在软件编程层面看，这是一项很复杂的编程工作。</p></blockquote><p><br />从传统到IO多路复用到Reactor模型的调用，举个栗子，超市购物。<br /><br><br />在传统模型中，顾客购物买单，店长负责收银和被咨询工作，当顾客多时，需要排队；<br /><br><br />在IO多路复用的模型中，店长新招了一个售前店员，店员伴随着顾客购物，顾客有问题了店员帮助回答，当顾客示意将买单时，店员call店长准备买单；当顾客问一些商品的专业问题，店员不了解只好去问店主；当多个顾客想要同时购物仅剩的一件商品而出现打架时，店员示意暂停对外服务，并协助疏散顾客；类比到软件编程，就是面向过程的概念，系统需要关心如何实现某个事件的逻辑、还需要关心某个事件何时会发生、发生的条件等。<br /><br><br />在Reactor模型中，店长根据品类招了对应的专业售前店员，当顾客有问题对应的店员可以及时协助解决。此时的店员就是一个个具体的解决方案，类比到软件编程，Reactor模型下，就是面向对象（事件）的概念，通过定义一个个事件，并将具体业务和事件抽离开。<br /><br><br />总结：反应堆的执行效率虽然与IO多路复用几乎等价，但在软件编程上，反应堆解耦了应用程序的实际处理逻辑与应用不相关的解复用、调度机制，而多路复用是面向过程的思想，相对面向对象，它的开发效率降低，程序复杂性提高，不推荐！<br /></p><p><a name="7c55a2b4"></a></p><h3 id="几种Reactor模型"><a href="#几种Reactor模型" class="headerlink" title="几种Reactor模型"></a>几种Reactor模型</h3><p><br />略。<br /></p><p><a name="3dbf0c11"></a></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><br />Netty、Redis、nginx、 memcached<br /><br><br />推荐阅读： <a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="noopener">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf</a><br /><br><br />                        <a href="https://blog.csdn.net/russell_tao/article/details/17452997" target="_blank" rel="noopener">https://blog.csdn.net/russell_tao/article/details/17452997</a></p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（五）底层连接配置之ChannelOption</title>
      <link href="/2020/06/02/netty-wa-jue-ji-wu-di-ceng-lian-jie-pei-zhi-zhi-channeloption/"/>
      <url>/2020/06/02/netty-wa-jue-ji-wu-di-ceng-lian-jie-pei-zhi-zhi-channeloption/</url>
      
        <content type="html"><![CDATA[<p>上两篇主要介绍了如何结合spring和springboot搭建netty脚手架，其中在启动类中，我们通常会通过<code>ServerBootstrap.option</code>或者<code>ServerBootstrap.childOption</code>来配置TCP参数，合理的TCP参数配置对于项目的可用性还是挺重要的！<br /><br><br />那这一次我们来介绍一下Netty的TCP连接的底层参数配置：<code>io.netty.channel.ChannelOption</code><br /></p><p><a name="CxBF8"></a></p><h2 id="ChannelOption套接字配置"><a href="#ChannelOption套接字配置" class="headerlink" title="ChannelOption套接字配置"></a>ChannelOption套接字配置</h2><blockquote><p>Netty中关于套接字选项的设置，在<code>io.netty.channel.ChannelOption</code>这个类中。</p></blockquote><br /><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>SO_BROADCAST</td><td>对应套接字层的套接字：SO_BROADCAST，将消息发送到广播地址。</td></tr><tr><td>如果目标中指定的接口支持广播数据包，则启用此选项可让应用程序发送广播消息。</td><td></td></tr><tr><td>SO_KEEPALIVE</td><td>对应套接字层的套接字：SO_KEEPALIVE，保持连接。</td></tr><tr><td>在空闲套接字上发送探测，以验证套接字是否仍处于活动状态。</td><td></td></tr><tr><td>SO_SNDBUF</td><td>对应套接字层的套接字：SO_SNDBUF，设置发送缓冲区的大小。</td></tr><tr><td>SO_RCVBUF</td><td>对应套接字层的套接字：SO_RCVBUF，获取接收缓冲区的大小。</td></tr><tr><td>SO_REUSEADDR</td><td>对应套接字层的套接字：SO_REUSEADDR，本地地址复用。</td></tr><tr><td>启用此选项允许绑定已使用的本地地址。</td><td></td></tr><tr><td>SO_LINGER</td><td>对应套接字层的套接字：SO_LINGER，延迟关闭连接。</td></tr><tr><td>启用此选项，在调用close时如果存在未发送的数据时，在close期间将阻止调用应用程序，直到数据被传输或连接超时。</td><td></td></tr><tr><td>SO_BACKLOG</td><td>对应TCP/IP协议中_backlog_参数，_backlog_即连接队列，设置TCP中的连接队列大小。如果队列满了，会发送一个ECONNREFUSED错误信息给C端，即“ Connection refused”。</td></tr><tr><td>SO_TIMEOUT</td><td>等待客户连接的超时时间。</td></tr><tr><td>IP_TOS</td><td>对应套接字层的套接字：IP_TOS，在IP标头中设置服务类型（TOS）和优先级。</td></tr><tr><td>IP_MULTICAST_ADDR</td><td>对应IP层的套接字选项：IP_MULTICAST_IF，设置应发送多播数据报的传出接口。</td></tr><tr><td>IP_MULTICAST_IF</td><td>对应IP层的套接字选项：IP_MULTICAST_IF2，设置应发送多播数据报的IPV6传出接口。</td></tr><tr><td>IP_MULTICAST_TTL</td><td>对应IP层的套接字选项：IP_MULTICAST_TTL，在传出的 多播数据报的IP头中设置生存时间（TTL）。</td></tr><tr><td>IP_MULTICAST_LOOP_DISABLED</td><td>取消 指定应将 传出的多播数据报的副本 回传到发送主机，只要它是多播组的成员即可。</td></tr><tr><td>TCP_NODELAY</td><td>对应TCP层的套接字选项：TCP_NODELAY，指定TCP是否遵循Nagle算法 决定何时发送数据。Nagle算法代表通过减少必须发送包的个数来增加网络软件系统的效率。即尽可能发送大块数据避免网络中充斥着大量的小数据块。如果要追求高实时性，需要设置关闭Nagle算法；如果需要追求减少网络交互次数，则设置开启Nagle算法。</td></tr></tbody></table><br /><a name="K19pV"></a>## ChannelOption通用配置| 参数 | 解释 || --- | --- || ALLOCATOR | ByteBuf的分配器，默认值为ByteBufAllocator.DEFAULT。 || RCVBUF_ALLOCATOR | 用于Channel分配接受Buffer的分配器，默认值为AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。 || MESSAGE_SIZE_ESTIMATOR | 消息大小估算器，默认为DefaultMessageSizeEstimator.DEFAULT。估算ByteBuf、ByteBufHolder和FileRegion的大小，其中ByteBuf和ByteBufHolder为实际大小，FileRegion估算值为0。该值估算的字节数在计算水位时使用，FileRegion为0可知FileRegion不影响高低水位。 || CONNECT_TIMEOUT_MILLIS | 连接超时毫秒数，默认值30000毫秒即30秒。 || WRITE_SPIN_COUNT | 一个Loop写操作执行的最大次数，默认值为16。也就是说，对于大数据量的写操作至多进行16次，如果16次仍没有全部写完数据，此时会提交一个新的写任务给EventLoop，任务将在下次调度继续执行。这样，其他的写请求才能被响应不会因为单个大数据量写请求而耽误。 || WRITE_BUFFER_WATER_MARK |  || ALLOW_HALF_CLOSURE | 一个连接的远端关闭时本地端是否关闭，默认值为False。值为False时，连接自动关闭；为True时，触发ChannelInboundHandler的userEventTriggered()方法，事件为ChannelInputShutdownEvent。 || AUTO_READ | 自动读取，默认值为True。Netty只在必要的时候才设置关心相应的I/O事件。对于读操作，需要调用channel.read()设置关心的I/O事件为OP_READ，这样若有数据到达才能读取以供用户处理。该值为True时，每次读操作完毕后会自动调用channel.read()，从而有数据到达便能读取；否则，需要用户手动调用channel.read()。需要注意的是：当调用config.setAutoRead(boolean)方法时，如果状态由false变为true，将会调用channel.read()方法读取数据；由true变为false，将调用config.autoReadCleared()方法终止数据读取。 || AUTO_CLOSE |  |]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（四）结合springboot搭建netty脚手架</title>
      <link href="/2020/05/31/netty-wa-jue-ji-si-jie-he-springboot-da-jian-netty-jiao-shou-jia/"/>
      <url>/2020/05/31/netty-wa-jue-ji-si-jie-he-springboot-da-jian-netty-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<p>上文《Netty挖掘机（三）结合spring搭建netty脚手架》，结合Spring+Netty实现API接口服务模块，本文继续码字，以Springboot的方式接入Netty实现API接口服务。<br /><br><br />我们知道，spring-boot-starter-web 默认的web容器是Tomcat，同样也支持修改容器<br /><br><br />如要把Tomcat 切换为Jetty，我们首先要做的是先移除包中的Tomcat依赖，再加入Jetty容器<br /></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><br />以上操作，即可将默认的Tomcat容器切换为Jetty容器。<br /><br><br />然而，当使用Netty替代web容器的时候，也是上面这种做法吗？<br /><br><br />回顾下Netty和Servlet的区别<br /></p><ul><li>Servlet<br><br />Servlet是一种Java EE规范 ，是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。<br><br />Tomcat和Jetty 是一个servlet容器，而Jetty比大多数的servlet容器要更轻，即轻量级的servlet容器。</li><li>Netty<br><br />而Netty是一个异步事件驱动的基于NIO的网络应用程序框架，它支持扩展实现自己的servlet容器。</li></ul><p><br />当需要面对处理大量网络协议的时候，建议使用Netty，当仅用于HTTP应用程序的时候，可以使用servlet容器。<br /><br><br />所以当使用Netty替代tomcat等servlet容器时，可以实现一个自定义的servlet容器。<br /></p><p><a name="67723949"></a></p><h2 id="搭建思路"><a href="#搭建思路" class="headerlink" title="搭建思路"></a>搭建思路</h2><ol><li>首先Springboot 中移除Tomcat 依赖；</li><li>引入Servlet依赖，自己实现一个Servlet上下文，并加入Spring上下文；</li><li>Netty捕获到一个完整的Http 请求后，转换为ServletRequest，交给DispatcherServlet处理；</li><li>DispatcherServlet内部进行解析， 调用HandlerMapping寻找处理器，找到对应的处理器Controller后执行并返回处理结果；</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590937108727-af422824-31a2-4260-b204-7fec1c7f31bb.jpeg#align=left&display=inline&height=519&margin=%5Bobject%20Object%5D&name=process.jpg&originHeight=519&originWidth=1066&size=31225&status=done&style=none&width=1066" alt="process.jpg"><br /></p><p><a name="475f2d9c"></a></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p><a name="c780a665"></a></p><h3 id="Maven-pom配置"><a href="#Maven-pom配置" class="headerlink" title="Maven pom配置"></a>Maven pom配置</h3><ul><li>主要引入了Netty、Springboot的相关依赖，并且排除了内嵌的tomcat包依赖；</li><li>项目中使用了Servlet来接收http，而我们又排除了tomcat依赖，所以需手动加上servlet-api依赖；</li></ul><p><a name="1b888f46"></a></p><h3 id="全局返回实体"><a href="#全局返回实体" class="headerlink" title="全局返回实体"></a>全局返回实体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResultVO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ResultVO <span class="token function">create</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">{</span>        ResultVO ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResultVO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setMsg</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="acf861a0"></a></p><h3 id="定义功能类"><a href="#定义功能类" class="headerlink" title="定义功能类"></a>定义功能类</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/get"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResultVO <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"my name is jerry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="47381299"></a></p><h3 id="Netty-启动类"><a href="#Netty-启动类" class="headerlink" title="Netty 启动类"></a>Netty 启动类</h3><blockquote><p>通过Spring上下文找到dispatcherServlet，并传入Channel初始化配置类，用于执行具体的业务逻辑。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${netty.port:8080}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> DispatcherServlet dispatcherServlet<span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"############# start server at port: {}... #############"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap                <span class="token comment" spellcheck="true">// 绑定两个组</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 创建NioServerSocketChannel实例</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 添加Channel初始化配置类</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpChannelInitializer</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 服务于boss线程(accept connect)</span>                <span class="token comment" spellcheck="true">// 设置TCP中的连接队列大小，如果队列满了，会发送一个ECONNREFUSED错误信息给C端，即“ Connection refused”</span>                <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置关闭tcp的Nagle算法（尽可能发送大块数据，避免网络中充斥着许多小数据块），要求高实时性</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置启用心跳保活机制</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> HttpChannelOptionConstants<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="25751352"></a></p><h3 id="管道初始化配置类"><a href="#管道初始化配置类" class="headerlink" title="管道初始化配置类"></a>管道初始化配置类</h3><blockquote><p>每次有请求进来时，调用初始化配置，将处理器添加到管道。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>Channel ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    ChannelPipeline pipeline <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpObjectAggregator</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpFirstServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpLastServerHandler</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>添加了一个支持最大消息为64*1024 kb大小的<code>HttpFirstServerHandler</code>，即聚合了多个Http片段。而一般不设置的话默认是有多个Http的片段组合成一次请求的；</li><li>添加了两个处理器，一个用于将Netty接收到的Http请求包装到<code>HttpServletRequest</code>中，一个用于接收<code>MockHttpServletRequest</code>，并使用dispatcherServlet执行内部的业务逻辑。</li></ul><p><a name="7a3e16e0"></a></p><h3 id="包装HttpServletRequest"><a href="#包装HttpServletRequest" class="headerlink" title="包装HttpServletRequest"></a>包装<code>HttpServletRequest</code></h3><blockquote><p>Netty捕获到一个完整的Http 请求后，转换为ServletRequest，转发到下一个处理器</p></blockquote><p><br />假设管道配置了聚合http片段时，入站处理器需要继承<code>SimpleChannelInboundHandler</code>。<br /><br><br />代码如下<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext channelHandlerContext<span class="token punctuation">,</span> FullHttpRequest fullHttpRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    MockHttpServletRequest servletRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MockHttpServletRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String uri <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>favicon<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    uri <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>uri<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String method <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuf content <span class="token operator">=</span> fullHttpRequest<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fullHttpRequest<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> servletRequest<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span>header<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UriComponents uriComponents <span class="token operator">=</span> UriComponentsBuilder<span class="token punctuation">.</span><span class="token function">fromUriString</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String path <span class="token operator">=</span> uriComponents<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setRequestURI</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServletPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setScheme</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServerName</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setServerPort</span><span class="token punctuation">(</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>uriComponents<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>content<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    content<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> byteArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    String contentStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>byteArr<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servletRequest<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span>byteArr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>HttpMethod<span class="token punctuation">.</span>GET<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        QueryStringDecoder uriDecoder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryStringDecoder</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>        uriDecoder<span class="token punctuation">.</span><span class="token function">parameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>param<span class="token operator">-</span><span class="token operator">></span> servletRequest<span class="token punctuation">.</span><span class="token function">addParameter</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>HttpMethod<span class="token punctuation">.</span>POST<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> contentMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>contentStr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        servletRequest<span class="token punctuation">.</span><span class="token function">addParameters</span><span class="token punctuation">(</span>contentMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    channelHandlerContext<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="fb43c6fd"></a></p><h3 id="处理实际的业务逻辑"><a href="#处理实际的业务逻辑" class="headerlink" title="处理实际的业务逻辑"></a>处理实际的业务逻辑</h3><blockquote><p>DispatcherServlet内部进行解析， 调用HandlerMapping寻找处理器，找到对应的处理器Controller后执行并返回处理结果；</p></blockquote><p><br />假设管道配置了聚合http片段时，入站处理器需要继承<code>SimpleChannelInboundHandler</code>。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> MockHttpServletRequest servletRequest<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MockHttpServletResponse servletResponse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MockHttpServletResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dispatcherServlet<span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>    String respContent <span class="token operator">=</span> servletResponse<span class="token punctuation">.</span><span class="token function">getContentAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuf resultBuf <span class="token operator">=</span> Unpooled<span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span>respContent<span class="token punctuation">,</span> CharsetUtil<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>    HttpResponseStatus status <span class="token operator">=</span> HttpResponseStatus<span class="token punctuation">.</span>OK<span class="token punctuation">;</span>    FullHttpResponse response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultFullHttpResponse</span><span class="token punctuation">(</span>HttpVersion<span class="token punctuation">.</span>HTTP_1_1<span class="token punctuation">,</span> status<span class="token punctuation">,</span> resultBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 添加响应头信息</span>    HttpHeaders headers <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>HttpHeaderNames<span class="token punctuation">.</span>CONTENT_TYPE<span class="token punctuation">,</span> HttpHeaderValues<span class="token punctuation">.</span>APPLICATION_JSON  <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    headers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>HttpHeaderNames<span class="token punctuation">.</span>CONTENT_LENGTH<span class="token punctuation">,</span> resultBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"================= REQUEST END, cost {} ms =================\n"</span><span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="dcc66630"></a></p><h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ApplicationContext applicationContext <span class="token operator">=</span> SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>HttpServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />好了，接下来开始启动程序，发现报错，很明显，描述是指缺少了<code>ServletWebServerFactory</code>这个bean，即未能加载嵌入的供web应用加载的空间。<br /></p><pre class=" language-java"><code class="language-java">Caused by<span class="token operator">:</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContextException<span class="token operator">:</span> Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean<span class="token punctuation">.</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">getWebServerFactory</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">206</span><span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">createWebServer</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">180</span><span class="token punctuation">)</span>    at org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ServletWebServerApplicationContext<span class="token punctuation">.</span><span class="token function">onRefresh</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">154</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">8</span> common frames omitted</code></pre><p><br />查看源码，可以发现逻辑走向是这样的，<br /><br><br />先获取webServer和servletContext，如果两者都为null，则去获取ServletWebServer工厂，进而得到webServer，否则则开始启动上下文。<br /><br><br />如果不忽略tomcat，按正常的逻辑跑下去，一般是获取到<code>TomcatServletWebServerFactory</code>再去获得webSever。而且<code>ServletWebServerFactory</code>默认的实现类仅有几种<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590938693489-546dd5fa-51e9-4ca4-b891-34f017f36b5a.jpeg#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=servletWebServerFactory.jpg&originHeight=156&originWidth=1075&size=24025&status=done&style=none&width=1075" alt="servletWebServerFactory.jpg"><br /><br><br />综上，现在我们排除了tomcat的依赖，想要结合Netty自己实现一个Servlet上下文，则需要走else if的逻辑，即可得：servletContext不能为null。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">GenericWebApplicationContext</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableWebServerApplicationContext</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createWebServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        WebServer webServer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>webServer<span class="token punctuation">;</span>        ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>webServer <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> servletContext <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 默认获得Tomcat工厂实现类，用于获取Tomcat作为WebServer</span>            ServletWebServerFactory factory <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getWebServerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>webServer <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getWebServer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletContextInitializer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>servletContext <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSelfInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStartup</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContextException</span><span class="token punctuation">(</span><span class="token string">"Cannot initialize servlet context"</span><span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initPropertySources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">GenericWebApplicationContext</span> <span class="token keyword">implements</span> <span class="token class-name">ConfigurableWebServerApplicationContext</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> ServletWebServerFactory <span class="token function">getWebServerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> beanNames <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBeanNamesForType</span><span class="token punctuation">(</span>ServletWebServerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanNames<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ApplicationContextException</span><span class="token punctuation">(</span><span class="token string">"Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// ......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />按以上的分析，由于是在<code>SpringApplication.run</code>的启动逻辑内报错，故我们需要在启动生命周期内，创建<code>ServletContext</code>这个bean<br /><br><br />这里可以使用<code>SpringApplicationRunListener</code>，并且通过spring.factories文件配置监听器即可生效<br /></p><blockquote><p>什么是<code>SpringApplicationRunListener</code>？<br>在调用<code>SpringApplication.run()</code>的过程中，会进行初始化事件体系，如果发现有自定义广播，则会将其设置成自身的事件广播，否则使用默认的<code>SimpleApplicationEventMulticaster</code>，代码在<code>org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster</code>。<br><code>SpringApplicationRunListener</code>接口参与了Springboot的生命周期，开放了基于生命周期各个过程的接口，使得用户方便在指定的生命周期广播相应的事件</p></blockquote><p><a name="905b9be7"></a></p><h4 id="创建监听器"><a href="#创建监听器" class="headerlink" title="创建监听器"></a>创建监听器</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletListener</span> <span class="token keyword">implements</span> <span class="token class-name">SpringApplicationRunListener</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ServletListener</span><span class="token punctuation">(</span>SpringApplication application<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextPrepared</span><span class="token punctuation">(</span>ConfigurableApplicationContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">class</span> <span class="token class-name">SelfServletContext</span> <span class="token keyword">extends</span> <span class="token class-name">MockServletContext</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> ServletRegistration<span class="token punctuation">.</span>Dynamic <span class="token function">addServlet</span><span class="token punctuation">(</span>String servletName<span class="token punctuation">,</span> Servlet servlet<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> FilterRegistration<span class="token punctuation">.</span>Dynamic <span class="token function">addFilter</span><span class="token punctuation">(</span>String filterName<span class="token punctuation">,</span> Filter filter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        ServletContext servletContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SelfServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>ServletWebServerApplicationContext<span class="token punctuation">)</span> context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setServletContext</span><span class="token punctuation">(</span>servletContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="spring.factories"></a></p><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h4><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">org.springframework.boot.SpringApplicationRunListener</span><span class="token punctuation">=</span><span class="token attr-value">cn.binary.jerry.netty.config.ServletListener</span></code></pre><p><br />接下来开始启动程序，启动正常，并且调试接口： <a href="http://localhost:8082/user/get/jy" target="_blank" rel="noopener">http://localhost:8082/user/get/jy</a><br /><br><br />发现在最后一个Handler中的<code>dispatcherServlet.service(servletRequest, servletResponse);</code>出错，报空指针…<br /><br><br />查看源码发现是在以下代码中，未找到ServletConfig这个配置，而<code>FrameworkServlet</code>是<code>DispatcherServlet</code>的父类，所以可以通过反射机制给父类的参数配置值<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">FrameworkServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServletBean</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> ServletConfig config<span class="token punctuation">;</span>    <span class="token keyword">public</span> ServletConfig <span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">publishRequestHandledEvent</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> <span class="token keyword">long</span> startTime<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> Throwable failureCause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>publishEvents <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationContext <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> processingTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 由于this.getServletConfig() 为null，获取不到servletName，导致报NPT</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ServletRequestHandledEvent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> WebUtils<span class="token punctuation">.</span><span class="token function">getSessionId</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getUsernameForRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">,</span> processingTime<span class="token punctuation">,</span> failureCause<span class="token punctuation">,</span> response<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p><br />既然没有配置，我们就手动帮它配，并且进行初始化<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ApplicationContext applicationContext <span class="token operator">=</span> SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取DispatcherServlet</span>    DispatcherServlet dispatcherServlet <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CommonUtils<span class="token punctuation">.</span><span class="token function">setDeclaredFieldValue</span><span class="token punctuation">(</span>dispatcherServlet<span class="token punctuation">,</span> <span class="token string">"config"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MockServletConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        dispatcherServlet<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ServletException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>HttpServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br />接下来开始启动程序，启动正常，并且调试接口： <a href="http://localhost:8082/user/get/jy" target="_blank" rel="noopener">http://localhost:8082/user/get/jy</a> ，一切正常了！<br /></p><p><a name="138a6766"></a></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><br />在Netty In Action中提到，Server端的程序不建议使用<code>SimpleChannelInboundHandler</code>，因为执行了<code>channelRead0()</code>后会自动释放指向保存该消息的ByteBuf的内存引用，而在Server端往往需要回传数据给Client端，ctx.write()又是异步的，这样就会导致<code>channelRead0()</code>返回后写操作还没有完成。而一般对于Client端使用而言，已经有了传入消息并处理完了，此时便可以自动释放。所以一般开发中Server端的程序的入站处理器建议使用<code>ChannelInboundHandlerAdapter</code>。<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590938750240-d8379a1c-890a-4fb5-9ab0-a7efb47dcd3d.jpeg#align=left&display=inline&height=535&margin=%5Bobject%20Object%5D&name=channelRead_code.jpg&originHeight=535&originWidth=861&size=23509&status=done&style=none&width=861" alt="channelRead_code.jpg"><br /><br><br />到这里，基于Springboot+Netty实现的API框架已成功搭建好了哈。<br /><br><br />具体源码请查看github：<br /><br><br /><a href="https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-3" target="_blank" rel="noopener">https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-3</a></p><hr><p>Ending……<br /><br><br />阿黑在下一章节将继续源码剖析！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（三）结合spring搭建netty脚手架</title>
      <link href="/2020/05/31/netty-wa-jue-ji-san-jie-he-spring-da-jian-netty-jiao-shou-jia/"/>
      <url>/2020/05/31/netty-wa-jue-ji-san-jie-he-spring-da-jian-netty-jiao-shou-jia/</url>
      
        <content type="html"><![CDATA[<p>上文《Netty挖掘机（二）初识Netty》，主要介绍了Netty的特性及其如何启动，启动的相关配置说明。这一篇主要讲一下如何结合Spring搭建Netty脚手架，实现API接口服务模块。<br /><br><br />结合Spring依赖注入的特性，在Netty的handler中获取上下文的bean，再通过uri找到匹配的方法。<br /></p><p><a name="20f02ddc"></a></p><h3 id="maven-pom配置"><a href="#maven-pom配置" class="headerlink" title="maven pom配置"></a>maven pom配置</h3><p><br />主要引入了Netty、Spring的依赖， 及其日志框架logback，很简单。<br /></p><p><a name="786e68ad"></a></p><h3 id="封装请求体"><a href="#封装请求体" class="headerlink" title="封装请求体"></a>封装请求体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiReq</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * HTTP protocol     */</span>    <span class="token keyword">private</span> String protocol<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * ip     */</span>    <span class="token keyword">private</span> String remoteIp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request type     */</span>    <span class="token keyword">private</span> String method<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request uri     */</span>    <span class="token keyword">private</span> String uri<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request headers     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * request data     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> data <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String controllerName<span class="token punctuation">;</span>    <span class="token keyword">private</span> String invokeMethodName<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getParam</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="aa2bad4d"></a></p><h3 id="封装返回体"><a href="#封装返回体" class="headerlink" title="封装返回体"></a>封装返回体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiResp</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>8826517176378050058L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ApiResp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ApiResp <span class="token function">create</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">{</span>        ApiResp ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ApiResp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setMsg</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="62fa2d54"></a></p><h3 id="定义Controller的基类，用于后续反射调用派生类方法"><a href="#定义Controller的基类，用于后续反射调用派生类方法" class="headerlink" title="定义Controller的基类，用于后续反射调用派生类方法"></a>定义Controller的基类，用于后续反射调用派生类方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApiController</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ApiResp <span class="token function">invoke</span><span class="token punctuation">(</span>String invokeMethodName<span class="token punctuation">,</span> ApiReq req<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Method method <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>invokeMethodName<span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ApiResp result <span class="token operator">=</span> <span class="token punctuation">(</span>ApiResp<span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="a9a58b76"></a></p><h3 id="定义一个功能类"><a href="#定义一个功能类" class="headerlink" title="定义一个功能类"></a>定义一个功能类</h3><p><br />用户功能类，这里只列出一个方法，返回简单的文字描述信息。<br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token keyword">extends</span> <span class="token class-name">ApiController</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ApiResp <span class="token function">get</span><span class="token punctuation">(</span>ApiReq req<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ApiResp<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"my name is "</span> <span class="token operator">+</span> req<span class="token punctuation">.</span><span class="token function">getParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="7d16d5f4"></a></p><h3 id="实现一个Netty-启动类"><a href="#实现一个Netty-启动类" class="headerlink" title="实现一个Netty 启动类"></a>实现一个Netty 启动类</h3><p><br />回顾一下上文讲到的启动类，其实启动类对外透明化，只要很简单的几行代码，就帮我们实现了很多配置，甚至有更多的透明化配置等着我们去使用。<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractControllerAdapter controllerAdapter<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HttpServer</span><span class="token punctuation">(</span>AbstractControllerAdapter controllerAdapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>controllerAdapter <span class="token operator">=</span> controllerAdapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"############# start server at port: {}... #############"</span><span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap                <span class="token comment" spellcheck="true">// 绑定两个组</span>                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 创建NioServerSocketChannel实例</span>                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 添加处理器Handler</span>                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel channel<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 为通道Channel进行初始化配置</span>                        ChannelPipeline pipeline <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpRequestDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">HttpResponseEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">HttpServerHandler</span><span class="token punctuation">(</span>controllerAdapter<span class="token punctuation">)</span>                        <span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 服务于boss线程(accept connect)</span>                <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置关闭tcp的Nagle算法（尽可能发送大块数据，避免网络中充斥着许多小数据块），要求高实时性</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置启用心跳保活机制</span>                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />其中在初始化配置中，可以看到主要配置了三个<br /></p><ul><li>HttpRequestDecoder：将字节解码为HttpRequest、HttpContent和LastHttpContent消息；</li><li>HttpResponseEncoder：将HttpResponse、HttpContent和LastHttpContent消息编码为字节；</li><li>HttpServerHandler：服务中转站，下面会提到。</li></ul><p><a name="080445ec"></a></p><h3 id="服务中转站"><a href="#服务中转站" class="headerlink" title="服务中转站"></a>服务中转站</h3><p><br />中转，即是一个协同者的角色，提供一个handler，拦截请求以执行入站和出战事件。<br /><br><br />ChannelHandler是Netty中处理器的抽象，Netty对其提供了很多种可以开箱即用的实现，包括运用于各种协议（如HTTP SSL）的ChannelHandler，在内部也使用了事件和Future。<br /><br><br />在这里我们用了其中的一个实现ChannelInboundHandlerAdapter来拦截和处理事件。其中涉及到Netty中对HTTP的执行流程的一个封装。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1590936988432-8b30f96a-44d9-48b4-9b6d-47ef4dd89bd9.jpeg#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&name=full_http.jpg&originHeight=220&originWidth=705&size=8574&status=done&style=none&width=705" alt="full_http.jpg"><br /><br><br />以上是一次完整的Http请求，HttpRequest是请求的第一部分，包含Http头部信息；HttpContent是请求中存放数据的块体，不止一个；LastHttpContent标志请求的结束，也包含数据，也可能包含尾随的Http头部信息。<br /><br><br />按照这种顺序，接下来实现通过一次完整的Http请求获取数据<br /></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractControllerAdapter adapter<span class="token punctuation">;</span>    <span class="token keyword">private</span> ApiReq req<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HttpServerHandler</span><span class="token punctuation">(</span>AbstractControllerAdapter adapter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adapter <span class="token operator">=</span> adapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">HttpRequest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                HttpRequest request <span class="token operator">=</span> <span class="token punctuation">(</span>HttpRequest<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>                req <span class="token operator">=</span> ApiReq<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">LastHttpContent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String controllerName <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getControllerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                HttpContent content <span class="token operator">=</span> <span class="token punctuation">(</span>HttpContent<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> data <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">parseData</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                FullHttpResponse response <span class="token operator">=</span> ApiResp<span class="token punctuation">.</span><span class="token function">response</span><span class="token punctuation">(</span>adapter<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            ReferenceCountUtil<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">channelReadComplete</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><br />到这里，基于Spring+Netty实现的API框架已成功搭建好了哈。<br /><br><br />具体源码请查看github：<br /><br><br /><a href="https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-2" target="_blank" rel="noopener">https://github.com/qJerry/Netty-Analyze-Demo/tree/master/Chapter1-2</a></p><hr><p>Ending……<br /><br><br />阿黑在下一章节将结合SpringBoot搭建Netty脚手架…！<br /><br><br />请关注微信公众号：进击的阿黑，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器系统日志管理logrotate</title>
      <link href="/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/"/>
      <url>/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br>对于业务系统，每天都会输出大量的日志，并且增长极快，久而久之在有限的容量内总会消耗完服务器的磁盘空间；<br><br><br>当我们遇到故障需要排查的时候，日志往往是第一选择，然而当日志日渐庞大的时候，排查成问题，空间也成问题；<br><br><br>线上埋点系统出现问题，排查发现硬盘被日志撑爆了。<br><br><br>。。。<br><br><br><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>帮我们解决了日志方面的繁琐问题，<br></p><ul><li>它支持自动执行日志的（周期性）切割，压缩，删除</li><li>可以指定目录存放压缩日志文件</li><li>当执行出错时可以指定email发出邮件报警</li></ul><p><a name="e05dce83"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><br><a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">logrotate</a>旨在简化对生成大量日志文件的系统的管理。它允许自动旋转，压缩，删除和邮寄日志文件。每个日志文件可以每天，每周，每月或当它变得太大时处理。通常，logrotate作为每天cron任务运行。<br></p><p><a name="e655a410"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br>主流的Linux系统一般都会自带logrotate包，如果没有，则使用以下命令安装<br></p><pre class=" language-shell"><code class="language-shell">$ yum install logrotate crontabs $ logrotate -vlogrotate 3.8.6 - Copyright (C) 1995-2001 Red Hat, Inc.This may be freely redistributed under the terms of the GNU Public LicenseUsage: logrotate [-dfv?] [-d|--debug] [-f|--force] [-m|--mail command] [-s|--state statefile]        [-v|--verbose] [-l|--log STRING] [--version] [-?|--help] [--usage] [OPTION...] <configfile></code></pre><p><a name="6255b094"></a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p><br><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的默认配置文件放在 <code>/etc/logrotate.conf</code>，我们无需对它进行操作<br></p><p><a name="95cfe8dc"></a></p><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p><br><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>有一个针对日志的自定义配置文件夹 <code>/etc/logrotate.d/</code>，可以看到系统已经默认配置了syslog、yum等日志管理配置<br></p><pre><code>$ ll /etc/logrotate.d/-rw-r--r-- 1 root root  76 Aug  2  2018 bootlog-rw-r--r-- 1 root root 160 Sep 15  2017 chrony-rw-r--r-- 1 root root 408 Aug  2  2018 psacct-rw-r--r-- 1 root root 224 Aug  9  2018 syslog-rw-r--r-- 1 root root 100 Aug 21  2018 yum</code></pre><p><a name="19dc45e9"></a></p><h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><p><br><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的执行文件放在 <code>/usr/sbin/logrotate</code><br></p><p><a name="8dac4304"></a></p><h2 id="详细配置说明"><a href="#详细配置说明" class="headerlink" title="详细配置说明"></a>详细配置说明</h2><pre class=" language-shell"><code class="language-shell">/var/log/logback.log {    daily    rotate 30    compress    delaycompress    missingok       notifempty       size 30k       yearly    create 0600 root root    postrotate        # 输入指定的命令    endscript}</code></pre><ul><li>daily：日志文件按天轮换，还可以配置”weekly”，”monthly”，”yearly”。</li><li>rotate count：只能存储的归档文件数量，其他将被删除，如果count为0代表直接删除归档</li><li>compress：每次轮换完成后，将已轮换的归档用gzip压缩</li><li>delaycompress：与compress搭配使用，表示将最近归档文件的压缩推迟到下一个轮换周期</li><li>missingok：若当前日志文件缺少，则不发出错误消息而是继续执行下一个日志文件</li><li>notifempty：若当前日志为空，则不执行轮换</li><li>create mode owner group：在轮换之后，用指定权限创建新的日志文件，mode以八进制指定日志文件的模式（与chmod相同），owner指定将拥有日志文件的用户名，group指定日志文件将属于的组。可以省略任何日志文件属性，在这种情况下，新文件的那些属性将使用与原始日志文件相同的值来表示省略的属性。可以使用nocreate选项禁用此选项</li><li>postrotate/endscript：在所有指令完成后，postrotate和endscript里面指定的命令将被执行</li><li>size _size_：仅当日志文件大小超过指定字节大小时，才会触发轮换</li><li>dateext：使用当前日期作为命名格式</li><li>dateformat _format_string_：配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数</li></ul><p><br>更多配置查看<a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">官方说明</a><br></p><p><a name="4c763bb6"></a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><a name="ce559ba2"></a></p><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><ul><li>-d, –debug：开启调试模式，此时不会执行实际操作，但会打印出整个执行流程</li><li>-f, –force：强制轮换文件</li><li>-m, –mail ：压缩日志后，发送日志到指定邮箱</li><li>-s, –state=statefile ：使用指定的状态文件</li><li>-v, –verbose ：显示转储过程</li></ul><p><a name="17d444b6"></a></p><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>自动运行<br><br>默认情况下， <a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>在安装时已创建了以天为单位的定时任务<pre class=" language-shell"><code class="language-shell">$ cat /etc/cron.daily/logrotate</code></pre></li></ul><p>#!/bin/sh<br>/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf<br>EXITVALUE=$?<br>if [ $EXITVALUE != 0 ]; then<br>    /usr/bin/logger -t logrotate “ALERT exited abnormally with [$EXITVALUE]”<br>fi<br>exit 0</p><pre><code>- &lt;br /&gt;当运行周期为周/月/年时，可以在/etc/cron.*/logrotate下配置即可，当然也可以手动配置到crontab上。- 手动运行   - debug模式（logrotate -d ）```shell$ logrotate -d /etc/logrotate.d/custom-log</code></pre><ul><li><p>verbose模式（logrotate -v ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -v /etc/logrotate.d/custom-log</code></pre></li><li><p>强制模式（logrotate -vf ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -vf /etc/logrotate.d/custom-log</code></pre></li></ul><p><a name="9c5945ef"></a></p><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><ol><li><p>强制模式不起作用<br><br>删除记录状态的文件</p><pre class=" language-shell"><code class="language-shell">$ rm /var/lib/logrotate/logrotate.status</code></pre></li><li><p>日志文件为空无法执行<br><br>那就让它不为空呗</p></li><li><p>使用nohup进行日志输出，接着日志切割后，原日志大小不变<br><br>改变nohup输出方式：nohup xxx.sh &gt;&gt; nohup.out &amp;，要有两个&gt;</p></li></ol><p><br>大概就是这样，让我们尝试接入到我们的系统内吧！</p>]]></content>
      
      
      <categories>
          
          <category> logrotate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计之错误码（二）</title>
      <link href="/2020/05/30/api-she-ji-zhi-cuo-wu-ma-er/"/>
      <url>/2020/05/30/api-she-ji-zhi-cuo-wu-ma-er/</url>
      
        <content type="html"><![CDATA[<p><a name="EtstL"></a></p><h2 id="错误码类型"><a href="#错误码类型" class="headerlink" title="错误码类型"></a>错误码类型</h2><p>上一篇说到，错误码类型会有业务错误码和系统错误码，所以我们必须要将其考虑进来<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588486291183-acc1f079-b50f-47fe-994a-7befc6480140.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=482&size=9821&status=done&style=none&width=482" alt="image.png"><br /></p><p><a name="eeyl1"></a></p><h2 id="错误码设计"><a href="#错误码设计" class="headerlink" title="错误码设计"></a>错误码设计</h2><p>错误码设计原则是，尽可能做到简洁。故我将错误码分成两部分：系统码（前4位）+错误码（后4位）<br />系统码和错误码区间区间 需通过后台申请。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588486466975-c2c05977-7f33-49e3-8446-d5494e64ac55.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=562&size=20319&status=done&style=none&width=562" alt="image.png"><br />由于要区分错误码类型，我定义了指定的区间进行分配，剩下未分配的区间，待后续动态扩展<br /><br><br />例如，我所在部门假设会有50个项目来开发，那么我可以申请区间为00010000-00500000的错误码。当然后续由于业务扩展，又增加了新的项目，亦可以重新申请新的错误码区间！<br /></p><p><a name="2uuq3"></a></p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>我考虑了两种场景，对内错误码API和开放错误码API。<br />基础的模型有：运营后台、错误码系统、错误码服务<br><a name="kv6FM"></a></p><h3 id="对内错误码"><a href="#对内错误码" class="headerlink" title="对内错误码"></a>对内错误码</h3><p>贯彻“错误码无侵入”的理念，对内设计的领域模型，主要有业务系统—&gt;错误码SDK&lt;—&gt;错误码内部API<br><a name="XkX0q"></a></p><h3 id="开放错误码"><a href="#开放错误码" class="headerlink" title="开放错误码"></a>开放错误码</h3><p>我们仅需要将错误码API接口开放即可，并 提供一套错误码API文档<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587195975740-66f381e2-0c28-4a6a-a464-f9a95d61ab06.png#align=left&display=inline&height=389&margin=%5Bobject%20Object%5D&name=image.png&originHeight=521&originWidth=1000&size=33575&status=done&style=none&width=746" alt="image.png"><br /></p><p><a name="P3eEF"></a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588495621963-ec565c00-55cf-4f61-a80a-8a9e64007ff4.png#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1161&size=91009&status=done&style=none&width=1161" alt="image.png"><br /></p><p><a name="vFpv2"></a></p><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>码盒项目基于Springboot + Spring cloud + Mysql搭建而成，项目架构比较简单。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588487357922-814f9fa7-62dd-44b9-85c8-92263f9f953b.png#align=left&display=inline&height=478&margin=%5Bobject%20Object%5D&name=image.png&originHeight=643&originWidth=1003&size=48545&status=done&style=none&width=746" alt="image.png"><br /></p><p><a name="vqdYr"></a></p><h3 id="运营后台"><a href="#运营后台" class="headerlink" title="运营后台"></a>运营后台</h3><ul><li><p>创建业务部门、业务系统</p></li><li><p>申请端口、系统码、错误码区间</p></li><li><p>修改错误码信息、及其错误描述</p></li><li><p>售后排查功能<br><a name="s6Kq9"></a></p><h3 id="错误码服务"><a href="#错误码服务" class="headerlink" title="错误码服务"></a>错误码服务</h3></li><li><p>内部错误码API接口</p></li><li><p>外部错误码API接口</p></li><li><p>错误码文档可视化<br><a name="PFghE"></a></p><h3 id="错误码提取"><a href="#错误码提取" class="headerlink" title="错误码提取"></a>错误码提取</h3><p>支持在编译期间，从业务中自动提取出错误码内容<br><a name="cHdkr"></a></p><h3 id="错误码SDK"><a href="#错误码SDK" class="headerlink" title="错误码SDK"></a>错误码SDK</h3><p>接入业务系统，通过配置中心配置，开启错误码同步及检测功能，并支持开启周期性更新错误码<br><a name="xoel4"></a></p><h3 id="错误码话术转换"><a href="#错误码话术转换" class="headerlink" title="错误码话术转换"></a>错误码话术转换</h3><p>待定。。。<br /></p><br /><br /></li></ul><p><a name="fsVRc"></a></p><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588488831390-1e0b2e66-35d9-45cf-aa94-ed7a58895462.png#align=left&display=inline&height=799&margin=%5Bobject%20Object%5D&name=image.png&originHeight=799&originWidth=1002&size=61758&status=done&style=none&width=1002" alt="image.png"><br />从上图看出，我这里区分了4个角色：项目负责人、产品、技术、用户<br /></p><p><a name="8MBao"></a></p><h3 id="负责人"><a href="#负责人" class="headerlink" title="负责人"></a>负责人</h3><p>这是接入码盒的第一步</p><ul><li>创建业务部门：根据部门信息，对应创建一条部门记录</li><li>创建业务系统：根据系统信息，对应创建一条系统记录，并自动生成一个系统码，4位组成</li><li>申请配置：这里不仅可以申请错误码区间，还可以申请域名，端口等，这样可以协同管理跨部门的信息</li></ul><p><br />当申请配置成功后，即可进行下一步<br><a name="1gd5n"></a></p><h3 id="技术线"><a href="#技术线" class="headerlink" title="技术线"></a>技术线</h3><p>引进码盒SDK即可，但是配置方式有以下几种<br><a name="wExmJ"></a></p><h4 id="配置错误码文件"><a href="#配置错误码文件" class="headerlink" title="配置错误码文件"></a>配置错误码文件</h4><p>这是最简单的一种接入方式。技术人员在具体的业务项目中引入码箱SDK，并在资源文件下定义code.json，内容参考如下</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">101</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"参数有误"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"请检查入参：必填参数是否为空，长度超出规定限制长度 或 是否不符合格式"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">102</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"系统繁忙"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"可能发生了网络或者系统异常，导致无法判定准确的转账结果。此时，商户不能直接当做转账成功或者失败处理，可以考虑采用相同的out_biz_no重发请求，或者通过调用“(alipay.fund.trans.order.query)”来查询该笔转账订单的最终状态"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">103</span><span class="token punctuation">,</span>    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"根据监管部门的要求，请补全您的身份信息解除限制"</span><span class="token punctuation">,</span>    <span class="token property">"detail"</span><span class="token operator">:</span> <span class="token string">"根据监管部门的要求，请补全您的身份信息解除限制"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><br /><p><a name="aW6rv"></a></p><h4 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h4><p>常见的项目，会将错误码定义在枚举类中，增加了可读性，以及便于迭代。<br />这里针对此业务错误码枚举类，增加了自定义注解 <code>@CodeBoxData</code> 的支持，如下。当然有些项目错误码多，需要按业务进行区分，即有多个枚举类，也一样在每个枚举类上添加 <code>@CodeBoxData</code> 注解。<br /><br><br />配置注解的目的，也是为了生成错误码信息到资源文件下的code.json文件中。<br />至于怎么生成，这里主要借鉴了lombok、mapstruct等的思路，它们基于注解处理器，给我们提供了很多丰富的功能。<br />在编译期间，码盒的注解处理器将会将枚举类的内容动态添加到code.json。接着等项目启动，SDK将会将生成的错误码同步到码盒系统。</p><p><a name="rmQAn"></a></p><h3 id="产品线"><a href="#产品线" class="headerlink" title="产品线"></a>产品线</h3><p>码盒提供了针对产品经理的一个解决方案，在公司产品经理和开发人员经常有这样几个苦恼：</p><ol><li>开发人员定义的错误信息太技术，导致涌出部分售后问题，引发产品不满：“这不是我设计的！”；</li><li>修改错误信息，必须改代码，重新发布，引发开发人员不满：“又来！”；</li><li>错误信息应该从哪里处理，前端？后端？中台？，引发开发人员疑惑：“是你，是你，还是你？”；</li></ol><p><br />以上问题，在码盒上统统解决，当发现错误信息会带来售后问题而需要优化时，仅需要在码盒后台修改即可！<br /></p><p><a name="3lZjy"></a></p><h2 id="业务接入"><a href="#业务接入" class="headerlink" title="业务接入"></a>业务接入</h2><p><a name="eUnVy"></a></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>业务项目基于Springboot + Spring cloud 框架<br /></p><p><a name="5tmFC"></a></p><h3 id="下载码盒项目"><a href="#下载码盒项目" class="headerlink" title="下载码盒项目"></a>下载码盒项目</h3><p><a href="https://github.com/qJerry/Code-Box" target="_blank" rel="noopener">https://github.com/qJerry/Code-Box</a></p><p><a name="Y927q"></a></p><h3 id="执行数据库脚本"><a href="#执行数据库脚本" class="headerlink" title="执行数据库脚本"></a>执行数据库脚本</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1588496780981-63ca66bb-315c-4e90-98b7-4a0f1a04fd2e.png#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&name=image.png&originHeight=355&originWidth=428&size=18805&status=done&style=none&width=428" alt="image.png"></p><p><a name="WwDRB"></a></p><h3 id="更改码盒内部API配置文件"><a href="#更改码盒内部API配置文件" class="headerlink" title="更改码盒内部API配置文件"></a>更改码盒内部API配置文件</h3><p>数据库配置、端口配置、注册中心配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">hikari</span><span class="token punctuation">:</span>      <span class="token key atrule">username</span><span class="token punctuation">:</span> root      <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/code_box<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span>8<span class="token important">&amp;serverTimezone</span>=GMT%2B8<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8501</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>1002/eureka/</code></pre><p><a name="A0WFd"></a></p><h3 id="引入SDK"><a href="#引入SDK" class="headerlink" title="引入SDK"></a>引入SDK</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.qJerry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>CodeBox-Sdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p><a name="btjRy"></a></p><h3 id="添加自定义注解-CodeBoxData"><a href="#添加自定义注解-CodeBoxData" class="headerlink" title="添加自定义注解@CodeBoxData"></a>添加自定义注解@CodeBoxData</h3><p>在错误码枚举类上添加自定义注解，枚举类的参数参考如下</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@CodeBoxData</span><span class="token keyword">public</span> <span class="token keyword">enum</span> BusinessCodeEnum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设备：1000-1999</span>    <span class="token function">EQUIPMENT_NOT_EXIST</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"设备不存在"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 用户：2000-2499</span>    <span class="token function">USER_LOGIN_AGAIN</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">"请重新登录"</span><span class="token punctuation">,</span> <span class="token string">"当前缓存信息已过期，需要重新登录"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer code<span class="token punctuation">;</span>    String message<span class="token punctuation">;</span>    String detail<span class="token punctuation">;</span>    <span class="token function">BusinessCodeEnum</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String message<span class="token punctuation">,</span> String detail<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>detail <span class="token operator">=</span> detail<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="wfh0H"></a></p><h3 id="业务项目配置文件添加码盒配置"><a href="#业务项目配置文件添加码盒配置" class="headerlink" title="业务项目配置文件添加码盒配置"></a>业务项目配置文件添加码盒配置</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">code</span><span class="token punctuation">:</span>  <span class="token key atrule">business</span><span class="token punctuation">:</span>    <span class="token key atrule">id</span><span class="token punctuation">:</span> 1    // 业务部门id    <span class="token key atrule">system</span><span class="token punctuation">:</span>      <span class="token key atrule">id</span><span class="token punctuation">:</span> 1    // 业务系统id  <span class="token key atrule">refresh</span><span class="token punctuation">:</span>    <span class="token key atrule">open</span><span class="token punctuation">:</span> false    // 是否开启周期性任务    <span class="token key atrule">cron</span><span class="token punctuation">:</span> 0 0/5 * * * <span class="token punctuation">?</span>    // 调度周期  <span class="token key atrule">sync-log</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p><a name="NLHZd"></a></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>在每个需要用到错误码的地方，直接调用SDK的 <code>ResultVO.err()</code> 输入具体的错误码即可，如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ResultVO <span class="token function">getCode</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Strings<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span> name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">err</span><span class="token punctuation">(</span>10101L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ResultVO<span class="token punctuation">.</span><span class="token function">suc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然，SDK也内置了全局异常处理器<code>CodeBoxGlobalException</code>，直接传入错误码即可。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CodeBoxGlobalException</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="y6oBK"></a></p><h2 id="框架特色"><a href="#框架特色" class="headerlink" title="框架特色"></a>框架特色</h2><p><a name="pTn79"></a></p><h3 id="99-无侵入"><a href="#99-无侵入" class="headerlink" title="99%无侵入"></a>99%无侵入</h3><p>为了尽可能做到不侵入业务代码，我制作了一个SDK，并添加了自定义注解或者直接配置文件配置的形式进行接入<br /></p><p><a name="GS9he"></a></p><h3 id="自定义注解处理器"><a href="#自定义注解处理器" class="headerlink" title="自定义注解处理器"></a>自定义注解处理器</h3><p>支持在编译期间，对于在业务错误码枚举类上添加了自定义注解的类，将在编译期间，将其拉取到资源文件下的code.json中，业务技术方无需手写code.json文件，只需添加注解，即可快速完成接入的一大步。<br /></p><p><a name="u43Ed"></a></p><h3 id="动态字节码技术（对外透明化）"><a href="#动态字节码技术（对外透明化）" class="headerlink" title="动态字节码技术（对外透明化）"></a>动态字节码技术（对外透明化）</h3><p>内部封装了一个错误码工具类，使用了ASM动态字节码功能，在项目启动期间和周期性刷新错误码期间，将会动态添加或更新错误码到SDK的错误码枚举类中，对外透明化，业务仅需提供一个错误码作为入参，即可获取详细的错误码内容。<br /><strong>出发点：</strong><br />可能有些人包括我一开始会直接使用redis缓存来存放错误码信息。但从实际使用上看，错误码更多的是静态数据，一般不会去频繁改动，这时候放置于缓存就有点浪费资源了。故我在做自定义注解处理器的时候，就想到了使用动态字节码技术，在运行期间放置或修改错误码信息。<br /></p><p><a name="BnrZa"></a></p><h3 id="及时更新错误码内容"><a href="#及时更新错误码内容" class="headerlink" title="及时更新错误码内容"></a>及时更新错误码内容</h3><p>当在后台修改对应的错误码信息后，若开启了周期性刷新，则会定时同步最新数据到本地~~<br /></p><p><a name="P90Ko"></a></p><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p>可以配置是否要同步错误码日志到平台、配置接入码盒的方式、配置是否要定时更新后台同步的错误码信息等等<br /></p><p><a name="Eh02J"></a></p><h3 id="日志排查功能"><a href="#日志排查功能" class="headerlink" title="日志排查功能"></a>日志排查功能</h3><p>当配置了同步错误码日志到平台后，即可在后台查看具体的错误信息，并给出具体的解决方案。<br /></p><p><a name="If95A"></a></p><h3 id="错误日志导出"><a href="#错误日志导出" class="headerlink" title="错误日志导出"></a>错误日志导出</h3><br /><br /><p><a name="slp4k"></a></p><h2 id="项目状况"><a href="#项目状况" class="headerlink" title="项目状况"></a>项目状况</h2><p><a name="SZVna"></a></p><h3 id="已完成事项"><a href="#已完成事项" class="headerlink" title="已完成事项"></a>已完成事项</h3><p>已完成码盒服务、码盒SDK的开发<br /></p><p><a name="fMiLc"></a></p><h3 id="未完成事项"><a href="#未完成事项" class="headerlink" title="未完成事项"></a>未完成事项</h3><p>运营后台相关功能。<br /></p><p><a name="rOATz"></a></p><h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p><a href="https://github.com/qJerry/Code-Box" target="_blank" rel="noopener">https://github.com/qJerry/Code-Box</a></p>]]></content>
      
      
      <categories>
          
          <category> API错误码设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计之错误码（一）</title>
      <link href="/2020/05/03/api-she-ji-zhi-cuo-wu-ma-yi/"/>
      <url>/2020/05/03/api-she-ji-zhi-cuo-wu-ma-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于项目中自己负责的一块业务，经常会出现产品反馈给我“xxx失败了，帮忙看看什么问题”，而我就会马不停蹄地上服务器see logs。再者后续平台可能会做开放API的处理，此时此刻，亟不可待，需要一套完整的错误码设计方案出炉。用户—客服—产品 这一条线就可以通过错误码定位到问题，不用再到最后一步：开发。<br /></p><p><a name="xo9nX"></a></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在参考了几个大厂的错误码规范后，我发现其实每家平台都有不同的考虑而下了不同的功夫，而我自认为比较周全（可能是文档的问题）的是Google Api的文档。<br />“该如何设计呢？”</p><ul><li>首先我想的第一点就是：简单。错误码设计必须简单易懂，不需要多华丽。</li></ul><p>所以我想到的方案就是：定义一个公共枚举类，首先定义出我负责模块的错误码和错误描述，以及解决方案。</p><ul><li>这时脑海中出现了第二个点：如何区分其他模块？一个系统不同业务模块必定会有不同的错误码，不能够让大家随着你的性子走，随便定义一个公共类就完事了吧，有什么亮点呢？</li></ul><p>错误码定制化，包括系统+模块+功能+错误码。<br />“这样就足够了吗？”<br /></p><p><a name="XzVaf"></a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><a name="s3edE"></a></p><h2 id="什么是错误码？"><a href="#什么是错误码？" class="headerlink" title="什么是错误码？"></a>什么是错误码？</h2><p>错误码，对于很多人而言就是一串数字，它关联了系统上的各种错误信息。<br />错误码带给我们的作用是什么？</p><ul><li>告知我们哪个系统哪个模块出了问题；</li><li>告知我们具体是什么问题；</li><li>通过决策和话术转换回显合理的错误内容给用户。</li></ul><p><a name="MiQro"></a></p><h2 id="错误码服务的人群"><a href="#错误码服务的人群" class="headerlink" title="错误码服务的人群"></a>错误码服务的人群</h2><ul><li>对于服务间的调用，即针对技术人员</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1581909865245-0fd083ff-47c3-4b75-bbac-c1ad9e8111ea.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=682&size=13082&status=done&style=none&width=682" alt="image.png"></p><ul><li>对于客户端的调用，即针对非技术人员</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1581909929407-1017b9b0-1422-4c6d-ad7e-40e8ed42e7c9.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=161&originWidth=681&size=12721&status=done&style=none&width=681" alt="image.png"><br /></p><p><a name="rpcKs"></a></p><h2 id="错误码服务的类型"><a href="#错误码服务的类型" class="headerlink" title="错误码服务的类型"></a>错误码服务的类型</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587191468061-1c34aa7e-d62c-4e96-b33e-bb3578a82436.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=386&size=2433&status=done&style=none&width=386" alt="image.png"><br /></p><p><a name="iEyMu"></a></p><h2 id="错误码设计的原则"><a href="#错误码设计的原则" class="headerlink" title="错误码设计的原则"></a>错误码设计的原则</h2><p><a name="t0aFW"></a></p><h3 id="规范的错误代码"><a href="#规范的错误代码" class="headerlink" title="规范的错误代码"></a>规范的错误代码</h3><p><a name="2G6kF"></a></p><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582019707581-16efc7a7-c742-4183-b9ec-5a2327d0e8ca.png#align=left&display=inline&height=122&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=721&size=9264&status=done&style=none&width=721" alt="image.png"><br /></p><ul><li>系统：</li></ul><p>即服务之上的定义，如Saas可以定义为一个系统，其中有一个个的服务<br />一般不用到这个级别的话，默认为0。</p><ul><li>应用：</li></ul><p>即服务，一个系统中可以有多个服务，这里基于实际服务数量，仅限定2位。</p><ul><li>功能：</li></ul><p>即功能接口，例如提现接口、支付接口等等。</p><ul><li>错误码：</li></ul><p>提示级别+自增代码。<br />错误提示级别，1：返回提示；2：返回不提示；3：隐藏性卖萌提示；<br />注意：很多系统都会将错误码和httpcode混合在一块，虽说我们现在大多采用的通信协议为http，但是同时市面上也有其他各种通信协议如dubbo、hessian、thrift等。当出现系统进行重构而更改了通信协议时，或者对接了其他不同通信协议的服务，将会是一件很棘手的事。故错误码应该不与httpcode耦合，而是应抽象出一套自己的selfcode。<br /><br><br />以上规范对于服务提供方而言，是非常适合的，便于快速定位到具体问题；<br />但是对于服务消费方而言，恐怕就无意义了，当我们做成开放API供第三方开发者接入时，就会面临第三方开发者徒增理解和交流的复杂度。</p><p><a name="OmsDp"></a></p><h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1587191743115-adda4354-8385-4311-aa64-8ea572b0cd64.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=375&size=2535&status=done&style=none&width=375" alt="image.png"></p><ul><li>模块：</li></ul><p>可以当做应用来理解，也可以当做功能模块来理解，看系统的架构。</p><ul><li>错误码：</li></ul><p>自增代码。</p><p>相对于第一版而言，它更加简单清晰，且通过模块与错误码的绑定，更加快速定位问题，和降低沟通的成本。</p><p><a name="QBzUp"></a></p><h3 id="规范的错误消息"><a href="#规范的错误消息" class="headerlink" title="规范的错误消息"></a>规范的错误消息</h3><blockquote><p>错误消息应该帮助用户轻松，快速地理解和解决API错误。</p></blockquote><ul><li>不要假定用户是API专家。 用户可以是客户端开发人员，操作人员，IT人员或应用程序的最终用户。</li><li>不要假定用户了解服务实现或熟悉错误的上下文（如日志分析）。</li><li>如果可能，应构造错误消息，以便技术用户（但不一定是您的API开发人员）可以响应错误并进行更正。</li><li>保持错误消息简练。 如果需要请提供链接，这样困惑的读者可以提出问题，提供反馈或获取更多信息（这些信息不一定适合在错误消息中展示）。如果不合适，就可以使用详细信息字段展开。</li></ul><p><a name="Hxfk6"></a></p><h3 id="规范的错误细节（详细信息）"><a href="#规范的错误细节（详细信息）" class="headerlink" title="规范的错误细节（详细信息）"></a>规范的错误细节（详细信息）</h3><p>只有能够帮助应用程序处理错误时，才应该引入错误详细信息；<br />如果错误信息只能由人来处理，则仅依赖错误消息即可；<br />下面是一些示例<code>error_details</code>有效内容：</p><ul><li><code>RetryInfo</code>描述客户端何时可以重试失败的请求，可以返回<code>Code.UNAVAILABLE</code>或<code>Code.ABORTED</code></li><li><code>QuotaFailure</code>描述配额检查如何失败，可以返回<code>Code.RESOURCE_EXHAUSTED</code></li><li><code>BadRequest</code>描述客户端请求中的违例，可以返回<code>Code.INVALID_ARGUMENT</code></li></ul><br /><a name="Uj2EA"></a>### 标准的错误模型基于以上几点，我们可以得到如下大致的错误模型：```javapublic class Status {  // 规范化的错误码  int code = 1;  // 规范化的错误信息  String message = 2;  // 规范化的错误细节描述  Object details = 3;}```<p><a name="eBxrK"></a></p><h3 id="错误重试机制"><a href="#错误重试机制" class="headerlink" title="错误重试机制"></a>错误重试机制</h3><p>对于某些错误，是否需要进行重试的控制（此时也需要考虑API的幂等性）<br /></p><p><a name="L13I7"></a></p><h2 id="错误码的处理方式"><a href="#错误码的处理方式" class="headerlink" title="错误码的处理方式"></a>错误码的处理方式</h2><p>在分布式应用中，一个请求往往涉及到多个服务，这时如果请求出现异常，则不应该盲目将错误从服务端传播到客户端。同时也需要避免出现非技术人员看到技术性的错误。需进行合理翻译：</p><ul><li>隐藏接口实现的详细信息和机密信息。</li><li>调整发生错误的一方。基于自下而上的处理方式，从另一个服务收到错误的服务器，应将该错误层层传播给自己的调用方，最终由最上层的调用方来处理。</li></ul><p><br />类比到日常开发中，我们通常用Springboot搭建Api接口，按照约定的规范，定义了controller、service、dao层。对于一个请求贯通三层导致的异常，想必大多人都不会傻乎乎地使用大量的“try catch”充斥在代码里，而是通过全局异常错误处理器来处理错误。这也是我们惯有的思路。<br /></p><p><a name="OtaJj"></a></p><h2 id="错误码如何分配"><a href="#错误码如何分配" class="headerlink" title="错误码如何分配"></a>错误码如何分配</h2><blockquote><p>我们总会面临这么一个问题，不同业务线的同学，未使用规范好的错误代码，而导致出现同一个错误码出现了不同的错误信息，这样在业务代码中，不仅可能会多做了一些判断的语句，还会增加其他开发人员理解的复杂度。</p></blockquote><ul><li>各个业务线的部门，应该分配对应的错误码区间。</li></ul><p>怎么分配？在新建业务线时，负责人需要向上申请错误码（这里还可以延伸到申请端口、域名之类的信息，这样就可以集中梳理好文档，方便日后的调整）；</p><ul><li>一个业务线部门的多个系统，也应该继续分配对应的错误码区间，这样便能有效避免出现重复的错误码，造成麻烦。分配方式亦可以同上；</li><li>错误码区间，最好也按错误级别分配区间，如系统级别的异常分配a-b区间、业务级别的异常分配c-d区间。</li></ul><br /><p><a name="fmxPu"></a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>另一些思考：<br />确实，对于很多新业务来说，“规范”似乎总不会停留在嘴边，有也大多只会说“嗯，后面要搞的”，往往是“效率至上”。一个需求下来，你做的快，别人就夸你效率高，殊不知其间考虑少了多少东西，进而也许引发后续的重构灾难。<br /><br><br />对于错误码，可能很多人看来，随便定义了一个枚举类，按注释区分好就得了。但是真的够了吗？也许仔细想一下，还真的不够。既然不够，方案来凑。接下来将进行实战篇，开发一套错误码系统。</p>]]></content>
      
      
      <categories>
          
          <category> API错误码设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rabbitmq引发的内存溢出</title>
      <link href="/2020/03/25/rabbitmq-yin-fa-de-nei-cun-yi-chu/"/>
      <url>/2020/03/25/rabbitmq-yin-fa-de-nei-cun-yi-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某一天，和我们配合的中台组给我们部门发了一组新的MQ配置，用于支付回调消息的接收，原来我们的某个项目已经有一个MQ，所以项目需要适配两个MQ（该项目都是作为消费者的角色）。<br><br>rabbitmq使用的版本是<br></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><br>兼容多MQ的代码<br></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>config<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>CachingConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RabbitTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Qualifier<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactoryConfigurer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Primary<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig1</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token keyword">public</span> ConnectionFactory <span class="token function">connectionFactory1</span> <span class="token punctuation">(</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.host}"</span><span class="token punctuation">)</span> String host<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.port}"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.username}"</span><span class="token punctuation">)</span> String username<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.rabbitmq.password}"</span><span class="token punctuation">)</span> String password    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        CachingConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"rabbitTemplate1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Primary</span>    <span class="token keyword">public</span> RabbitTemplate <span class="token function">rabbitTemplate1</span> <span class="token punctuation">(</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        RabbitTemplate rabbitTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"listenerContainerFactory1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> SimpleRabbitListenerContainerFactory <span class="token function">listenerContainerFactory1</span> <span class="token punctuation">(</span>            SimpleRabbitListenerContainerFactoryConfigurer configurer<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory1"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleRabbitListenerContainerFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configurer<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>AcknowledgeMode<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>config<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>CachingConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>support<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>Jackson2JsonMessageConverter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Qualifier<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>SimpleRabbitListenerContainerFactoryConfigurer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>condition<span class="token punctuation">.</span>ConditionalOnProperty<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"pay.callback.message.config.enable"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitConfig2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"connectionFactory2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ConnectionFactory <span class="token function">connectionFactory2</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.host}"</span><span class="token punctuation">)</span> String host<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.port}"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.userName}"</span><span class="token punctuation">)</span> String userName<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pay.callback.rabbitmq.password}"</span><span class="token punctuation">)</span> String password    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        CachingConnectionFactory connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"listenerContainerFactory2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> SimpleRabbitListenerContainerFactory <span class="token function">listenerContainerFactory2</span> <span class="token punctuation">(</span>            SimpleRabbitListenerContainerFactoryConfigurer configurer<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"connectionFactory2"</span><span class="token punctuation">)</span> ConnectionFactory connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        SimpleRabbitListenerContainerFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configurer<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span>factory<span class="token punctuation">,</span> connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setMessageConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setAcknowledgeMode</span><span class="token punctuation">(</span>AcknowledgeMode<span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setDefaultRequeueRejected</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><br><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>开发环境验证通过，发布到测试环境时，出现了以下异常<br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584962184230-94cacf83-10fa-4a66-82e6-b2d0866ac935.png#align=left&display=inline&height=309&originHeight=309&originWidth=1379&status=done&style=none&width=1379" alt><br><br>一下子就精神了，这就是臭名昭著的内存溢出<br>回顾以往出现内存溢出，往往有以下几种</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p><br>#### 堆空间溢出<br>java.lang.OutOfMemoryError: Java heap space<br><br><br>出现的原因一般是</p><ul><li>数据突增。比如突然创建了大对象，超出了最大堆空间内存，可能还来不及回收，也可能根本就无法满足。</li><li>对象堆积。一般是程序编码有问题，导致创建的对象一直堆积在堆内存，无法被GC探测回收。</li></ul><p><a name="5owiu"></a></p><h4 id="永久代溢出"><a href="#永久代溢出" class="headerlink" title="永久代溢出"></a>永久代溢出</h4><p>java.lang.OutOfMemoryError: PermGen space<br></p><p><a name="YBI5C"></a></p><h4 id="元空间溢出"><a href="#元空间溢出" class="headerlink" title="元空间溢出"></a>元空间溢出</h4><p>java.lang.OutOfMemoryError: Metaspace<br><br><br>元空间的概念是在jdk1.8提出来的，用来取代以前的永久代。永久代<br><br><br>遇到这种问题，冷静，接着一步步校验<br><a name="74rSx"></a></p><h3 id="查看jvm启动参数"><a href="#查看jvm启动参数" class="headerlink" title="查看jvm启动参数"></a>查看jvm启动参数</h3><pre class=" language-shell"><code class="language-shell">java -server -Xmx512M -Xms512M -Denv=FAT -XX:+UseCodeCacheFlushing -XX:+HeapDumpOnOutOfMemoryError -Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:-OmitStackTraceInFastThrow -jar /usr/local/application/**.jar</code></pre><p><br>可以看出，启动参数限制了最大堆内存是515M，因为是测试环境，部署了很多个项目，保险起见设置的，平时也都正常。<br><br><br>那就是说调大最大堆内存就可以，接下来试一下把最大堆内存调整为1G。<br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585108515492-d1f2688c-a8e7-431b-b0c3-e9e9d5588f6f.png#align=left&display=inline&height=197&name=image.png&originHeight=394&originWidth=1149&size=34669&status=done&style=none&width=574.5" alt="image.png"><br><br><br>使用了测试环境的配置，更改启动参数，本地运行后，仍然会报错<br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585020549225-b792bbee-e45c-46db-a495-e6134b1b260c.png?x-oss-process=image/resize,w_1492#align=left&display=inline&height=385&originHeight=385&originWidth=1492&status=done&style=none&width=1492" alt><br><br><br>呃。。。。<br></p><p><a name="8EZYi"></a></p><h3 id="查看VisualVm"><a href="#查看VisualVm" class="headerlink" title="查看VisualVm"></a>查看VisualVm</h3><p>这时候打开VisualVm看看，可以看到设置的最大堆大小在1000MB，而已使用的堆内存大小才100多MB，此时能够笃定是创建了大对象而导致的内存溢出。<br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585113933509-612e463d-c2de-4119-8f15-3b08aae91b9d.png#align=left&display=inline&height=198&name=image.png&originHeight=395&originWidth=938&size=39095&status=done&style=none&width=469" alt="image.png"><br><br><br></p><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>这一步开始来断点，排查大对象从哪里来，此时查看报错的源码，发现确实是因为大对象的创建导致<br>代码在<code>com.rabbitmq.client.impl.Frame</code> 类中，Frame是指AMQP协议层面的通信帧。</p><p>对于Frame的理解，可以查看其它博客：<a href="https://blog.csdn.net/usagoole/article/details/83048009" target="_blank" rel="noopener">https://blog.csdn.net/usagoole/article/details/83048009</a><br><br><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585031558601-735fded5-3c8c-4a16-907b-37405ff6aa0a.png?x-oss-process=image/resize,w_968#align=left&display=inline&height=405&originHeight=405&originWidth=968&status=done&style=none&width=968" alt><br><br><br>从上图可以看到，输入流读取的字节数为1345270062，这时候即创建了一个大小为1345270062（1.2G）的字节数组，于是乎出现内存溢出。</p><p>至于为什么会突然读取到这么大的字节数，重新调试，我把断点打在<code>com.rabbitmq.client.impl.SocketFrameHandler</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585114607912-18d1f90f-89d0-4828-a3b0-9bd8be57e17b.png#align=left&display=inline&height=124&name=image.png&originHeight=247&originWidth=1120&size=29771&status=done&style=none&width=560" alt="image.png"></p><p>系统有两个MQ，原有的MQ一切正常，从支付回调MQ开始，就开始报错了，所以初步怀疑是这个MQ账号的问题，或许是账号不对？没有远程登录的权限？</p><p><a name="MOeVr"></a></p><h3 id="理解源码"><a href="#理解源码" class="headerlink" title="理解源码"></a>理解源码</h3><p>Rabbitmq是基于socket连接读取的输入流，再将它转成字节数组。<br>先熟悉一下<code>com.rabbitmq.client.impl.Frame</code><br>帧（Frame），AMQP协议层面的通信帧</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585123637246-3dec2065-2aa4-4df0-98cd-37df07cf4ddd.png#align=left&display=inline&height=179&originHeight=179&originWidth=1162&size=0&status=done&style=none&width=1162" alt><br><br><br>上图从左到右依次为帧类型、通道编号、帧大小、内容、结束标记组成一个帧<br><br><br>从上面调试的代码可以看出，我们是打算取出payload这一段内容时，超出了长度。<br><br><br>再看看以下代码，<br>readInt()的作用是，读取四个输入字节，并做了位移运算，返回一个整型值。<br>一个int存储的是32位的整型数据，32bit = 4 * 1byte，即表明每次从输入流里读取4个字节的数据；<br></p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> payloadSize <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> ch1 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch2 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch3 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ch4 <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch1 <span class="token operator">|</span> ch2 <span class="token operator">|</span> ch3 <span class="token operator">|</span> ch4<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ch1 <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch2 <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch3 <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ch4 <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585130485796-42921d27-6590-4d14-b9db-5f95b68556d5.png#align=left&display=inline&height=168&name=image.png&originHeight=168&originWidth=955&size=18264&status=done&style=none&width=955" alt="image.png"><br><br><br>断点可以看出，返回的整型值，也就是payload的长度，达到了1345270062，这样下一步创建byte对象的时候，就出现内存溢出的事故。</p><p>但是为什么会出现这个大对象，回过头去分析readInt()，<code>in.read()</code>将16进制的网络字节码 转为10进制的数组，正<br>是因为读取的数据有问题，才导致位移运算后得到一个比较大的整型值。<br></p><p><a name="1q2wB"></a></p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>围绕着上面这个问题，此时需要抓个包看看，采取的是边断点边抓包的方式。<br></p><ul><li>打开抓包工具，过滤器设置指定ip为MQ的host</li><li>先断点到111行，接着启动程序</li></ul><p><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585131449012-9dfcd943-bf61-4827-83e7-67fa4b5f1aa8.png#align=left&display=inline&height=130&name=image.png&originHeight=130&originWidth=748&size=15506&status=done&style=none&width=748" alt="image.png"><br></p><ul><li>当打到该断点的时候，看到帧大小比较大的时候，进入readInt()</li></ul><p><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585131606794-e80def82-36f6-40b8-ab8d-beb113afa79a.png#align=left&display=inline&height=274&name=image.png&originHeight=274&originWidth=1157&size=30045&status=done&style=none&width=1157" alt="image.png"><br><br><br>可以看到此时读取的4个数值分别是80、47、49、46，由于是网络字节码转过来的，故转为16进制后，对应为<br></p><pre class=" language-java"><code class="language-java">DEC<span class="token operator">:</span><span class="token number">80</span>    <span class="token number">47</span>    <span class="token number">49</span>    <span class="token number">46</span>HEX<span class="token operator">:</span><span class="token number">50</span>  <span class="token number">2F</span>    <span class="token number">31</span>    2E    </code></pre><ul><li>查看抓包</li></ul><p><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1585132560127-4d4a3dc5-2de0-4f22-aadb-b7557b62093a.png#align=left&display=inline&height=542&name=image.png&originHeight=542&originWidth=717&size=57551&status=done&style=none&width=717" alt="image.png"><br><br><br>从抓包可以看到，字节码对上了，而且看到响应码为400，Bad Request！！！<br><br><br>这也验证了一开始提到的猜测：MQ账号有问题，于是咨询了中台组，最终发现，是因为1.0部门给的端口有问题，导致socket无法连接！<br><br><br></p>]]></content>
      
      
      <categories>
          
          <category> Rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器监控netdata</title>
      <link href="/2020/03/18/fu-wu-qi-jian-kong-netdata/"/>
      <url>/2020/03/18/fu-wu-qi-jian-kong-netdata/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Netdata"><a href="#什么是Netdata" class="headerlink" title="什么是Netdata"></a>什么是Netdata</h1><p>简单一句话，Netdata是一个分布式的实时健康监测系统。</p><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>对象</td><td>针对系统和应用程序的分布式，实时，性能和运行状况监视</td></tr><tr><td>可视化</td><td>Netdata使用高度互动的Web仪表板实时提供无与伦比的洞察力，以实时了解其运行的系统（包括Web服务器，数据库，应用程序）上发生的一切</td></tr><tr><td>自动化与集成化</td><td>它可以自动运行，无需任何第三方组件，也可以集成到现有的监视工具链（Prometheus，Graphite，OpenTSDB，Kafka，Grafana等）</td></tr><tr><td>高效</td><td>Netdata快速高效，旨在永久在所有系统（物理和虚拟服务器，容器，IoT设备）上运行，而不会中断其核心功能</td></tr><tr><td>分布式</td><td>可以针对多个节点进行统一管理</td></tr><tr><td>开源</td><td>Netdata是免费的开源软件，目前可在Linux，FreeBSD和MacOS上运行。</td></tr></tbody></table><p>Netdata诞生的背景，有兴趣的同学可以看看：<a href="https://blog.netdata.cloud/posts/redefining-monitoring-netdata/" target="_blank" rel="noopener">使用Netdata重新定义监视</a></p><p><a name="gXXM9"></a></p><h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>参考：<a href="https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually</a></p><p><a name="eRo7M"></a></p><h2 id="Netdata插件"><a href="#Netdata插件" class="headerlink" title="Netdata插件"></a>Netdata插件</h2><p>以下插件，在安装时可以选择启用或禁用</p><table><thead><tr><th>软件包名</th><th>描述</th></tr></thead><tbody><tr><td><code>bash</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>curl</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>iproute</code> 或 <code>iproute2</code></td><td>用于监控** Linux流量QoS **<br>如果<code>iproute</code>提示不可用或已过时，请使用<code>iproute2</code></td></tr><tr><td><code>python</code></td><td>这对于大多数外部插件来说都是必须的</td></tr><tr><td><code>python-yaml</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-beanstalkc</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-dnspython</code></td><td>用于监控DNS的查询时间</td></tr><tr><td><code>python-ipaddress</code></td><td>用于监控** DHCPd **<br>只有Python V2才需要此软件包。Python V3已经嵌入了此功能</td></tr><tr><td><code>python-mysqldb</code><br>或<br><code>python-pymysql</code></td><td>用于监控<strong>mysql</strong>或<strong>mariadb</strong> 数据库<br><code>python-mysqldb</code>会运行地更快，所以它是首选</td></tr><tr><td><code>python-psycopg2</code></td><td>用于监控<strong>postgresql</strong>数据库</td></tr><tr><td><code>python-pymongo</code></td><td>用于监控<strong>mongodb</strong>数据库</td></tr><tr><td><code>nodejs</code></td><td>用于<code>node.js</code>插件来监控<strong>named</strong>和<strong>SNMP</strong>设备</td></tr><tr><td><code>lm-sensors</code></td><td>用于监控<strong>hardware sensors</strong></td></tr><tr><td><code>libmnl</code></td><td>用于收集netfilter指标</td></tr><tr><td><code>netcat</code></td><td>用于从远程系统中收集指标的Shell插件</td></tr></tbody></table><p>如果安装了上述软件包，Netdata功能将大大增加，但如果没有它们，Netdata仍然可以正常工作</p><p><a name="byYm9"></a></p><h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><blockquote><p>要在任何Linux系统（物理，虚拟，容器，IoT，边缘）上从源代码安装Netdata并使其与最新的版本自动保持最新，请运行以下命令</p></blockquote><pre class=" language-shell"><code class="language-shell"># make sure you run `bash` for your shellbash# install Netdata directly from GitHub sourcebash <(curl -Ss https://my-netdata.io/kickstart.sh)</code></pre><p>自动安装后，netdata默认的配置文件放在<code>/etc/netdata/netdata.conf</code>中</p><p>如果自动安装不顺利的同学， 可以采用手动安装的方式。</p><p><a name="2RgXA"></a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p><a name="deBqx"></a></p><h3 id="安装Netdata所需的软件包"><a href="#安装Netdata所需的软件包" class="headerlink" title="安装Netdata所需的软件包"></a>安装Netdata所需的软件包<br></h3><p><a name="djGNn"></a></p><h4 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h4><p>系统监控和许多应用程序监控，它没有mysql /mariadb，postgres，named，硬件监控和SNMP。</p><pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata</code></pre><br><a name="G0hej"></a>#### 完整安装<pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata-all</code></pre><br><a name="eEtu9"></a>### 安装Netdata<pre class=" language-shell"><code class="language-shell"># 下载Netdata（同时创建netdata目录）git clone https://github.com/netdata/netdata.git --depth=1cd netdata# 运行具有root权限的脚本来编译安装Netdata并启动它./netdata-installer.sh</code></pre><p>注意</p><ul><li>如果不想安装完后启动Netdata，加上<code>--dont-start-it</code> 参数</li><li>如果不想安装在默认目录，则可以这样，<code>./netdata-installer.sh --install /opt</code>，即可安装到<code>/opt/netdata</code> 中</li><li>安装完后， <code>/opt/netdata/etc/netdata/netdata.conf</code>配置文件会自动被创建，可以编辑此文件以更改设置首选项。一个最常见被调整选项是history，它控制Netdata将使用的内存数据库大小。其默认情况下应为“3600”秒（图表中一小时的数据），这使得Netdata将使用大约10-15MB的RAM（取决于系统检测到的图表数量）。请检查内存要求。  当修改配置后，需要重启</li></ul><p><a name="HBX6N"></a></p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>启动，停止和重新启动Netdata</p><pre class=" language-shell"><code class="language-shell">service netdata startservice netdata stopservice netdata restart</code></pre><p>当使用<code>service</code>（系统首选基于系统启动或停止的方法）无法实现的时候，可以尝试对<code>systemd</code>和<code>init.d</code>使用等效命令</p><pre class=" language-shell"><code class="language-shell">systemctl start netdatasystemctl stop netdatasystemctl restart netdata/etc/init.d/netdata start/etc/init.d/netdata stop/etc/init.d/netdata restart</code></pre><p><a name="OpWZX"></a></p><h2 id="访问Netdata仪表盘"><a href="#访问Netdata仪表盘" class="headerlink" title="访问Netdata仪表盘"></a>访问Netdata仪表盘</h2><p>打开<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><br>当出现无法访问的时候，检查下防火墙的状态，测试环境下将它关闭即可（生产环境不建议）。或者查看安全组是否屏蔽了该端口</p><pre class=" language-shell"><code class="language-shell"># 查看防火墙状态firewall-cmd --state# 关闭，或者指定开启某个端口的入站systemctl stop firewalld.service</code></pre><p><a name="qIvfM"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th>路径</th><th>所有者</th><th>权限</th><th>Netdata</th><th>注释</th></tr></thead><tbody><tr><td><code>/etc/netdata</code></td><td>用户  <code>root</code><br>组 <code>netdata</code></td><td>目录<code>0755</code><br>文件<code>0640</code></td><td>读</td><td><strong>Netdata配置文件</strong><br>可能包含敏感信息，因此<code>netdata</code>允许组读取它们。</td></tr><tr><td><code>/usr/libexec/netdata</code></td><td>用户  <code>root</code><br>组 <code>root</code></td><td>任何人都可以执行<br>dirs <code>0755</code><br>文件<code>0644</code>或<code>0755</code></td><td>执行</td><td><strong>Netdata插件</strong><br>权限取决于文件-并非所有<strong>插件</strong>都应具有可执行标志。<br>有一些带有升级权限（Linux功能或<code>setuid</code>）的插件-这些插件应该仅按组可执行<code>netdata</code>。</td></tr><tr><td><code>/usr/share/netdata</code></td><td>用户  <code>root</code><br>组 <code>netdata</code></td><td>任何人的<br>目录<code>0755</code><br>文件都可读<code>0644</code></td><td>通过网络读取和发送</td><td><strong>Netdata Web静态文件</strong><br>这些文件通过网络发送给有权访问Netdata Web服务器的任何人。Netdata会检查这些文件的所有权（使用的<code>[web]</code>部分的设置<code>netdata.conf</code>），如果文件所有权不正确，则拒绝提供这些文件。不支持符号链接。Netdata也拒绝提供<code>..</code>名称中的URL 。</td></tr><tr><td><code>/var/cache/netdata</code></td><td>用户  <code>netdata</code><br>组 <code>netdata</code></td><td>目录<code>0750</code><br>文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata临时数据库文件</strong><br>Netdata在此处存储其临时实时数据库。</td></tr><tr><td><code>/var/lib/netdata</code></td><td>用户  <code>netdata</code><br>组 <code>netdata</code></td><td>目录<code>0750</code><br>文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata永久数据库文件</strong><br>Netdata在此处存储注册表数据，运行状况警报日志db等。</td></tr><tr><td><code>/var/log/netdata</code></td><td>用户  <code>netdata</code><br>组 <code>root</code></td><td>目录<code>0755</code><br>文件<code>0644</code></td><td>写，创造</td><td><strong>Netdata日志记录</strong><br>所有Netdata应用程序，将它们的错误或其他参考消息记录到此目录中的文件中。这些文件应进行日志轮换。</td></tr></tbody></table><p><a name="wvtdc"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a name="5aT8C"></a></p><h2 id="netdata-conf"><a href="#netdata-conf" class="headerlink" title="netdata.conf"></a>netdata.conf</h2><p>参考<a href="https://docs.netdata.cloud/daemon/config/" target="_blank" rel="noopener">https://docs.netdata.cloud/daemon/config/</a><br>可通过<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><a href="http://your_server_ip:19999/netdata.conf" target="_blank" rel="noopener">/netdata.conf</a> 查看netdata的配置信息，注释的配置使用对应的默认值<br>包含了很多配置项，如global、web、plugins、health、registry、cloud、backend、statsd等。每一个配置项下，有key-value的配置，通过key我们能比较快速地知道其含义。</p><p><a name="JP3Wj"></a></p><h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>默认端口为19999</p><pre class=" language-shell"><code class="language-shell">[web]        # default port = 19999</code></pre><p><a name="5EehV"></a></p><h3 id="修改左上角hostname"><a href="#修改左上角hostname" class="headerlink" title="修改左上角hostname"></a>修改左上角hostname</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350636961-acbafd22-e45c-43f3-ad1c-e21b62fe18f5.png#align=left&display=inline&height=81&name=image.png&originHeight=162&originWidth=438&size=11915&status=done&style=none&width=219" alt="image.png"></p><pre class=" language-shell"><code class="language-shell">[global]        hostname = localhost-1</code></pre><p><a name="6QA90"></a></p><h3 id="当配置多个节点后，修改注册节点的名称"><a href="#当配置多个节点后，修改注册节点的名称" class="headerlink" title="当配置多个节点后，修改注册节点的名称"></a>当配置多个节点后，修改注册节点的名称</h3><p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350889946-22b8be07-eb61-41c8-9d86-d355b365c606.png#align=left&display=inline&height=170&name=image.png&originHeight=340&originWidth=558&size=28206&status=done&style=none&width=279" alt="image.png"></strong></p><pre class=" language-shell"><code class="language-shell">[registry]        registry hostname = local192.168.2.57</code></pre><p><a name="jcWWM"></a></p><h3 id="修改内存使用"><a href="#修改内存使用" class="headerlink" title="修改内存使用"></a>修改内存使用</h3><p>Netdata使用history标签作为配置内存使用的key，默认为3996秒，即在图表中你能看到的条目数。</p><p>参考以下估算标准，条目数与对应使用的内存</p><ul><li>3600秒（图表数据保留1小时）使用15 MB RAM</li><li>7200秒（图表数据保留2小时）使用30 MB RAM</li><li>14400秒（图表数据保留4小时）使用60 MB RAM</li><li>28800秒（图表数据保留8小时）使用120 MB RAM</li><li>43200秒（图表数据保留12小时）使用180 MB RAM</li><li>86400秒（24小时图表数据保留）使用360 MB RAM</li></ul><p>假设我想让Netdata保留2个小时的图表数据，则可以配置为</p><pre class=" language-shell"><code class="language-shell">[global]        history = 7200</code></pre><p><a name="3doYv"></a></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>参考<a href="https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start" target="_blank" rel="noopener">https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start</a><br>为了提高性能和安全性，Netdata官方十分建议在Netdata前面添加一个代理。在这里，我们通常使用Nginx作为代理工具，并结合Cerbot来使用。</p><blockquote><p>什么是Cerbot？<br>Certbot是一种工具，可帮助您为您的域创建和续订证书+密钥对，注意，它是免费的！</p></blockquote><p><a name="18wXs"></a></p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>怎么安装和配置Nginx就不说了，这里贴一下官方建议的代理Netdata的配置<br>创建一个文件/etc/nginx/sites-available/netdata，内容如下 </p><pre class=" language-shell"><code class="language-shell">upstream backend {    server 127.0.0.1:19999;    keepalive 64;}server {    listen 80;    # Change `example.com` to match your domain name.    server_name netdata.example.com;    location / {        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://backend;        proxy_http_version 1.1;        proxy_pass_request_headers on;        proxy_set_header Connection "keep-alive";        proxy_store off;    }}</code></pre><p>运行测试配置文件是否正常</p><pre class=" language-shell"><code class="language-shell">sudo nginx -t</code></pre><p>如果没返回错误，再运行以下命令，在<code>sites-enabled</code>目录中创建软链接，重启以生效</p><pre class=" language-shell"><code class="language-shell">sudo ln -s /etc/nginx/sites-available/netdata /etc/nginx/sites-enabled/netdata</code></pre><p><a name="Dcdvn"></a></p><h3 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h3><p>Netdata还建议我们尽可能最大化地使用好代理：加密的HTTPS连接。所以Netdata给我们提供了一个免费的证书生成工具Certbot，使用它，我们将能自动生成证书，并能够支持自动地更新证书，运行以下命令</p><pre class=" language-shell"><code class="language-shell">sudo certbot --nginx</code></pre><p>系统会提示您一些问题。在Which names would you like to activate HTTPS for?提问时，点击 Enter。接下来是这个问题：</p><pre class=" language-shell"><code class="language-shell">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you're confident your site works on HTTPS. You can undo thischange by editing your web server's configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</code></pre><p>如果确定想要强制使用HTTPS的话，则选择2，并且确定。</p><p>这样，我们就真正完成了代理的配置。</p><p><a name="FoKgv"></a></p><h3 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h3><p>当我们把代理设置完后，我们可能还需要一个密码验证，运行以下命令</p><pre class=" language-shell"><code class="language-shell"># 指定用户名为user，添加到.htpasswd文件中sudo sh -c "echo -n 'user:' >> /etc/nginx/.htpasswd"# 创建密码，系统将提示您创建一个密码sudo sh -c "openssl passwd -apr1 >> /etc/nginx/.htpasswd"</code></pre><p>打开Nginx配置文件，添加权限校验的配置吗，授权用户文件指向刚才创建的.htpasswd</p><pre class=" language-shell"><code class="language-shell">location / {        auth_basic "Restricted Content";        auth_basic_user_file /etc/nginx/.htpasswd;        ...}</code></pre><p>接着再重启nginx，即可开启密码校验功能。</p><p><a name="AOm0c"></a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a name="q69aK"></a></p><h2 id="仪表板区域"><a href="#仪表板区域" class="headerlink" title="仪表板区域"></a>仪表板区域</h2><p>Netdata的仪表板主要分为了三个区域：栏目、菜单、节点菜单<br><a name="n4R4n"></a></p><h3 id="栏目"><a href="#栏目" class="headerlink" title="栏目"></a>栏目</h3><p>分为多个部分，例如系统概述，CPU，磁盘，内存等<br>例如下面的内存栏目<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091930943-803eeaa8-14b8-46e2-83cd-e7b6987b027a.png#align=left&display=inline&height=1747&name=memorysection.png&originHeight=1747&originWidth=1108&size=218059&status=done&style=none&width=1108" alt="memorysection.png"></p><p><a name="up7Ct"></a></p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>菜单显示在标准仪表板的右侧，Netdata为每个部分生成一个菜单，菜单链接到它们所关联的部分。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091853647-8a8daaf5-edd2-4864-aa2c-05f7987dca3c.png#align=left&display=inline&height=823&name=menu.png&originHeight=823&originWidth=218&size=29721&status=done&style=none&width=218" alt="menu.png"></p><p><a name="8SCAR"></a></p><h3 id="节点菜单"><a href="#节点菜单" class="headerlink" title="节点菜单"></a>节点菜单</h3><p>节点菜单出现在标准仪表板的左上角，并标有Netdata正在监视的系统的主机名。<br>单击它会显示一个下拉菜单，其中包含您可能已通过Netdata注册表连接的所有节点。<br>默认情况下，“我的节点”标题下没有任何内容，但是您可以尝试使用任何演示Netdata节点来查看节点菜单的工作方式。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091944663-e505e9ef-b2fc-4fa7-bf7e-87dabde524f7.png#align=left&display=inline&height=527&name=nodemenu.png&originHeight=527&originWidth=498&size=53129&status=done&style=none&width=498" alt="nodemenu.png"></p><p>通过Netdata Cloud或专用注册表添加节点后，您将看到它们出现在“我的节点”标题下。</p><p><a name="RA1Ep"></a></p><h2 id="自定义仪表板"><a href="#自定义仪表板" class="headerlink" title="自定义仪表板"></a>自定义仪表板</h2><p>Netdata将有关各个图表的信息存储在/netdata/web/dashboard_info.js文件中。<br>例如，以下是dashboard_info.js如何定义“系统概述”部分的方式。</p><pre class=" language-shell"><code class="language-shell">netdataDashboard.menu = {  'system': {    title: 'System Overview',    icon: '<i class="fas fa-bookmark"></i>',    info: 'Overview of the key system metrics.'  },</code></pre><p>注意，不能直接更改dashboard_info.js，而是应另外新建一个文件，Netdata已经提供了一个示例文件：dashboard_info_custom_example.js</p><pre class=" language-shell"><code class="language-shell">cd /netdata/web/sudo cp dashboard_info_custom_example.js your_dashboard_info_file.js</code></pre><p>自定义文件编写完后，在/netdata/web的目录下使用新建自定义文件的名称即可。</p><pre class=" language-shell"><code class="language-shell">[web] custom dashboard_info.js = your_dashboard_info_file.js</code></pre><p><a name="T1J1H"></a></p><h2 id="使用Netdata-Cloud监视多个系统"><a href="#使用Netdata-Cloud监视多个系统" class="headerlink" title="使用Netdata Cloud监视多个系统"></a>使用Netdata Cloud监视多个系统</h2><p>在第一个节点的仪表板上右上角点击登录按钮，此时Netdata将会发送一封验证邮件，点击链接后，该节点将自动链接到Netdata Cloud的账户，并重定向回仪表板。<br>其他节点也按同样的操作，即可。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584331860428-276e3ea3-bfc4-4150-b9e5-186ecc0dc38b.png#align=left&display=inline&height=228&name=image.png&originHeight=456&originWidth=1903&size=112935&status=done&style=none&width=951.5" alt="image.png"></p><p><a name="MTK90"></a></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><a name="MFI0z"></a></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p><a name="Nnxqc"></a></p><h3 id="无需配置"><a href="#无需配置" class="headerlink" title="无需配置"></a>无需配置</h3><p><a name="Giiq1"></a></p><h3 id="长期指标存储"><a href="#长期指标存储" class="headerlink" title="长期指标存储"></a>长期指标存储</h3><p>使用我们的新数据库引擎，您可以存储每秒数天，数周或数月的历史指标。或者，您可以将指标归档到另一个数据库，例如MongoDB或Prometheus。</p><p><a name="bySdN"></a></p><h3 id="分布式，按系统安装"><a href="#分布式，按系统安装" class="headerlink" title="分布式，按系统安装"></a>分布式，按系统安装</h3><p>您无需将度量标准集中在一个位置，而是在每个系统上安装Netdata ，每个系统负责其度量标准。拥有分布式代理可以降低成本，并使Netdata可以在资源很少的设备（例如IoT和边缘设备）上运行，而不会影响其核心目的。</p><p><a name="jlznB"></a></p><h3 id="完善的健康监控功能"><a href="#完善的健康监控功能" class="headerlink" title="完善的健康监控功能"></a>完善的健康监控功能</h3><p>可确保您始终知道异常发生的时间</p><p><a name="HYtLj"></a></p><h3 id="高速，资源少的收集器"><a href="#高速，资源少的收集器" class="headerlink" title="高速，资源少的收集器"></a><strong>高速，资源少的收集器</strong></h3><p>每秒可以收集数千个指标，同时仅使用系统CPU资源的一小部分和少量MiB RAM。</p><p><a name="ghJbb"></a></p><h3 id="Netdata-Cloud"><a href="#Netdata-Cloud" class="headerlink" title="Netdata Cloud"></a>Netdata Cloud</h3><p>可帮助Netdata用户监视整个基础结构的运行状况和性能，无论它们是两千个（或两千个（或更多）！）系统。<br>如果使用Netdata监视多个系统，则Netdata Cloud可以提供集中监控解决方案的所有优势，同时又可以将工作负载分配给每个代理。<br>而且，更好的是，Netdata Cloud不存储系统的任何指标。它存储有关系统IP，主机名和随机创建的GUID的元数据，仅此而已。指标从系统直接流式传输到Web浏览器。<br>本质上，Web浏览器托管一个SaaS应用程序，并将Netdata Cloud的所有功能直接嵌入到仪表板中。<br>**<br><a name="mA1hH"></a></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>祥见：<a href="https://docs.netdata.cloud/zh/docs/netdata-security/" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/docs/netdata-security/</a></p><p><a name="1KwLD"></a></p><h3 id="数据安全性"><a href="#数据安全性" class="headerlink" title="数据安全性"></a>数据安全性</h3><p>Netdata连接的数据源获取的原始数据只会保留在收集的主机，暴露出去的数据是图表元数据和度量标准值。</p><p><a name="Dwlwi"></a></p><h3 id="系统安全性"><a href="#系统安全性" class="headerlink" title="系统安全性"></a>系统安全性</h3><ul><li>Netdata守护程序，在收集系统以及因应用程序的各项指标时，以普通系统用户身份运行，没有构造特殊的特权。</li><li>从Netdata插件到Netdata守护程序，是通讯单向的，原始数据的不会离开收集过程，不会被保存；</li></ul><p><a name="KlAz0"></a></p><h3 id="只读收集指标"><a href="#只读收集指标" class="headerlink" title="只读收集指标"></a>只读收集指标</h3><p>Netdata只可以读取收集的指标，但是不能进行其他操作，也不会公开敏感信息和业务数据，如内核版本、O/S版本，应用程序版本等</p><p><a name="N0MJH"></a></p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>作为一个监视系统，查看者可以看到监视器上的所有的指标信息，此时应当受到保护，否则会出现 </p><ul><li><p>根据视图内容，进行探索测试DDOS攻击的入口</p><blockquote><p>什么是DDOS攻击？<br>分布式拒绝服务。短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线</p></blockquote></li><li><p>使用Netdata本身来给服务器施加压力，尽管只具有最低的进程优先级，仍可以导致OOM</p></li></ul><p><a name="e9VtT"></a></p><h1 id="github传送门"><a href="#github传送门" class="headerlink" title="github传送门"></a><a href="https://github.com/netdata/netdata/" target="_blank" rel="noopener">github传送门</a></h1><p><a name="bmtLw"></a></p><h1 id="Netdata中文汉化版"><a href="#Netdata中文汉化版" class="headerlink" title="Netdata中文汉化版"></a><a href="https://github.com/Fhaohaizi/netdata" target="_blank" rel="noopener">Netdata中文汉化版</a></h1>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务调度平台XXL-JOB</title>
      <link href="/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/"/>
      <url>/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/</url>
      
        <content type="html"><![CDATA[<h1 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h1><p>以往系统中的周期性任务执行，一般有以下几种方式</p><ul><li>引入quartz or spring-task ，每一个任务对应编写一个执行类，配置调度规则执行</li><li>使用系统的执行器，比如centos的crontab，每一个任务对应编写一个执行类，并在crontab 配置调度规则</li></ul><p>此时，又会出现以下的问题</p><ul><li>任务出现异常，需增加报警功能</li><li>任务出现阻塞，比如上一次任务没执行完，下次任务会排队等待，以此累积</li><li>任务超时，需自己主动中断任务</li><li>单机任务调度下，系统出现异常，比如内存爆掉，磁盘空间不够用</li><li>任务失败，需hardcode 指定次数重试</li><li>在没有配日志可视化的前提下，查看日志需要去服务器上敲命令，面临rm -rf *的风险</li><li>…</li></ul><p><a name="03456e8f"></a></p><h1 id="二、什么是xxl-job"><a href="#二、什么是xxl-job" class="headerlink" title="二、什么是xxl-job"></a>二、什么是xxl-job</h1><p>XXL-JOB是一个轻量级分布式任务调度平台，支持通过 Web 页面对任务进行 CRUD 操作，支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，支持在线配置调度任务入参和在线查看调度结果。</p><p>它的特点有：</p><p>平台：</p><ul><li>调度中心式设计</li><li>解耦</li><li>用DB实现注册中心，实现轻量级部署</li><li>弹性扩、缩容</li><li>故障转移：执行器集群某台机器出现故障，能够自动切换正常的执行器</li><li>分片广播：且支持动态分片，提升任务运行效率</li><li>路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li><li>全异步化：异步调度和异步执行。</li></ul><p>任务：</p><ul><li>任务分布式执行</li><li>简单：支持通过web对任务进行crud</li><li>灵活：动态修改任务状态，自定义失败重试次数等，且即时生效</li><li>告警：任务失败，支持邮件告警</li></ul><p><a name="4a91069d"></a></p><h1 id="三、概念说明"><a href="#三、概念说明" class="headerlink" title="三、概念说明"></a>三、概念说明</h1><p><a name="0e46d8d6"></a></p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>调度任务，系统角色中的最小单元、</p><ul><li>可通过webide（GLUE模式） 或者ide（BEAN模式）自定义任务内容</li><li>支持多种路由策略和阻塞处理策略的选择</li><li>支持自定义失败重试次数和任务超时时间</li><li>支持任务失败告警</li><li>支持动态修改任务状态和各个配置策略的修改</li></ul><p><a name="f59ddb66"></a></p><h2 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h2><p>统一管理任务调度平台上的调度任务，负责触发调度执行，并提供可视化平台管理</p><p><a name="96a9b743"></a></p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>主要负责接收“调度中心”的调度并执行</p><p><a name="4e82ca40"></a></p><h1 id="四、安装启动"><a href="#四、安装启动" class="headerlink" title="四、安装启动"></a>四、安装启动</h1><p><a name="f26ef914"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job</a></p><p><a name="b6780d84"></a></p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Maven3+</li><li>JDK1.7+</li><li>MYSQL5.6+</li></ul><p><a name="1fa42afe"></a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a name="XzoRW"></a></p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>sql脚本在源码内，用navicat工具导入即可</p><pre class=" language-go"><code class="language-go">doc<span class="token operator">/</span>db<span class="token operator">/</span>tables_xxl_job<span class="token punctuation">.</span>sql</code></pre><p><a name="XHMkH"></a></p><h3 id="调度数据库配置说明"><a href="#调度数据库配置说明" class="headerlink" title="调度数据库配置说明"></a>调度数据库配置说明</h3><pre class=" language-go"><code class="language-go"><span class="token operator">-</span> xxl_job_lock：任务调度锁表；<span class="token operator">-</span> xxl_job_group：执行器信息表，维护任务执行器信息；<span class="token operator">-</span> xxl_job_info：调度扩展信息表： 用于保存XXL<span class="token operator">-</span>JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；<span class="token operator">-</span> xxl_job_log：调度日志表： 用于保存XXL<span class="token operator">-</span>JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；<span class="token operator">-</span> xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；<span class="token operator">-</span> xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；<span class="token operator">-</span> xxl_job_user：系统用户表；</code></pre><p><a name="WnTWG"></a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre class=" language-go"><code class="language-go">xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin：调度中心xxl<span class="token operator">-</span>job<span class="token operator">-</span>core：公共依赖xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>spring：Spring版本，通过Spring容器管理执行器，比较通用；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>frameless：无框架版本；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>jfinal：JFinal版本，通过JFinal管理执行器；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>nutz：Nutz版本，通过Nutz管理执行器；</code></pre><p><a name="UuWM4"></a></p><h3 id="配置部署“调度中心”（xxl-job-admin）"><a href="#配置部署“调度中心”（xxl-job-admin）" class="headerlink" title="配置部署“调度中心”（xxl-job-admin）"></a>配置部署“调度中心”（xxl-job-admin）</h3><p><a name="8rQNF"></a></p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">### web</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080</span><span class="token attr-name">server.context-path</span><span class="token punctuation">=</span><span class="token attr-value">/xxl-job-admin</span><span class="token comment" spellcheck="true">### resources</span><span class="token attr-name">spring.mvc.static-path-pattern</span><span class="token punctuation">=</span><span class="token attr-value">/static/**</span><span class="token attr-name">spring.resources.static-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/static/</span><span class="token comment" spellcheck="true">### freemarker</span><span class="token attr-name">spring.freemarker.templateLoaderPath</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/templates/</span><span class="token attr-name">spring.freemarker.suffix</span><span class="token punctuation">=</span><span class="token attr-value">.ftl</span><span class="token attr-name">spring.freemarker.charset</span><span class="token punctuation">=</span><span class="token attr-value">UTF-8</span><span class="token attr-name">spring.freemarker.request-context-attribute</span><span class="token punctuation">=</span><span class="token attr-value">request</span><span class="token attr-name">spring.freemarker.settings.number_format</span><span class="token punctuation">=</span><span class="token attr-value">0.##########</span><span class="token comment" spellcheck="true">### mybatis</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/mybatis-mapper/*Mapper.xml</span><span class="token comment" spellcheck="true">### xxl-job, datasource</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">123456</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.tomcat.jdbc.pool.DataSource</span><span class="token attr-name">spring.datasource.tomcat.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">10000</span><span class="token attr-name">spring.datasource.tomcat.max-active</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">spring.datasource.tomcat.test-on-borrow</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.datasource.tomcat.validation-query</span><span class="token punctuation">=</span><span class="token attr-value">SELECT 1</span><span class="token attr-name">spring.datasource.tomcat.validation-interval</span><span class="token punctuation">=</span><span class="token attr-value">30000</span><span class="token comment" spellcheck="true">### xxl-job email</span><span class="token attr-name">spring.mail.host</span><span class="token punctuation">=</span><span class="token attr-value">smtp.qq.com</span><span class="token attr-name">spring.mail.port</span><span class="token punctuation">=</span><span class="token attr-value">25</span><span class="token attr-name">spring.mail.username</span><span class="token punctuation">=</span><span class="token attr-value">xxx@qq.com</span><span class="token attr-name">spring.mail.password</span><span class="token punctuation">=</span><span class="token attr-value">xxx</span><span class="token attr-name">spring.mail.properties.mail.smtp.auth</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.enable</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.required</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.socketFactory.class</span><span class="token punctuation">=</span><span class="token attr-value">javax.net.ssl.SSLSocketFactory</span><span class="token comment" spellcheck="true">### xxl-job, access token</span><span class="token attr-name">xxl.job.accessToken</span><span class="token punctuation">=</span><span class="token comment" spellcheck="true">### xxl-job, i18n (default empty as chinese, "en" as english)</span><span class="token attr-name">xxl.job.i18n</span><span class="token punctuation">=</span></code></pre><p><a name="z5SBq"></a></p><h4 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h4><p><a name="KcwZA"></a></p><h5 id="方式一：项目打包部署"><a href="#方式一：项目打包部署" class="headerlink" title="方式一：项目打包部署"></a>方式一：项目打包部署</h5><ul><li>打包xxl-job-admin</li><li>调度中心访问地址：<a href="http://localhost:8080/xxl-job-admin" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin</a> (该地址执行器将会使用到，作为回调地址)<br><br>默认登录账号：admin    默认登录密码：123456</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786646307-a2fc191b-157e-4652-bd27-4a04bb881c71.jpeg#align=left&display=inline&height=689&name=center.jpg&originHeight=689&originWidth=1274&size=49771&status=done&style=none&width=1274" alt="center.jpg"></p><p><a name="d4afdc1b"></a></p><h5 id="方式二：Docker镜像搭建"><a href="#方式二：Docker镜像搭建" class="headerlink" title="方式二：Docker镜像搭建"></a>方式二：Docker镜像搭建</h5><ul><li><p>下载镜像</p><pre class=" language-shell"><code class="language-shell">docker pull xuxueli/xxl-job-admin</code></pre></li><li><p>创建容器</p><blockquote><p>由于官方镜像的配置文件（application.properties）是默认的，这里需要通过 “PARAMS” 指定，参数格式 RAMS=”–key=value  –key2=value2” 去修改；</p></blockquote></li></ul><pre class=" language-shell"><code class="language-shell">docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&characterEncoding=UTF-8" -p 8082:8080 -v /tmp:/data/applogs --name xxl-job-admin  -d xuxueli/xxl-job-admin</code></pre><ul><li>运行<pre class=" language-shell"><code class="language-shell">mvn clean packagedocker build -t xuxueli/xxl-job-admin ./xxl-job-admindocker run --name xxl-job-admin -p 8080:8080 -d xuxueli/xxl-job-admin</code></pre><a name="f68af6d7"></a><h5 id><a href="#" class="headerlink" title></a></h5><a name="hg5x5"></a><h5 id="调度中心集群（可选-）"><a href="#调度中心集群（可选-）" class="headerlink" title="调度中心集群（可选 ）"></a>调度中心集群（可选 ）</h5></li></ul><p>调度中心支持集群部署，提升调度系统容灾和可用性。<br>调度中心集群部署时，几点要求和建议：</p><ul><li>DB配置保持一致；</li><li>登陆账号配置保持一致；</li><li>集群机器时钟保持一致（单机集群忽视）；</li><li>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。</li></ul><p><a name="vz4xh"></a></p><h3 id="配置部署“执行器项目”（xxl-job-executor-sample）"><a href="#配置部署“执行器项目”（xxl-job-executor-sample）" class="headerlink" title="配置部署“执行器项目”（xxl-job-executor-sample）"></a>配置部署“执行器项目”（xxl-job-executor-sample）</h3><ul><li>执行器配置application.properties</li></ul><pre class=" language-go"><code class="language-go"># web portserver<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">8081</span># log configlogging<span class="token punctuation">.</span>config<span class="token operator">=</span>classpath<span class="token punctuation">:</span>logback<span class="token punctuation">.</span>xml### 调度中心部署跟地址 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行<span class="token string">"执行器心跳注册"</span>和<span class="token string">"任务结果回调"</span>；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>addresses<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin### 执行器AppName <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：执行器心跳注册分组依据；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>appname<span class="token operator">=</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample### 执行器IP <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 <span class="token string">"执行器注册"</span> 和 <span class="token string">"调度中心请求并触发任务"</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>ip<span class="token operator">=</span>### 执行器端口号 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：小于等于<span class="token number">0</span>则自动获取；默认端口为<span class="token number">9999</span>，单机部署多个执行器时，注意要配置不同执行器端口xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">9999</span>### 执行器通讯TOKEN <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：非空时启用xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>accessToken<span class="token operator">=</span>### 执行器运行日志文件存储磁盘路径 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：需要对该路径拥有读写权限；为空则使用默认路径xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logpath<span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>applogs<span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">/</span>jobhandler### 执行器日志保存天数 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：值大于<span class="token number">3</span>时生效，启用执行器Log文件定期清理功能，否则不生效xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logretentiondays<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span></code></pre><ul><li>部署项目<br>官方提供了多种执行器的示例项目，这里默认使用springboot。<br>执行器集群（可选）<br><br><br>执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。<br><br>执行器集群部署时，几点要求和建议：<ul><li>执行器回调地址（xxl.job.admin.addresses）需要保持一致；执行器根据该配置进行执行器自动注册等操作。</li><li>同一个执行器集群内AppName（xxl.job.executor.appname）需要保持一致；调度中心根据该配置动态发现不同集群的在线执行器列表。</li></ul></li></ul><p><a name="26cc147d"></a></p><h1 id="五、开发"><a href="#五、开发" class="headerlink" title="五、开发"></a>五、开发</h1><blockquote><p>任务运行模式主要有Bean模式和Gule模式（理解为脚本）</p></blockquote><p><a name="048b136f"></a></p><h2 id="BEAN模式"><a href="#BEAN模式" class="headerlink" title="BEAN模式"></a>BEAN模式</h2><blockquote><p>在该模式下，任务的具体实现逻辑是 以JobHandler的形式存在于“执行器项目”中。</p></blockquote><ul><li>步骤一：新建执行器项目</li></ul><p>这里只要copy 项目<code>xxl-job-executor-sample-springboot</code> 即可</p><ul><li>步骤二：修改执行器appname</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> <span class="token string">"classpath:logback.xml"</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">xxl</span><span class="token punctuation">:</span>  <span class="token key atrule">job</span><span class="token punctuation">:</span>    <span class="token key atrule">accessToken</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">addresses</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8080/xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>admin    <span class="token key atrule">executor</span><span class="token punctuation">:</span>      <span class="token key atrule">appname</span><span class="token punctuation">:</span> xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>executor<span class="token punctuation">-</span>test      <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">''</span>      <span class="token key atrule">logpath</span><span class="token punctuation">:</span> /data/applogs/xxl<span class="token punctuation">-</span>job/jobhandler      <span class="token key atrule">logretentiondays</span><span class="token punctuation">:</span> <span class="token number">-1</span>      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9999</span></code></pre><ul><li>步骤三：新建一个任务Handler：TestJobHandler</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>ReturnT<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>IJobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>JobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>log<span class="token punctuation">.</span>XxlJobLogger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p>Title:lyy-modular-saas-api&lt;/p> * &lt;p>Desc: 运行模式为Bean模式&lt;/p> * 开发步骤： * 1、继承"IJobHandler"：“com.xxl.job.core.handler.IJobHandler”； * 2、注册到Spring容器：添加“@Component”注解，被Spring容器扫描为Bean实例； * 3、注册到执行器工厂：添加“@JobHandler(value="自定义jobhandler名称")”注解，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 4、执行日志：需要通过 "XxlJobLogger.log" 打印执行日志； * @author Jerry * @version 1.0 * @since 2019/8/8 */</span><span class="token annotation punctuation">@JobHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"testJobHandler"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJobHandler</span> <span class="token keyword">extends</span> <span class="token class-name">IJobHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execute</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# start to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"beat at:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# end to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>步骤四：执行器管理，新增执行器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786788896-d5796647-8a22-4b58-95dd-10dff177e364.jpeg#align=left&display=inline&height=472&name=actuator.jpg&originHeight=472&originWidth=601&size=11783&status=done&style=none&width=601" alt="actuator.jpg"></p><ul><li>步骤五：任务管理，新建调度任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786798752-af536e8e-0f70-4e85-a1a2-d9bdc2218c98.jpeg#align=left&display=inline&height=533&name=task.jpg&originHeight=533&originWidth=901&size=23727&status=done&style=none&width=901" alt="task.jpg"></p><ul><li>步骤六：执行任务，并查看日志</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786809410-16cd6399-94c2-44b3-8f79-41e91ddff21d.jpeg#align=left&display=inline&height=414&name=console_log.jpg&originHeight=414&originWidth=891&size=36655&status=done&style=none&width=891" alt="console_log.jpg"></p><p>可以看到，这里成功执行了先前自定义的调度任务，并输出了log，结合代码分析，任务执行的log通过<code>XxlJobLogger.log</code>记录并写到日志表内，调度中心后台读取日志表得到详细的log</p><p><a name="958f5368"></a></p><h2 id="GLUE模式"><a href="#GLUE模式" class="headerlink" title="GLUE模式"></a>GLUE模式</h2><blockquote><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定JobHandler</p></blockquote><p>拿GULE模式（JAVA）来解释，每一个GLUE模式的代码，在“执行器”接受到调度请求时，会通过Groovy类加载器加载出代码，并实例化成Java对象，同时注入此代码中声明的Spring服务（这里要确保代码中所引用的类或服务在“执行器项目中存在”），接着调用该对象的execute方法，执行具体的任务逻辑。</p><ul><li>步骤一：任务管理，新建调度任务<br></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786826556-7207d017-d8a7-4837-aabd-48381a7d4824.jpeg#align=left&display=inline&height=533&name=task_glue.jpg&originHeight=533&originWidth=902&size=24651&status=done&style=none&width=902" alt="task_glue.jpg"></p><ul><li>步骤二：点击操作，选择GLUE IDE，进入Web Ide界面<br></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786835674-f696b25f-cb86-48ff-ae46-f60eb95a042e.jpeg#align=left&display=inline&height=408&name=web_ide.jpg&originHeight=408&originWidth=694&size=13347&status=done&style=none&width=694" alt="web_ide.jpg"></p><p><a name="21449655"></a></p><h2 id="任务执行失败-邮件告警"><a href="#任务执行失败-邮件告警" class="headerlink" title="任务执行失败-邮件告警"></a>任务执行失败-邮件告警</h2><ul><li>步骤一：在之前 <code>3.3.1 更改配置</code>中，有相关邮件报警的发送方配置，配置即可</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">### 这里是用腾讯企业邮箱测试</span>spring.mail.host=smtp.exmail.qq.comspring.mail.port=465spring.mail.username=error@qq.comspring.mail.password=123456</code></pre><ul><li>步骤二：在 <code>任务管理，新建调度任务</code>中，配置接收告警邮件的邮箱，多个用“,”隔开即可</li></ul><p>相关的处理逻辑在调度中心的<code>JobFailMonitorHelper</code>类中</p><p><a name="6911d0e4"></a></p><h2 id="分片广播-amp-动态分片"><a href="#分片广播-amp-动态分片" class="headerlink" title="分片广播&amp;动态分片"></a>分片广播&amp;动态分片</h2><blockquote><p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。<br>使用场景：</p><ol><li>分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；</li><li>广播任务场景：广播执行器机器运行shell脚本、广播集群节点进行缓存更新等</li></ol></blockquote><p><a name="z07er"></a></p><h3 id="步骤一：执行器集群部署，暂设置为2个节点"><a href="#步骤一：执行器集群部署，暂设置为2个节点" class="headerlink" title="步骤一：执行器集群部署，暂设置为2个节点"></a>步骤一：执行器集群部署，暂设置为2个节点</h3><p>执行器管理可以看到：一个APP有两个机器地址</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786903400-2e72b744-8d2d-42d5-bc4f-1bea33e059f3.jpeg#align=left&display=inline&height=337&name=actuators.jpg&originHeight=337&originWidth=1528&size=21343&status=done&style=none&width=1528" alt="actuators.jpg"></p><p><a name="A7kJB"></a></p><h3 id="步骤二：新增or更新任务，更改路由策略为分片广播"><a href="#步骤二：新增or更新任务，更改路由策略为分片广播" class="headerlink" title="步骤二：新增or更新任务，更改路由策略为分片广播"></a>步骤二：新增or更新任务，更改路由策略为分片广播</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786916544-715046ad-6150-40bb-a59b-01918374aa3c.jpeg#align=left&display=inline&height=531&name=broadcast.jpg&originHeight=531&originWidth=898&size=23259&status=done&style=none&width=898" alt="broadcast.jpg"></p><p><a name="02TFX"></a></p><h3 id="步骤三：编写业务代码"><a href="#步骤三：编写业务代码" class="headerlink" title="步骤三：编写业务代码"></a>步骤三：编写业务代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分片参数</span>ShardingUtil<span class="token punctuation">.</span>ShardingVO shardingVO <span class="token operator">=</span> ShardingUtil<span class="token punctuation">.</span><span class="token function">getShardingVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"分片参数1：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 业务逻辑</span><span class="token comment" spellcheck="true">// ...</span></code></pre><p><a name="wybCl"></a></p><h3 id="步骤四：执行任务，查看运行日志"><a href="#步骤四：执行任务，查看运行日志" class="headerlink" title="步骤四：执行任务，查看运行日志"></a>步骤四：执行任务，查看运行日志</h3><pre class=" language-verilog"><code class="language-verilog"># 节点<span class="token number">1</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 分片参数：当前分片序号 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 命中分片开始处理<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 忽略# 节点<span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 分片参数<span class="token number">1</span>：当前分片序号 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 忽略<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 命中分片开始处理</code></pre><p>可以看到一个集群的两个节点都收到了分片调度请求，业务逻辑即可针对对应的分片序号进行业务逻辑分片处理！</p><p><a name="6346b6d9"></a></p><h1 id="六、架构设计"><a href="#六、架构设计" class="headerlink" title="六、架构设计"></a>六、架构设计</h1><p><a name="41db83b4"></a></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>实现 调度+任务 两者解耦</li><li>调度行为在调度中心（admin后台），负责发起调度请求</li><li>任务抽象化为一个个JobHandler，交由“<code>执行器</code>”统一管理，“<code>执行器</code>”负责接收调度请求并找到对应的JobHandler，执行具体的业务逻辑（execute）</li></ul><p><a name="ff23e032"></a></p><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><ul><li><strong>调度模块（调度中心）</strong>： 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块； 支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>： 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效； 接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p><a name="65aa05f0"></a></p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582786987822-69688faa-9f2b-4d55-aea8-012599876e51.png#align=left&display=inline&height=822&name=architecture.png&originHeight=822&originWidth=1562&size=376301&status=done&style=none&width=1562" alt="architecture.png"></p><p><a name="ec0ef4cd"></a></p><h3 id="架构特性"><a href="#架构特性" class="headerlink" title="架构特性"></a>架构特性</h3><ul><li>解耦<br><br><code>调度中心</code> 通过类rpc的调用模式，调用<code>执行器</code>暴露的远程服务；<br><br>详见日志远程调用源码：</li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>invoker<span class="token punctuation">.</span>reference<span class="token punctuation">.</span>XxlRpcReferenceBean#getObject</code></pre><ul><li><p>线程池<br><br>调度采用线程池方式实现，避免用单线程出现阻塞而导致任务调度延迟；</p></li><li><p>并行调度<br><br>调度模块采用并行机制，而调度传递到<code>执行器</code>则是串行执行</p></li><li><p>多种路由策略</p></li><li><p>过期处理策略<br><br>过期5s内立即触发一次，过期超5s则忽略</p></li><li><p>日志回调服务<br><br><code>“执行器”</code>在收到调度请求并执行任务后，会将任务的执行结果回调通知给调度中心，调度中心再对应更新日志表。<br><br>执行器触发回调线程处理源码：</p></li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>TriggerCallbackThread#doCallback</code></pre><ul><li><p>调度中心接受回调源码：</p><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>AdminBizImpl#<span class="token function">callback</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>HandleCallbackParam<span class="token punctuation">)</span></code></pre></li><li><p>任务集群<br><br>执行器如若集群部署，调度中心将会感知到在线的所有执行器</p></li><li><p>全异步化</p><ul><li>异步调度：调度中心每次任务触发时仅发送一次调度请求，该调度请求首先推送“异步调度队列”，然后异步推送给远程执行器</li><li>异步执行：执行器会将请求存入“异步执行队列”并且立即响应调度中心，异步运行。</li></ul></li><li><p>轻量级设计<br><br>XXL-JOB调度中心中每个JOB逻辑非常 “轻”，在全异步化的基础上，单个JOB一次运行平均耗时基本在 “10ms” 之内（基本为一次请求的网络开销）；因此，可以保证使用有限的线程支撑大量的JOB并发运行</p></li></ul><p><a name="ab715697"></a></p><h3 id="通讯流程分析"><a href="#通讯流程分析" class="headerlink" title="通讯流程分析"></a>通讯流程分析</h3><ul><li><code>调度中心</code>向<code>执行器</code>发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌Server，默认端口9999;</li><li><code>执行器</code>执行任务逻辑</li><li><code>执行器</code>http回调<code>调度中心</code>调度结果: <code>调度中心</code>中接收回调的服务，是针对<code>执行器</code>开放一套API服务;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> XXL-JOB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（二）初识Netty</title>
      <link href="/2020/02/21/netty-wa-jue-ji-er-chu-shi-netty/"/>
      <url>/2020/02/21/netty-wa-jue-ji-er-chu-shi-netty/</url>
      
        <content type="html"><![CDATA[<p>上一遍大致讲了Netty的基础：JAVA NIO，和最早的BIO</p><p>这一回开始着手聊一下Netty的特性及实现流程</p><p>Netty 是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器<br />和客户端。</p><p><a name="79d24e74"></a></p><h2 id="Netty的特性"><a href="#Netty的特性" class="headerlink" title="Netty的特性"></a>Netty的特性</h2><p>以下内容摘自《Netty 实战》</p><table><thead><tr><th>分类</th><th>Netty 的特性</th></tr></thead><tbody><tr><td>设计</td><td>统一的 API，支持多种传输类型，阻塞的和非阻塞的；简单而强大的线程模型；真正的无连接数据报套接字支持；链接逻辑组件以支持复用</td></tr><tr><td>易于使用</td><td>-</td></tr><tr><td>性能</td><td>拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟；得益于池化和复用，拥有更低的资源消耗；最少的内存复制</td></tr><tr><td>健壮性</td><td>不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError；消除在高速网络中 NIO 应用程序常见的不公平读/写比率</td></tr><tr><td>安全性</td><td>完整的 SSL/TLS 以及 StartTLS 支持；可用于受限环境下，如 Applet 和 OSGI</td></tr></tbody></table><p><a name="fed85108"></a></p><h2 id="Netty服务端实现流程"><a href="#Netty服务端实现流程" class="headerlink" title="Netty服务端实现流程"></a>Netty服务端实现流程</h2><p><a name="7ea27cc2"></a></p><h3 id="实现自定义的handler"><a href="#实现自定义的handler" class="headerlink" title="实现自定义的handler"></a>实现自定义的handler</h3><p>每个服务都会有自己内部的处理逻辑，Netty内置了handler处理I/O事件。</p><p>我们先尝试实现一个handler，逻辑是接受入站数据并返回</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>ByteBuf<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span>Unpooled<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelFutureListener<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelHandlerContext<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelInboundHandlerAdapter<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>ChannelHandler<span class="token punctuation">.</span>Sharable<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>util<span class="token punctuation">.</span>CharsetUtil<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpChannelInboundHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ByteBuf in <span class="token operator">=</span> <span class="token punctuation">(</span>ByteBuf<span class="token punctuation">)</span> msg<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Server received:"</span> <span class="token operator">+</span> in<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>CharsetUtil<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将消息写入缓冲区，并调用flush强行输出到远端节点</span>        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span>ChannelHandlerContext ctx<span class="token punctuation">,</span> Throwable cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 出现异常则关闭连接</span>        cause<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，我们的处理器HttpChannelInboundHandler继承了ChannelInboundHandlerAdapter，而ChannelInboundHandlerAdapter是Netty 提供的ChannelInboundHandler的实现类之一。所以我们可以通过覆盖它们的方法来实现自己的业务逻辑处理。关于Handler这块具体的内容我们后面再细讲</p><p><a name="channelRead"></a></p><h4 id="channelRead"><a href="#channelRead" class="headerlink" title="channelRead"></a>channelRead</h4><pre><code>客户端发送数据包过来时，在收到该数据包时，该方法会被调用。当前我们定义的接收数据类型为ByteBufChannelHandlerContext对象提供了许多操作。我们这里是将接收到的数据写入到缓冲区，再调用flush()将其冲刷到通道</code></pre><p><a name="exceptionCaught"></a></p><h4 id="exceptionCaught"><a href="#exceptionCaught" class="headerlink" title="exceptionCaught"></a>exceptionCaught</h4><pre><code>当服务出现异常时，会调用该方法。通常我们会在这里记录异常信息，并关闭对应的通道。</code></pre><p><a name="33d81c9d"></a></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>    EventLoopGroup boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    EventLoopGroup worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerBootstrap bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1.</span>        bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boss<span class="token punctuation">,</span> worker<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2.</span>            <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span>NioServerSocketChannel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3.</span>            <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token operator">&lt;</span>SocketChannel<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 4.</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span>SocketChannel channel<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 5.</span>                    <span class="token keyword">new</span> <span class="token class-name">HttpChannelInboundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 6.</span>            <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span>ChannelOption<span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 7</span>        ChannelFuture future <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 8.</span>        <span class="token comment" spellcheck="true">//            future.channel().closeFuture(); // 9.</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        boss<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        worker<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="ServerBootstrap"></a></p><h4 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h4><p>启动引导类，Netty 需要实例化一个ServerBootstrap来启动服务并配置相关参数</p><p><a name="f4ed49db"></a></p><h4 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h4><p>分配组，服务端的启动服务需要两个组协同工作来处理IO，一个boss组用于accept（接受）连接，一个worker组用于handle（处理）连接</p><p><a name="27c8bb5b"></a></p><h4 id="channel"><a href="#channel" class="headerlink" title="channel()"></a>channel()</h4><p>这里我们使用NioServerSocketChannel的实例化对象来设置ServerBootstrap实例</p><p><a name="b5484671"></a></p><h4 id="childHandler"><a href="#childHandler" class="headerlink" title="childHandler()"></a>childHandler()</h4><p>添加处理器</p><p><a name="7cc2732b"></a></p><h4 id="initChannel"><a href="#initChannel" class="headerlink" title="initChannel()"></a>initChannel()</h4><p>对channel进行初始化配置，而这里我们没有自定义ChannelInitializer的实现类来添加具体的配置项到channel的pipeline上。因为我仅添加了一个处理器，没有太复杂的逻辑。这个处理器用于处理channel上的事件</p><p><a name="44e83e30"></a></p><h4 id="option"><a href="#option" class="headerlink" title="option()"></a>option()</h4><p>指定要应用到新创建的 ServerChannel 的 ChannelConfig 的 ChannelOption。这些选项将会通过 bind()方法设置到 Channel。在 bind()方法被调用之后，设置或者改变 ChannelOption 都不会有任何的效果</p><p>SO_BAKCLOG:设置排队的连接数。</p><p><a name="69be5557"></a></p><h4 id="childOption"><a href="#childOption" class="headerlink" title="childOption()"></a>childOption()</h4><p>指定当子 Channel 被接受时，应用到子 Channel 的 ChannelConfig 的ChannelOption。所支持的 ChannelOption 取决于所使用的 Channel 的类型。</p><p><a name="67110355"></a></p><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>绑定端口并返回一个ChannelFuture，将在绑定完成后收到回调通知</p><p><a name="9ebc9139"></a></p><h4 id="closeFuture"><a href="#closeFuture" class="headerlink" title="closeFuture()"></a>closeFuture()</h4><p>优雅地关停服务，按需用。</p><p>下一篇会开始分析Netty的核心API</p>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty挖掘机（一）初识JAVA_NIO</title>
      <link href="/2020/02/21/netty-wa-jue-ji-yi-chu-shi-java-nio/"/>
      <url>/2020/02/21/netty-wa-jue-ji-yi-chu-shi-java-nio/</url>
      
        <content type="html"><![CDATA[<p>推荐阅读：<a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">美团技术团队对NIO的浅析</a></p><p>众所周知，Netty是基于JAVA NIO 而封装的网络通讯框架。</p><p>官网介绍：Netty is <em>an asynchronous event-driven network application framework</em><br />for rapid development of maintainable high performance protocol servers &amp; clients.</p><p>本人打着想重新梳理一遍Netty的知识体系的心态，来写Netty挖掘机这一系列的文章。我相信一步步深入到源码后，会有收获的！</p><p><a name="AntXF"></a></p><h1 id="什么是阻塞和非阻塞、同步和异步IO"><a href="#什么是阻塞和非阻塞、同步和异步IO" class="headerlink" title="什么是阻塞和非阻塞、同步和异步IO"></a>什么是阻塞和非阻塞、同步和异步IO</h1><p>一个IO操作分为先发起IO请求、再进行实际的IO操作</p><ul><li><p>阻塞、非阻塞IO：发起IO请求时线程是否会阻塞直到完成</p></li><li><p>同步、异步IO：真正IO实际读写操作 过程 是否会阻塞请求线程</p><pre><code>             同步需要等待（线程阻塞时）或轮询（线程非阻塞时）内核完成IO操作             异步是系统等内核完成IO操作后（被调用者）再主动通知程序（通知 或者 回调）</code></pre></li><li><p>同步阻塞：发起一个IO请求时，线程阻塞，直到等待实际的内核IO读写操作完成才放开线程</p></li><li><p>同步非阻塞：发起一个IO请求时，线程非阻塞，但是线程需要去定时轮询内核IO操作是否完成</p></li><li><p>异步非阻塞：发起一个IO请求时，线程非阻塞，不等待内核IO操作完成，也不用进程花费CPU资源去轮询，而是系统（被调用者）主动通知程序（调用者）</p></li></ul><blockquote><p>为什么说NIO是同步非阻塞？<br>NIO它的实际内核I/O操作（读read、写write、接受accept）会阻塞请求线程，所以是同步的；但是它的发起请求这一步，不会导致线程阻塞，而会通过多路复用器select进行轮询获取实际内核I/O操作完成的信息</p></blockquote><p><a name="P0Ae1"></a></p><h1 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO?"></a>什么是BIO?</h1><blockquote><p>即面向流的同步阻塞IO， Client、Server基于输入流、输出流进行通信</p></blockquote><p><a name="YUPa0"></a></p><h2 id="单线程BIO"><a href="#单线程BIO" class="headerlink" title="单线程BIO"></a>单线程BIO</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277115922-ff1a9c62-543b-4f7d-8352-0708c7baa785.png#align=left&display=inline&height=332&name=bio_single.png&originHeight=332&originWidth=630&size=17138&status=done&style=none&width=630" alt="bio_single.png"></p><p><a name="SbTeF"></a></p><h2 id="多线程版BIO"><a href="#多线程版BIO" class="headerlink" title="多线程版BIO"></a>多线程版BIO</h2><p>典型的C/S模型。它是由Server开启accept线程进行监听Client的连接请求，一个请求对应创建一个新的线程进行处理，并通过输出流返回给客户端。</p><pre><code>优点：支持同一时间内多个客户端并行请求服务端缺点：不具备弹性伸缩能力。当面对海量连接时，意味着线程数膨胀，与其同时造成的是系统性能的急剧下降（因为线程也是宝贵的系统资源），进而会发生句柄溢出、线程堆栈溢出，甚至造成服务器宕机。    ![bio1.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582277133782-0e1c8f64-5f58-44e7-98a2-f73031c00d7c.png#align=left&amp;display=inline&amp;height=271&amp;name=bio1.png&amp;originHeight=271&amp;originWidth=635&amp;size=32253&amp;status=done&amp;style=none&amp;width=635)    代码示例：</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    ServerSocket server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"# Server start，the port:"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"### start listener client connect..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Socket client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"### now accept one client connect, start handler..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">handler</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket client<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        InputStream stream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="6NJgt"></a></p><h2 id="线程池版BIO"><a href="#线程池版BIO" class="headerlink" title="线程池版BIO"></a>线程池版BIO</h2><p>在多线程的基础上，增加了线程池的概念，可以避免线程频繁创建。<br />线程池本身就是一个天然的漏斗，可以在特殊情况下解决一些系统无法处理的问题<br />然而还是逃不开一个事实：把线程当做命根子。。。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277645931-6a7e0c01-182a-494d-86ba-2de6d2cf7dd9.png#align=left&display=inline&height=375&name=bio_pool.png&originHeight=375&originWidth=871&size=30321&status=done&style=none&width=871" alt="bio_pool.png"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建容量为100的线程池</span>    ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ServerSocket server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"# Server start，the port:"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 循环等待新连接</span>            Socket client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token function">handler</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket client<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        InputStream stream <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="q7BRH"></a></p><h1 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h1><blockquote><p>即面向缓冲区的同步非阻塞IO。<br>从jdk1.4开始，增加了与原标准IO API 不同使用方式的NIO(NO BLOCK IO)<br>jdk1.5_update10 版本使用 epoll 替代了传统的 select/poll，极大的提升了 NIO 通信的性能。</p></blockquote><p><a name="Reo4X"></a></p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><pre><code>在BIO中使用字节流or字符流来传输数据；而在NIO中使用通道和缓冲区来传输数据Channel将数据读入Buffer， Buffer将数据写入Channel&lt;br /&gt;![channelbuffer.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582277715014-6ffaf053-475c-4489-b408-66d2f0077609.png#align=left&amp;display=inline&amp;height=214&amp;name=channelbuffer.png&amp;originHeight=214&amp;originWidth=296&amp;size=6493&amp;status=done&amp;style=none&amp;width=296)    </code></pre><p><a name="xJwy7"></a></p><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p><a name="W0vhy"></a></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote><p>即数据通道，不同于单向io（读和写需要不同的通道），这里的通道支持双向，即可从通道内读写数据。<br>实际Channel与Buffer结合使用：从通道读数据到缓冲区，缓冲区向通道写入数据</p></blockquote><p>JAVA NIO Channel 主要有以下几种<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278275822-0e90293f-ce44-4b56-be38-ba163a72452f.jpeg#align=left&display=inline&height=305&name=channel.jpg&originHeight=305&originWidth=940&size=15719&status=done&style=none&width=940" alt="channel.jpg"></p><ul><li>FileChannel 读写文件时用的通道（仅它无法设置非阻塞模式，默认阻塞）</li><li>SocketChannel 客户端传输TCP连接数据时的通道，与JAVA IO中的Socket对应</li><li>DatagramChannel 传输UDP连接数据时的通道，与Java IO中的DatagramSocket对应</li><li>ServerSocketChannel 服务端监听进入的TCP连接的通道，与Java IO中的ServerSocket对应</li></ul><p>以下是使用FileChannel 读取文件的Demo</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuffer json <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        json <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> br <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读入缓冲区</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>br <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 缓冲区读取就绪</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                json<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            buf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            br <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a name="5TwOz"></a></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><blockquote><p>即缓冲区。本质上是一块 可以从中读取数据，或写入数据 的内存，在JAVA NIO中提供了具体的方法来访问内存中的数据</p></blockquote><p>Channel将数据读入Buffer， Buffer将数据写入Channel<br><br /></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582277902479-3a118472-9512-406d-82b6-0a39e79df07c.png#align=left&display=inline&height=214&name=channelbuffer.png&originHeight=214&originWidth=296&size=6493&status=done&style=none&width=296" alt="channelbuffer.png"></p><p>Channel读入Buffer：</p><pre class=" language-java"><code class="language-java">FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bread <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Buffer写入Channel:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要有写入权限，否则会抛异常</span><span class="token comment" spellcheck="true">// RandomAccessFile fc = new RandomAccessFile("test.json", "rw")</span>FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bread <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="usZY8"></a></p><h4 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h4><ul><li><p>Capacity（容量）</p></li><li><p>Limit（限制）</p></li><li><p>Position（位置）<br><a name="KmpOl"></a></p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4></li><li><p>allocate(int capacity) 分配指定容量（字节）的缓冲区.</p></li><li><p>allocateDirect(int capacity) 分配指定容量的直接缓冲区</p></li><li><p>flip() 翻转缓冲区，使得limit变为当前位置position，position变为0，常用于Channel读入Buffer或Buffer写入Channel操作后</p></li><li><p>rewind() 倒带缓冲区，将当前位置position设置为0，limit不变，常用于通道读入缓冲区后，要读取缓冲区的数据</p></li></ul><p>举个栗子</p><pre class=" language-java"><code class="language-java">StringBuffer json <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    json <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> size <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ByteBuffer buf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 倒带buffer，将position设置为0</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 遍历buffer 的数据</span>        json<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>clear() 清除缓冲区，将缓冲区置于写入模式</li><li>compact() 压缩缓冲区，将缓冲区未读部分复制到缓冲区索引为0的区域，且下一次读入缓冲区时从未读部分的索引+1开始</li></ul><p><a name="k65gV"></a></p><h3 id="Selector（多路复用）"><a href="#Selector（多路复用）" class="headerlink" title="Selector（多路复用）"></a>Selector（多路复用）</h3><blockquote><p>即选择器<br>在java nio中，可以通过Selector用单个线程来管理多个通道。它能够检测n个Nio通道的状态（连接就绪、接收就绪、读就绪、写就绪）<br>现代操作系统的多任务处理上，开销貌似变得越来越小，但程序上仍要控制使用线程的频率，因为线程的切换开销是很昂贵的</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278370902-80bcb3f2-759f-4d3b-ae9c-b9e99b2dc258.jpeg#align=left&display=inline&height=410&name=selector.jpg&originHeight=410&originWidth=581&size=13430&status=done&style=none&width=581" alt="selector.jpg"></p><p><a name="gGpTB"></a></p><h4 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h4><p>我们说NIO 本身是基于事件驱动思想来处理IO的。这里的事件即我们通过Selector注册对应的事件在Channel上。它的事件主要有<br />连接就绪    SelectionKey.OP_ACCEPT<br />读就绪    SelectionKey.OP_READ<br />写就绪    SelectionKey.OP_WRITE<br />以下文字是摘自美团技术团队 《Java Nio浅析》中的一段</p><blockquote><p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。<br>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。<br>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p></blockquote><p><a name="qgjQt"></a></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><a name="LKb9O"></a></p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><pre class=" language-java"><code class="language-java">Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="lTBGh"></a></p><h5 id="注册Channel"><a href="#注册Channel" class="headerlink" title="注册Channel"></a>注册Channel</h5><p>要注意的是使用的Channel必须设置非阻塞模式，否则会抛出IllegalBlockingModeException异常。<br />why？<br />翻看了javadoc 后，找到这么一句：Non-blocking mode is most useful in conjunction with selector-based multiplexing，意思是认为非阻塞模式与基于选择器的多路复用结合使用最为有用。想想当Channel是阻塞模式的话，那多路复用其实也没啥意思了…<br />以ServerSocketChannel来举栗。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 打开通道</span>ServerSocketChannel server <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 绑定端口</span>server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置阻塞模式，false:nio style</span>server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建选择器</span>selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用给定的选择器注册此通道</span>server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a name="BfYUo"></a></p><h5 id="轮询获取channel状态"><a href="#轮询获取channel状态" class="headerlink" title="轮询获取channel状态"></a>轮询获取channel状态</h5><p>通过调用某个select方法，获取就绪的channel。<br />int select()：获取就绪的key个数，阻塞直到获取至少一个就绪的channel<br />int select(long timeout)：获取就绪的key个数，阻塞直到时间达到指定timeout<br />int selectNow()：非阻塞获取就绪的key个数<br />通过以上可得到就绪的key个数，再调用selectedKeys获取所有的事件key，迭代获取key对应的通道即可</p><p>完整代码如下：</p><pre class=" language-java"><code class="language-java">Selector selector<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">NioServer</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">NioServer</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 打开通道</span>    ServerSocketChannel server <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 绑定端口</span>    server<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置阻塞模式，false:nio style.true:oio style.</span>    server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建选择器</span>    selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用给定的选择器注册此通道</span>    server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端已启动，端口"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 阻塞，获取已就绪的key个数</span>        <span class="token keyword">int</span> wait <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wait <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取所有的事件key</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> readykeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> readykeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 移除已处理数据</span>            iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 处理逻辑</span>            <span class="token function">process</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 业务逻辑方法* @param key*/</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>SelectionKey key<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断客户端是否已确认连接并且可交互</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ServerSocketChannel server <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SocketChannel client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置阻塞模式</span>        client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 非阻塞</span>        <span class="token comment" spellcheck="true">// 注册选择器，设置读模式，告诉client端下次进来便要读取数据</span>        client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">,</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HI!\r\n"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//            // 将此对应的channel设置为准备接受其他客户端的连接请求</span>        <span class="token comment" spellcheck="true">//            key.interestOps(SelectionKey.OP_ACCEPT);</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接受连接来自 "</span><span class="token operator">+</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 处理数据读取请求</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取数据</span>        <span class="token comment" spellcheck="true">// 返回该读key 对应的channel</span>        SocketChannel client <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取channel内的数据</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 翻转缓冲区</span>                buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                content<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将channel设置为准备下一次读取</span>            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            key<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="OIs1D"></a></p><h3 id="scatter-gather-I-O-（也叫Vectored-I-O）"><a href="#scatter-gather-I-O-（也叫Vectored-I-O）" class="headerlink" title="scatter/gather I/O （也叫Vectored I/O）"></a>scatter/gather I/O （也叫Vectored I/O）</h3><p>Channel内置scatter/gather I/O功能</p><ul><li><p>scatter read：分散读入<br /><br><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582278733492-e46d63cb-4632-4aa5-92ac-491ae21c1481.jpeg#align=left&display=inline&height=300&name=scatter_io.jpg&originHeight=300&originWidth=360&size=9337&status=done&style=none&width=360" alt="scatter_io.jpg"></p><pre class=" language-java"><code class="language-java">Charset charset <span class="token operator">=</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FileChannel fc <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ByteBuffer headBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头部缓冲区固定大小8字节</span>  <span class="token keyword">long</span> size <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer bodyBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 剩下的归为body</span>  ByteBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>headBuf<span class="token punctuation">,</span> bodyBuf<span class="token punctuation">}</span><span class="token punctuation">;</span>  fc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>  headBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"head buffer data "</span> <span class="token operator">+</span> charset<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>headBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"body buffer data "</span> <span class="token operator">+</span> charset<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>bodyBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>gather write：聚集写入<br /><br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582278758175-3c131229-a597-40ec-9c3f-25ab82873eb7.png#align=left&display=inline&height=301&name=gather_io.png&originHeight=301&originWidth=333&size=8981&status=done&style=none&width=333" alt="gather_io.png"><br /></p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">(</span>RandomAccessFile accessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"test.json"</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  FileChannel fc <span class="token operator">=</span> accessFile<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ByteBuffer headBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头部缓冲区固定大小8字节</span>  headBuf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer bodyBuf <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 剩下的归为body</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Jerry"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ByteBuffer<span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>headBuf<span class="token punctuation">,</span> bodyBuf<span class="token punctuation">}</span><span class="token punctuation">;</span>  headBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  bodyBuf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> length <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"buffer data write to channel length "</span> <span class="token operator">+</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p>分散/聚集 IO支持，针对的是通道和buffer间的交互<br />通道可以将数据分散读入多个缓冲区，多个缓冲区可以将数据聚集写入单个通道</p><table><thead><tr><th>说明</th><th>特性</th></tr></thead><tbody><tr><td>连接输出</td><td>在内存中写入非顺序放置数据的应用程序可以在一个向量I / O操作中执行此操作。</td></tr><tr><td>效率</td><td>一个向量I / O读取或写入可以替换许多普通读取或写入，从而节省系统调用所涉及的开销</td></tr><tr><td>拆分输入</td><td>需要单独处理传输数据的各个部分的情况。例如，如果消息由标题和正文组成，则可以将标题和正文保留在单独的缓冲区中。这样做可以使您更容易分别使用标题和正文</td></tr></tbody></table><p><a name="6NDuL"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a name="USMzu"></a></p><h2 id="为什么NIO会替代BIO？"><a href="#为什么NIO会替代BIO？" class="headerlink" title="为什么NIO会替代BIO？"></a>为什么NIO会替代BIO？</h2><pre><code>可以从两个角度出发</code></pre><ul><li>jdk序列化（BIO面向流传输）<ol><li>不支持跨语言工作。即当跨应用调服务时，A应用（Python），B应用（JAVA），此时A应用发送到B应用的序列化对象，B应用无法对其反序列化</li><li>就算是同语言工作。效率低下，即码流太大，无论是网络传输or持久化到磁盘，会导致额外的系统占用。实际测试远低于ByteBufffer（java.nio包）</li><li>性能差。占用CPU资源高</li></ol></li><li>线程（BIO严重依赖线程工作）<ol start="4"><li>创建和销毁的成本高。在Linux系统中，线程本质上是一个轻量级的进程，这种系统级别的开销是挺大的</li><li>吃内存</li><li>线程切换的成本高。</li><li>易造成生产&gt;消费。即外部网络请求的频率远大于线程的创建及销毁。每个TCP连接即占用一个线程，此时当遇到IO读写阻塞导致线程无法及时释放等情况时，会导致性能下降，甚至宕机。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty挖掘机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈（二）JAVA集合</title>
      <link href="/2020/02/20/lao-sheng-chang-tan-er-java-ji-he/"/>
      <url>/2020/02/20/lao-sheng-chang-tan-er-java-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="java-util-List"><a href="#java-util-List" class="headerlink" title="java.util.List"></a>java.util.List</h2><h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><ol><li>底层是基于（可调整大小）数组的数据结构，使用一块连续的内存空间保存数据</li><li>性能<ul><li>添加（或删除）操作。<ul><li>在不需要调整数组大小（即在末尾操作）的情况下，时间复杂度为O(1)；</li><li>在超过大小 时，会触发底层数组扩容（System.arraycopy()，复制到新的存储空间）最坏情况下（即超过了大小或者添加、修改了第一个数据）时间复杂度为O(n)。扩容后数组长度为原来的1.5倍。</li></ul></li><li>查询操作。直接通过下标访问元素，时间复杂度为O(1)；循环查找指定元素，时间复杂度为O(n)</li></ul></li><li>缺省下初始容量为10</li></ol><p><a name="LinkedList"></a></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote><p>什么是双向循环链表？</p><ol><li>链表中任意一个存储单元都可以通过向前或向后寻址的方式获取到其前一个存储单元和后一个存储单元</li><li>链表的尾节点的后一个节点是链表的头节点，链表的头节点的前一个节点是链表的尾节点</li></ol></blockquote><ol><li>底层是基于循环双向链表的数据结构，在非连续的内存空间中保存数据。在双向链表中，通过指针将各个内存单元连接在一起。每个节点都指向它的上一个和下一个节点。当需要存储数据时，分配一块内存空间并将这块内存插入链表中</li><li>性能<ul><li>添加（或删除）操作<br><br>时间复杂度为O(1)，不需重排原结构，只需要调整上一个和下一个节点的指针</li><li>查询操作。查找第n个数据或循环查找指定元素的时间复杂度为O(n)</li></ul></li><li>缺省下无初始容量</li></ol><p><a name="CopyOnWriteArrayList"></a></p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><blockquote><p>线程安全的ArrayList，通过增加 <code>写时复制语义</code>来实现线程安全性。特点如下</p><ol><li><code>延时懒惰策略</code>，当对list修改时，会先将list copy 一个副本，在副本里进行修改，接着将指向原来内存的指针指向新内存</li><li>适用于list 大小不大，读操作多于可变操作（因为可变操作：add、set 会导致复制整个list，意味着重新开辟一个内存区域，开销大）</li><li>使用迭代器进行遍历速度很快，在多线程下不会导致异常（Arraylist 在多线程下进行迭代，<code>可能会出现java.util.ConcurrentModificationException</code>异常，因为遍历时其他线程对list做了修改），因为CopyOnWriteArrayList 每次进行读写操作都会创建一个副本进行操作</li><li>内部用了Reentrantlock来保证线程安全</li></ol></blockquote><p>add源码如下：</p><p>在添加集合的时候上锁，保证同步，避免出现多线程写入时会copy出n个副本</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="java.util.Map"></a></p><h2 id="java-util-Map"><a href="#java-util-Map" class="headerlink" title="java.util.Map"></a>java.util.Map</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195085532-df2303dc-7ce4-4206-aa58-3fd29e756552.jpeg#align=left&display=inline&height=389&name=map-interface.jpg&originHeight=389&originWidth=640&size=28029&status=done&style=none&width=640" alt="map-interface.jpg"></p><p><a name="0e6b089f"></a></p><h3 id="Hashmap-数组-列表-红黑树"><a href="#Hashmap-数组-列表-红黑树" class="headerlink" title="Hashmap(数组+列表+红黑树)"></a>Hashmap(数组+列表+红黑树)</h3><blockquote><p>用一个数组（table[i]）来分散所有的key，一个key加入时，会用hash算法通过key计算出hash值，进而得到对应的数组下标i（这里是使用<code>(n - 1) &amp; hash</code> 位操作而不是取余），然后把这个entry插入到table[i]中，但是当有多个key同时被计算出同一个下标i，此时会产生冲突，即碰撞。对应采取的方案是会在table[i]上形成一个单向链表。当链表过多或过长时，查找算法会变成低效率的链表遍历，这是hash表的缺陷。而后java8做了改进，当链表中的元素超过8个时，会自动转为红黑树，此时查找效率提升为O(log n)，即根据树的高度去查找。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195097956-860f60e2-43b4-440c-aff1-f74c47b9b53f.jpeg#align=left&display=inline&height=419&name=hashmap.jpg&originHeight=419&originWidth=1242&size=124356&status=done&style=none&width=1242" alt="hashmap.jpg"></p><p><a name="ea8a77ba"></a></p><h4 id="什么是hashmap"><a href="#什么是hashmap" class="headerlink" title="什么是hashmap"></a>什么是hashmap</h4><p>是一个用于存储key-value的键值对集合，每一个键值对都是一个Entry，这些Entry分散存储在一个数组中，数组的每一个元素的初始值都是NULL.</p><p><a name="ed83bf84"></a></p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>通过put和get存取对象。用put存储对象时，主要是先通过调用hashcode计算hash从而得到bucket(桶)的位置，而后进一步存储，如果没碰撞就直接放入bucket；如果碰撞了，就以链表的形式存入；如果碰撞导致链表长度&gt;=TREEIFY_THRESHOLD，则将链表转为红黑树；如果该节点已存在值，则替换。当发现数组元素个数超过Threshold （Capacity * Loadfactor）时，会自动扩容为原来的2倍，即数组容量始终是2的幂。用get获取对象时，主要是先通过调用hashcode计算hash从而得到bucket（桶）的位置，并进一步调用了equal()确定键值对。当在bucket的第一个节点找到，则直接命中，如果是树结构，则在树中调用key.equals(k)查找，时间复杂度为O(log n)，如果是链表结构，则在链表中调用key.equals(k)，时间复杂度为O(n)</p><ol><li>初始长度16，Loadfactor 负载因子（当前Capacity 填满程度的最大比例）默认0.75。<br><br>建议为了避免性能消耗，初始化时确定好Map的容量，并且需要注意<br><br>容量 = ((float)期望容量大小 / 0.75F ) + 1.0F，源码在putAll()内:float ft = ((float)s / loadFactor) + 1.0F;<br><br>当我们确定好容量（并且需要是2的幂次方，这样可以避免一次运算）时，就可以避免rehash的操作，即扩容。这是一种用内存换性能的操作。</li><li>Capacity 当前数组容量，始终为2的幂。扩容后数组长度为原来的2倍。</li><li>Threshold 扩容阈值，等于Capacity * Loadfactor。当数组元素个数超过阈值时需要进行扩容（需要重建hash表），数组长度为原来的2倍。</li><li>可接受Null值</li><li>非线程安全。也就是没有加锁，查询会很快。但是任意时刻多个线程同时写入，会导致数据错乱或者其他异常情况，比如死锁导致CPU100%（环形链表）等。</li><li>发生hash碰撞时，jdk1.7是在链表头部添加元素（这也是导致死锁的原因之一），jdk1.8改进为在链表尾部添加元素<br><br>在多线程下，那些map是线程安全的<ul><li>Collections.synchronizedMap(内部用了synchronized，高并发效率低，不采用)</li><li>HashTable(内部用了synchronized，高并发效率低，不采用)</li><li>ConcurrentHashMap</li></ul></li><li>里面是一个数组，每个元素又是一个单向链表，所以查询时是根据hash值找到对应的数组下标，之后要顺着链表找到具体的值，所以时间复杂度为O(n)，而后java8作了修改，当链表元素超过TREEIFY_THRESHOLD = 8个（即某个桶中的记录超过8个）会自动转为红黑树，此时时间复杂度为O(log n)</li></ol><p><a name="d303267a"></a></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol><li>在获取bucket下标的时候，为什么要用位操作：(n - 1) &amp; hash 来代替 取余操作 hash % n？<br><br>由于hashmap底层实现上规定数组长度为2的幂（就算初始化非2的幂也会强制换算为最接近的2的幂），所以在此条件下，(n - 1) &amp; hash = hash % n。一样的效果，但是位操作的效率更高。假设数组长度为8，此时hash值为15，15 % 8 = 7，15 &amp; (8-1)=7</li><li>为什么数组长度必须是2的幂？<br><br>只有当数组长度为2的幂次方时，(n - 1) &amp; hash = hash % n，即实现了key的定位<br><br>2的幂次方也可以减少碰撞几率，提高HashMap的查询效率；当不是2的幂时，会导致(n-1)的二进制末位是0，进而导致数组可使用位置小了很多，导致碰撞的几率增大</li><li>能否使用任何类作为Map的key？<br><br>可以，遵循equals()和hashCode()方法的定义规则。由于map中存取对象put和get时，会遇到计算key的hash值，进而确定它在bucket中的位置。然而当key是自定义对象时，假设它是一个可变对象，也就意味着它的hash值也是可变。当自定义对象在存到Map后，内部做了修改，此时再也无法在Map内通过它找到原来的Entry。所以自定义对象的话，需要将它变成不可变对象，即重写hashCode和equals()方法。所以我们一般会用String，Integer这种不可变对象来作为key。</li><li>当两个键的hashcode相等时，如何获取值对象？<br><br>通过key的hash值找到bucket的位置，接着通过key.equals(k)方法找到对应的节点，最终找到值。</li><li>为什么负载因子默认是0.75？<br><br>这是一种概率问题，当负载因子过大时，会导致hash碰撞的概率增大，而且在降低空间开销的同时，提高了查找的时间开销；当负载因子过小时，会导致rehash频率增加，而且增大了已使用和未使用的空间的差值，浪费空间；0.75的话，在源码里面有说到TreeNote大小大约是常规节点的两倍，在理想情况下一个bin（也就是bucket）中的链表长度达到8的概率是0.00000006。简单地总结就是空间与时间的权衡选择了0.75。所以我们在初始化hashmap设置负载因子时，需要考虑要在空间上做优化还是时间上。</li><li>为什么定义桶中个数超过8才转红黑树？</li></ol><ul><li>首先我们要知道，桶中元素初始化是用链表保存的，其查找性能是O(n)，但是树结构决定了它的查找性能是O(log(n))，性能提升。<br><br>在链表长度很小时，即时遍历速度也很快，但是当不断变长后，链表的查询性能肯定会受影响<br><br>链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195141518-0649f97a-d62d-422f-9cf7-1409022da25f.jpeg#align=left&display=inline&height=1845&name=hashmap_1.jpg&originHeight=1845&originWidth=1242&size=679596&status=done&style=none&width=1242" alt="hashmap_1.jpg"></p><p>这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。由此可见，发展30年的Java每一项改动和优化都是非常严谨和科学的。</p><p>参考文章</p><p><a href="https://www.cnblogs.com/chinajava/p/5808416.html" target="_blank" rel="noopener">深入理解哈希表</a><br><a href="http://www.importnew.com/14417.html" target="_blank" rel="noopener">Java 8：HashMap的性能提升</a><br><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="https://www.hollischuang.com/archives/2431" target="_blank" rel="noopener">关于HashMap容量的初始化，还有这么多学问</a><br><a href="http://youzhixueyuan.com/the-underlying-structure-and-principle-of-hashmap.html" target="_blank" rel="noopener">深入探讨HashMap的底层结构、原理、扩容机制</a></p><p><a name="ConcurrentHashmap"></a></p><h3 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h3><p>以下是jdk1.7的整体结构图<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195162939-6b3b269e-4d49-4c3f-b130-ffc742610f44.jpeg#align=left&display=inline&height=683&name=chashmap.jpg&originHeight=683&originWidth=1242&size=176252&status=done&style=none&width=1242" alt="chashmap.jpg"></p><ol><li>一个Segment数组，每个Segment可看做一个hashmap，其引入了分段锁技术，即每一个Segment继承了Reentrantlock进而实现加锁，即每次保证线程安全锁住的是一个Segment，并行度默认为16，即最多可以有16个Segment(线程)支持并发写。而后java8也引入了红黑树<blockquote><p>分段锁：锁的时候不锁住整个hash表，而是锁一个segment</p></blockquote></li></ol><p>假设出现极端情况下，所有数据都集中在一个Segment，相当于并发下锁住了全表，这种情况下其实和HashTable差不多，但是整体上看效率还是有提升。<br><br>所以在jdk1.8后，摒弃了Segment思想，加入Cas和synchronized组合的方式实现线程安全：</p><ul><li>若插入位置为空，则使用cas来将数据放入table 的第一个位置。若插入不成功，会一直自旋…</li><li>若插入位置不为空，对当前数组位置的头节点上锁<ul><li>如果该节点为forwarding nodes，表明该位置上的链表或红黑树正在进行扩容，让当前线程参与协助并发扩容，提高效率</li><li>如果为链表，则逐层遍历，当发现key的hashcode值相等，则将该节点的数据替换，否则添加到链表末尾</li><li>如果为红黑树，则按对应规则put<ol start="2"><li>线程安全，支持并发操作。</li><li>key和value值不能为null</li></ol></li></ul></li></ul><p>以下是jdk1.8的整体结构图，看似很像hashmap的结构。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195215246-97e06ea3-f1ec-426d-aa44-0320f4e33318.jpeg#align=left&display=inline&height=419&name=chashmap_1.jpg&originHeight=419&originWidth=1242&size=114087&status=done&style=none&width=1242" alt="chashmap_1.jpg"><br>链表为O（n），因为取决于链表的长度<br>红黑树为O(log n），取决于树的高度</p><p>参考文章<br><a href="https://www.codercto.com/a/68503.html" target="_blank" rel="noopener">解读Java8中ConcurrentHashMap是如何保证线程安全的</a></p><p><a name="TreeMap"></a></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol><li>数据结构是红黑树，即自平衡的排序二叉树。与哈希映射不同，树映射能保证其元素按升序键进行排序</li><li>继承了AbstractMap，所以它是一个key-value的map集合</li><li>实现了NavigableMap接口，能够按保存的key值排序，默认升序</li><li>实现了Cloneable接口，即支持被克隆</li><li>实现了java.io.Serializable接口，即支持序列化<table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>TreeMap()</td><td>此构造函数构造一个空树图，将使用键的自然顺序进行排序。</td></tr><tr><td>TreeMap(Comparator comparator)</td><td>此构造函数构造一个空的基于树的映射，该映射将使用比较器<code>comp</code>进行排序。</td></tr><tr><td>TreeMap(Map m)</td><td>此构造函数使用<code>m</code>中的条目初始化树映射，该映射将使用键的自然顺序进行排序。</td></tr><tr><td>TreeMap(SortedMap sm)</td><td>此构造函数使用<code>SortedMap sm</code>中的条目初始化树映射，该映射将按与<code>sm</code>相同的顺序排序。</td></tr></tbody></table></li></ol><p><a name="b6f16212"></a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>定义</p><ul><li>根节点必黑</li><li>每个叶节点必黑，即树尾端NIL指针或NULL节点</li><li>如果一个节点是红的，则它两个儿子都是黑的</li><li>对任一节点，它到树尾端NIL指针的每条路径都包含相同数目的黑节点，即相等黑节点数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195239143-93031ce5-6d92-411f-9fc1-4ae9850f070a.jpeg#align=left&display=inline&height=710&name=redwhitetree.jpg&originHeight=710&originWidth=1242&size=149130&status=done&style=none&width=1242" alt="redwhitetree.jpg"></p><p><a name="ulGXu"></a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><a name="HashSet"></a></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>即hash表，存放的是哈希值。存储顺序非插入顺序，按哈希值存取。底层是使用了Hashmap来保存元素。<br>如何判断相等？先判断哈希值是否一样，再判断equal方法是否为true，则为同一个元素。<br>问题来了，equal为false但是哈希值是相等的，是怎么存的。其实是把相等哈希值放到一个哈希桶里，哈希一样的存一列。如下图1代表哈希值不同，图2代表相同，但是equal为false</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195268204-7cc58b51-3062-4e66-8285-3db4d9d90a30.jpeg#align=left&display=inline&height=392&name=hashset.jpg&originHeight=392&originWidth=1242&size=73700&status=done&style=none&width=1242" alt="hashset.jpg"></p><p>最终可得结论，一个hashcode位置上可存放多个元素，Hashset通过hashcode确定元素在内存中的位置</p><p><a name="3f52d474"></a></p><h3 id="TreeSet-二叉树"><a href="#TreeSet-二叉树" class="headerlink" title="TreeSet(二叉树)"></a>TreeSet(二叉树)</h3><ol><li>利用二叉树的原理，将add的元素按指定的顺序进行排序，插入到二叉树指定的位置</li><li>Integer String可实现默认的排序，但是自定义对象需要实现Comparable接口，且要覆写该接口，并要有返回值</li></ol><p><a name="LinkHashSet"></a></p><h3 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h3><ol><li>继承于Hashset</li><li>基于LinkedHashMap实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈（一）TCP与UDP</title>
      <link href="/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/"/>
      <url>/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了更进一步了解网络层面的知识，先晒出一张网络体系结构图，加深理解。</p></blockquote><p><a name="0qP7n"></a></p><h1 id="计算机网络体系结构图"><a href="#计算机网络体系结构图" class="headerlink" title="计算机网络体系结构图"></a>计算机网络体系结构图</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582188081209-c85b7515-50d4-42c9-baf8-702116242721.png#align=left&display=inline&height=621&name=all.png&originHeight=621&originWidth=1041&size=251518&status=done&style=none&width=1041" alt="all.png"><br><br><a name="4Wa7C"></a></p><h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h1><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接的协议。基于这种连接方式， 通信设备应在传输数据前建立连接，并应在传输数据后关闭连接</td><td>面向数据报的协议。意味着打开、维护、终止连接不会有开销。UDP对于广播和多播类型的网络传输是有效的</td></tr><tr><td>点对点通信，连接两端的socket</td><td></td></tr><tr><td>面向字节流。TCP把传输的各种数据当做无结构的字节流来用</td><td></td></tr><tr><td>可靠性。它能够保证向目标路由器的数据传输</td><td>不可靠性。不能保证向目的地传送数据</td></tr><tr><td>错误检测机制。TCP提供了广泛的错误检查机制，这是因为它提供流量控制和数据确认。</td><td>UDP只有使用校验和的基本错误检查机制</td></tr><tr><td>数据排序。数据包能够按照顺序到达接收器</td><td>没有数据排序。若有需求，则需要再应用程序层进行管理</td></tr><tr><td>速度较慢。相对UDP而言速度较慢。</td><td>快、简单、高效</td></tr><tr><td>重传机制。支持重传丢失的数据包</td><td>无重传机制</td></tr><tr><td>标头大小为20个字节</td><td>标头大小为8个字节</td></tr><tr><td>重量级</td><td>轻量级</td></tr><tr><td>用于HTTP，HTTP，FTP，SMTP和Telnet</td><td>用于DNS，DHCP，TFTP，SNMP，RIP和VoIP</td></tr></tbody></table><p>注：本文所指的Client 均为发送方，Server为接收方</p><p><a name="wXUm8"></a></p><h1 id="TCP-三次握手、四次挥手"><a href="#TCP-三次握手、四次挥手" class="headerlink" title="TCP 三次握手、四次挥手"></a>TCP 三次握手、四次挥手</h1><p><a name="N7y6K"></a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><p>建立一个TCP连接时，需要Client和Server总共发送3个包。<br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191193844-5cd363e1-ca8f-42bc-8541-c6882e2d5ffe.jpeg#align=left&display=inline&height=421&name=3-way-handshake_1.jpg&originHeight=421&originWidth=572&size=35580&status=done&style=none&width=572" alt="3-way-handshake_1.jpg"></p><ul><li>Step 1（SYN）.<br>Client 端要和Server端 建立连接，所以要发一个SYN（即同步序列号）的包，初始序号x，保存在包头的序列号（Sequence Number）字段里，指明打算连接的Service port，。<br>用于告知Server：我（Client）可能要与你开始通讯了，现在发给你一个我（Client）启动段的序列号。<br>此时Client进入<code>SYN_SEND</code>状态<br></li><li>Step 2（SYN+ACK）.<br>Server 端 接收到数据包（通知）后<br>使用一个SYN-ACK信号位设置，来响应Client 端的请求。<br>即发送了自己的序列号（SVN），初始序号为y，和确认号（ACK，即Client发来的序列号递增1， 即x + 1）。<br>此时Server进入 <code>SYN_RCVD</code> 状态<br></li><li>Step 3（ACK）.<br>Client接收到Server端的响应后<br>发送确认包（ACK，即Server 发来的序列号递增1， 即y + 1）来确认收到响应，此时Client 进入 <code>ESTABLISHED</code> 状态，当Server 接收到该ACK包后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p><a name="2kajc"></a></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)。<br>需要四个包的原因是是因为TCP的半关闭引起的<br>客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p></blockquote><p>下面假设Client主动发起挥手动作<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191219910-edfed3ce-3fd3-42a2-97be-5274cc01272f.jpeg#align=left&display=inline&height=450&name=4-way-connect-termination.jpg&originHeight=450&originWidth=571&size=36350&status=done&style=none&width=571" alt="4-way-connect-termination.jpg"></p><ul><li>Step 1（FIN）.<br>Client 端（发起方）要关闭TCP连接，所以要发一个FIN包，序号为x。<br>发送完毕后，此时Client进入 <code>FIN_WAIT_1</code> 状态（此时表明无数据可发送，但仍可接受数据）<br></li><li>Step 2（ACK）.<br>当Server 端 接收到FIN包后，立即向Client发送确认包（即Client发来的FIN包的序号递增1，x + 1）。<br>发送完毕后，此时Server 进入 <code>CLOSE_WAIT</code> 状态（此时表明接收到了Client的关闭，但还没做好“思想准备“关闭连接）<br>当Client 端 接收到ACK包后，进入 <code>FIN_WAIT_2</code> 状态<br></li><li>Step 3（FIN）.<br>Server 端 发送ACK包一段时间（这段时间它有一些关闭过程）后，开始发送FIN包，序号为y<br>发送完毕后，此时Server 进入 <code>LAST_ACK</code> 状态<br></li><li>Step 4（ACK）.<br>当Client 端 接收到FIN包，即关闭请求后，发送一个确认包（即Server发来的FIN包的序号递增1，y + 1）<br>发送完毕后，此时Client  进入 <code>TIME_WAIT</code> 状态，目的在于在时间周期n内，允许Client 在发送的ACK包丢失的情况下重新发<br>当Server 端接收到ACK包后，连接正式关闭，此时Server进入 <code>CLOSED</code> 状态。Client资源（包括端口号、缓冲区数据）都被释放<br>当Client在时间周期n结束后，仍没收到Server 发的ACK包，则认为已正常关闭连接，此时Client 也进入 <code>CLOSE</code> 状态</li></ul><p><a name="EdGau"></a></p><h1 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h1><blockquote><p>从上面的体系图可以看到，TCP（即运输层）的报文信息最终会交付到网际层。而网际层不会提供可靠的服务。所以还是要TCP来保证可靠的传输，才能最终保证数据服务的可靠</p></blockquote><p><a name="ojMfe"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code>宏观上看，从TCP的特性可以得知，它有自己的错误检测机制、数据按序传输、确认应答+序列号、支持重传的功能。然后具体的内部处理是怎样的呢？主要有以下两点</code></pre><ul><li>停止等待协议这是最简单的保证可靠传输的协议以下会发生两种情况<ul><li>无差错<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191248595-92370406-641f-497b-a9c8-b50d1b81d4a7.jpeg#align=left&display=inline&height=452&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E6%97%A0%E5%B7%AE%E9%94%99.jpg&originHeight=452&originWidth=511&size=27921&status=done&style=none&width=511" alt="停止等待协助-无差错.jpg"><br>可以看到Client 在发送分组M1(即数据单元)后，暂停，等到Server发回确认后，继续发送下一个分组…<br>这是理想条件下的无差错情况</li><li>有差错</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191306837-86029c09-7535-4067-ad2a-84a581932092.jpeg#align=left&display=inline&height=451&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg&originHeight=451&originWidth=513&size=33516&status=done&style=none&width=513" alt="停止等待协助-超时重传.jpg"><br>当Client 发送 分组M1（会先设置一个计时器，在此计时器内M1仍存在，以便重传）时，可能会遇到数据无法到达Server，或者Server 检测出问题并丢弃了它，在指定时间内Client 如果未收到来自Server 的确认，则会重传M1，即人们常说的<code>超时重传</code>超时重传会有以下情况</p><pre><code>  - 确认丢失（发回延迟）&lt;br /&gt;Client发送分组M1,Server收到M1并发送确认分组，而在指定的时间内Client没有收到确认，后会重传M1.&lt;br /&gt;而由于Server 已经收到过M1了， 所以此时它需要 丢弃M1分组, 发送确认分组&lt;br /&gt;  - 确认迟到（发送延迟）&lt;br /&gt;由于网络延迟等原因，Client发送的分组M1，在指定时间后才到Server， 此时Client 还没来得及收到确认，再次发送分组M1&lt;br /&gt;而由于Server 刚好收到了M1，所以此时它需要 丢弃M1分组, 发送确认分组，&lt;br /&gt;Client 收到&gt;=2个以上的确认，会执行丢弃操作，并且停止发送&lt;br /&gt;</code></pre><ul><li>连续ARQ协议<br>由于停止等待协议对信道的利用率太低，故可以采用流水线的方式来传输，即连续ARQ协议。<br>这里需要提到一个<code>发送窗口</code>的概念。发送窗口支持滑动，所以也有<code>滑动窗口</code>这么一个概念<br>    Client 会维护一个发送窗口，一个窗口内可以有多个连续分组进行发送，而不必等待对方的确认一条条分组发。<br>    Server 亦不会对每个分组进行回传确认，而是在按需发送到达的最后一个分组到达之后，发送确认，代表这个窗口的分组已经发送成功</li></ul><p><a name="1Ljjk"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><a name="3vTak"></a></p><h3 id="1-使用滑动窗口"><a href="#1-使用滑动窗口" class="headerlink" title="1. 使用滑动窗口"></a>1. 使用滑动窗口</h3><pre><code>窗口主要分为接收窗口和发送窗口</code></pre><ul><li>接收窗口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582191463835-75b3e1a7-bae5-40e1-b310-3efe8b95950f.png#align=left&display=inline&height=104&name=%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png&originHeight=104&originWidth=636&size=21213&status=done&style=none&width=636" alt="接收窗口.png"></li></ul><p>“接收窗口”大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。图中，接收窗口是31~50，大小为20。<br>　　在接收窗口中，黑色的表示已收到的数据，白色的表示未收到的数据。<br>　　当收到窗口左边的数据，如27，则丢弃，因为这部分已经交付给主机；<br>　　当收到窗口右边的数据，如52，则丢弃，因为还没轮到它；<br>　　当收到已收到的窗口中的数据，如32，丢弃；<br>　　当收到未收到的窗口中的数据，如35，缓存在窗口中。</p><ul><li><p>发送窗口<br></p><pre><code>  ![发送窗口.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191487752-d6496e44-5da6-4121-922b-845d2dfbcf60.png#align=left&amp;display=inline&amp;height=126&amp;name=%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png&amp;originHeight=126&amp;originWidth=636&amp;size=20821&amp;status=done&amp;style=none&amp;width=636)</code></pre></li></ul><p>发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制，暂时可以理解swnd= rwnd =20。<br>　　图中分为四个区段，其中P1到P3是发送窗口。<br>　　tips：发送窗口以字节为单位。为了方便画图，图中展示得像以报文为单位一样。但这不影响理解。</p><p><a name="eXF2w"></a></p><h3 id="2-重传与确认"><a href="#2-重传与确认" class="headerlink" title="2. 重传与确认"></a>2. 重传与确认</h3><ul><li>确认<br>这里主要是通过累计确认的方式<br></li><li>重传<br>这里主要是上面说的<code>超时重传</code>，每一个报文都会有超时计数器，当超过指定时间后，Client（发送方）会触发重传报文</li></ul><p><a name="x3Wpy"></a></p><h3 id="3-流量控制（基于滑动窗口）"><a href="#3-流量控制（基于滑动窗口）" class="headerlink" title="3. 流量控制（基于滑动窗口）"></a>3. 流量控制（基于滑动窗口）</h3><pre><code>流量即发送方发送的报文流量。当接收方来不及处理数据时，通过滑动窗口，告诉发送方能够接受的单位字节是多少，以降低发送的频率，防止包丢失&lt;br /&gt;![流量控制.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191515681-2b00f8b3-3584-415e-9fb8-061bc3b5e8cc.png#align=left&amp;display=inline&amp;height=367&amp;name=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png&amp;originHeight=367&amp;originWidth=619&amp;size=98699&amp;status=done&amp;style=none&amp;width=619)</code></pre><ul><li><p>在建立连接时,接收方(B),告诉了发送方(A):<code>我的接收窗口是400(单位字节)</code>.<br></p></li><li><p>图中的<code>ACK</code>为TCP首部的ACK字段,<code>ack</code>为首部的确认号字段.<br></p></li><li><p>流量控制体现在:<code>rwnd=300, rwnd=100, rwnd=0</code>.在确认报文的窗口字段设定了发送方能够发出的数据多少,从而控制流量.注意只有到首部的<code>ACK</code>字段值为1,窗口字段的值才有效.<br></p></li><li><p>假设在B发送了<code>rwnd=0</code>之后,过段时间由于自己又希望接收到数据,于是发出<code>rwnd=400</code>的报文,但是该报文丢失了,这样A依然无法发送数据,B希望接收但接收不到数据.<br></p><p>  为解决该问题,TCP为每个链接都设有一个<code>持续计时器</code>.只要接收到对方窗口为0的通知,就启动持续计时器.在计时器到期后,就发送<code>探测报文</code>,对方可以在该报文的确认中告知当前的窗口值.若窗口任然为0,那么就重新设定计时器,若不为0,那么上述的问题就解决了。</p></li></ul><p><a name="V732a"></a></p><h3 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h3><pre><code>拥塞是指对网络某一资源(带宽,缓存等)的需求超过了可提供的部分,从而使网络中传送的数据不能按时到达,网络性能变差的情况.&lt;br /&gt;拥塞控制就是防止过多的数据注入到网络中,这样网络中的资源压力就小了.&lt;br /&gt;流量控制和拥塞控制似乎很相似,但是他们不同.前者立足于接收和发送者双方的情况;而后者注重的是数据量对网络环境的影响</code></pre><p><a name="CwpQP"></a></p><h1 id="TCP-粘包、拆包"><a href="#TCP-粘包、拆包" class="headerlink" title="TCP 粘包、拆包"></a>TCP 粘包、拆包</h1><blockquote><p>由于TCP 是一个面向字节流的协议，这也决定了它的数据是无结构的。所以TCP无法得知应用层对于这快数据的定义，而是基于自身缓冲区的实际情况进行数据包的拆分，或者将多个数据包进行合并来发送。</p></blockquote><p>参考下图，在不同的条件下，会发生多种现象</p><ul><li>Server 分别接收P1,P2，没有发生粘包、拆包<br></li><li>Server 一次接收P1+P2两个报文，发生了粘包<br></li><li>Server 先接收P2, 再分别接收了P1_1, P1_2，发生了拆包<br></li><li>Server 先接收了P2+P1_2，再接收了P1_1，发生了粘包、拆包<br></li><li>另一种极端情况，当窗口非常小，恰逢P1又很大时，可能会发生多次对P1进行拆包<br></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191541317-f601cb98-df74-4f9f-af86-e6a992687057.jpeg#align=left&display=inline&height=482&name=%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.jpg&originHeight=482&originWidth=601&size=22960&status=done&style=none&width=601" alt="粘包与拆包.jpg"></p><p>首先我们要知道，发送的数据会先传入发送缓冲区，再通过网络传输发送到接收端的缓冲区<br>以上现象发生的原因主要是</p><ul><li>发送的字节 大于 TCP发送缓冲区的大小，会发生拆包<br></li><li>发送的报文 大于 MSS(最大报文长度)，会发生拆包<br></li><li>发送的字节 小于 TCP发送缓冲区的大小，会将多次写入缓冲区的报文一并发送，即发生粘包<br></li></ul><p>解决方案，需要上层应用程序做对应的处理</p><ul><li><code>规定报文长度</code>。例如设定每条报文固定长度为200字节，当不够时，用空格填充<br></li><li><code>报文末尾添加回车换行符</code>。例如FTP协议<br></li><li><code>将报文分为header and body</code>，在头部中声明报文长度，然后根据这个长度来获取报文<br></li></ul><p>我们常用的Netty 已经帮我们处理好这些问题，我们仅需调用特定的方法即可。这个在后续的Netty挖掘机系列文章会提到栗子。<br>比如有：</p><ul><li><code>LineBasedFrameDecoder</code>  基于换行符解决<br></li><li><code>DelimiterBasedFrameDecoder</code> 基于分隔符解决<br></li><li><code>FixedLengthFrameDecoder</code> 指定长度解决</li></ul><p>参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">【读】这一次,让我们再深入一点 - TCP协议</a><br>参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">什么是 TCP 拆、粘包？如何解决？</a></p>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常见知识点整理</title>
      <link href="/2020/02/20/jvm-chang-jian-zhi-shi-dian-zheng-li/"/>
      <url>/2020/02/20/jvm-chang-jian-zhi-shi-dian-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM常见知识点整理"><a href="#JVM常见知识点整理" class="headerlink" title="JVM常见知识点整理"></a>JVM常见知识点整理</h1><p><a name="25742b8b"></a></p><h2 id="JAVA-代码执行顺序"><a href="#JAVA-代码执行顺序" class="headerlink" title="JAVA 代码执行顺序"></a>JAVA 代码执行顺序</h2><p>代码—编译器→字节码文件—JVM的解释器（类加载器）→机器码</p><p><a name="80000bf5"></a></p><h2 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h2><blockquote><p>分为直接内存，线程私有内存，线程共享内存。私有内存包括程序计数器，虚拟机栈，本地方法栈</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185140199-d875bdd3-9c15-4dca-a3cd-88707999ece8.jpeg#align=left&display=inline&height=1041&name=jvm_1.jpg&originHeight=1041&originWidth=1242&size=137836&status=done&style=none&width=1242" alt="jvm_1.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185146698-c0172500-5c06-4ee7-919c-d0fb422e3be4.jpeg#align=left&display=inline&height=663&name=jvm_2.jpg&originHeight=663&originWidth=1242&size=116477&status=done&style=none&width=1242" alt="jvm_2.jpg"></p><ul><li>程序计数器，当前线程所执行的字节码的行号指示器，每个线程都需要一个独立的计数器</li><li>虚拟机栈，线程私有，每执行一个方法都会创建一个栈帧，用于存储局部变量表、操作数栈，动态链接（运行期间获取对常量池的引用 等），方法出口等。方法从调用到执行完成，相当于一个栈帧在虚拟机栈入栈到出栈</li><li>本地方法区， 线程私有</li><li>堆，线程共享的一块内存区域，创建的对象和数组都在堆内存中，因重要区域而可被垃圾收集器收集，gc角度看可分为新生代和老年代</li><li>方法区，即永久代，线程共享。存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等。</li></ul><p><a name="2cd18ca3"></a></p><h2 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h2><blockquote><p>java堆从gc角度分为新生代和老年代</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185182099-b5a37c1b-d668-423a-816f-ed576de3570a.png#align=left&display=inline&height=264&name=jvm_3.png&originHeight=264&originWidth=627&size=42184&status=done&style=none&width=627" alt="jvm_3.png"></p><ul><li>新生代<br>存放新生对象，占堆的1/3空间。会频繁触发MinorGC进行垃圾回收。分为Eden（原始区），ServivorFrom（存活区），ServivorTo（存活区）三个区</li></ul><ol><li><p>Eden——新对象的出生地。如果该对象占用内存太大则会被分配到老年代。当它内存不够时会触发MinorGC</p><blockquote><p>简单描述下MinorGC的过程:即复制—清空—转换。主要采用复制算法。</p><ol><li>先将Eden和ServivorFrom中存活的对象复制到ServivorTo区（此时如果对象的年龄达到老年代的标准，则复制到老年代 || ServiceTo不够位置放了也复制到老年代），同时把对象的年龄+1</li><li>复制完后，清空Eden和ServiceFrom中的对象</li><li>再将ServiceFrom和ServiceTo进行互换。原ServiceTo中的对象作为下一次GC的被扫描者</li></ol></blockquote></li><li><p>ServivorFrom——上一次GC回收的幸存者，这一次GC回收的被扫描者</p></li><li><p>ServivorTo——保留一次MinorGC过程中的幸存者</p></li></ol><ul><li>老年代<br>主要存放生命周期长的内存对象。不会频繁执行MajorGC。当发生MajorGC时，至少已发生了一次MinorGC.当它满了装不下时，会产生OOM异常<blockquote><p>简单描述下MajorGC：即扫描—标记—整理（回收）。采用标记清除和标记整理的混合算法（因为单独采用标记清除算法会产生内存碎片）</p><ol><li>先扫描一次所有的老年代</li><li>标记存活的对象</li><li>回收未标记的对象</li></ol></blockquote>FullGC:针对整个堆的GC（新生代，老年代、元空间）操作，Full GC不等于Major GC，也不等于Minor GC+Major GC。</li></ul><ul><li>永久代<br>内存的永久保存区域。存放class和元数据的信息。当class被加载后则放入永久代，GC并不会对其进行清理。所以有机会会因为Class文件过多加载而导致OOM异常<blockquote><p>JAVA8中已移除永久代，被一个元数据区（元空间）的区域取代。元空间不在虚拟机中，而是直接在本地内存，所以它受限于本地内存的大小，而不再是虚拟机分配的区域大小</p></blockquote></li></ul><p><a name="265a5463"></a></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185270374-a17e3a59-33af-4afa-aea0-4d17210b0e98.png#align=left&display=inline&height=698&name=jvm_4.png&originHeight=698&originWidth=705&size=123324&status=done&style=none&width=705" alt="jvm_4.png"></p><p><a name="iLMP6"></a></p><h3 id="如何确定垃圾（对象已经死亡）"><a href="#如何确定垃圾（对象已经死亡）" class="headerlink" title="如何确定垃圾（对象已经死亡）"></a>如何确定垃圾（对象已经死亡）</h3><p><a name="klwkl"></a></p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>每创建一个对象就会有一个引用计数器。当对象被引用一次则计数器+1，引用失效则-1。所以当计数器为0时会认定它是垃圾！即可被GC回收<br>看似很合理，嗯<br>但是！一旦两个对象相互引用的时候，计数器永远不为0。此时就会导致OOM！</p><p><a name="3kKhM"></a></p><h4 id="可达性算法（JVM采用）"><a href="#可达性算法（JVM采用）" class="headerlink" title="可达性算法（JVM采用）"></a>可达性算法（JVM采用）</h4><p>从GC Roots为起点开始搜索，整个连通图中的对象都是可达（活）对象。对于无法到达的对象，便是不可达对象。此时并非死刑（即非可回收对象）。它们需要至少两次的标记过程，才会变为可回收对象，进而被GC回收</p><p><a name="JwUdv"></a></p><h3 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h3><p><a name="vzjrW"></a></p><h4 id="1-标记清除法"><a href="#1-标记清除法" class="headerlink" title="1. 标记清除法"></a>1. 标记清除法</h4><blockquote><p>从GC Roots根节点开始标记对象，未被标记的就为垃圾对象，然后将未被标记的对象进行清除</p></blockquote><p>缺点是 1. 内存碎片化严重，导致后面分配较大对象时无法找到足够的连续内存，而不得不提前触发一次垃圾收集； 2.标记清除效率不高<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185399768-6f3c72f5-5bc5-4ea1-a74a-796a26e81ebb.png#align=left&display=inline&height=442&name=jvm_5.png&originHeight=442&originWidth=716&size=86851&status=done&style=none&width=716" alt="jvm_5.png"></p><p><a name="iXlTX"></a></p><h4 id="2-复制（Copying）算法"><a href="#2-复制（Copying）算法" class="headerlink" title="2. 复制（Copying）算法"></a>2. 复制（Copying）算法</h4><blockquote><p>为了解决效率问题而生。将可用内存按容量分为大小相等的两块，每次只使用一块（活动区间）。当这一块内存用完了，则将还存活的对象（按前面说的，什么是存活对象？即从GC Roots出发，能到达的每个对象都是存活对象）放（复制）到另一块（空闲区间）上，接着把原来那块内存清理掉。这里的复制是按照内存地址依次排列，每次复制后将该存活对象的引用地址指向新的内存地址</p></blockquote><p>优点：不必考虑内存碎片；高效<br>缺点：浪费了一半的内存空间，无法让可用内存得到充分利用。<br>总结：对象的存活率非常低的时候就可采用，且能够克服50%内存的浪费，如新生代就采用了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185433277-369ff9db-ae4e-4aa1-b519-93016fda9abf.png#align=left&display=inline&height=444&name=jvm_6.png&originHeight=444&originWidth=753&size=97721&status=done&style=none&width=753" alt="jvm_6.png"></p><p><a name="w4tEz"></a></p><h4 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3. 标记整理算法"></a>3. 标记整理算法</h4><blockquote><p>为了解决当对象存活率高无法采用复制算法而生。和标记清除法的标记过程一样，只是标记后不直接清除，而是将存活对象都移动到内存的一端。端外部分就直接清理掉。老年代就采用这种算法</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185455380-6fd9d87c-273b-4767-ae0f-d6b5770b956c.png#align=left&display=inline&height=437&name=jvm_7.png&originHeight=437&originWidth=679&size=65150&status=done&style=none&width=679" alt="jvm_7.png"></p><p><a name="qGJzF"></a></p><h4 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h4><blockquote><p>jvm主采用。顾名思义，即根据对象存活的生命周期，将内存划分为不同的区域。将java堆划分为老年代和新生代。根据不同代采用不同的垃圾收集算法</p></blockquote><p>面试：请问当前主流jvm采用的垃圾收集算法是什么？ —&gt; 分代收集算法，划分不同代之后再根据对应特点采取合适的GC算法，如新生代采用复制算法，效率高，老年代采用标记算法</p><p><a name="c5ecc552"></a></p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><blockquote><p>什么是引用？<br>一个对象的创建，会对应在内存中申请一块空间来存放数据。当访问该对象的时候，不是直接访问它的内存地址，而是通过（指向该对象的内存地址的）引用去访问</p></blockquote><ul><li>强引用<br></li></ul><p>把一个对象赋给一个引用变量，则这个引用变量就是一个强引用<br>绝不会被GC回收<br>易造成内存泄漏<br>什么时候才会被回收？当不存在强引用，即没有任何引用对象指向它时</p><ul><li>软引用<br></li><li>弱引用<br></li><li>虚引用<br></li></ul><p><a name="bd0012cf"></a></p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><blockquote><p>将类的.class文件中的二进制数据加载到内存中，将其储存在方法区内。在堆中创建一个java.lang.Class对象，用于封装方法区内的数据结构</p></blockquote><p>分为五部分：加载，验证，准备，解析，初始化<br><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185499437-7ea7ffba-83c1-4ee7-b825-688cf4afc9e9.png#align=left&display=inline&height=400&name=jvm_8.png&originHeight=400&originWidth=1101&size=123605&status=done&style=none&width=1101" alt="jvm_8.png"></p><p><a name="ccc7aee1"></a></p><h3 id="1-加载（注意是类加载）"><a href="#1-加载（注意是类加载）" class="headerlink" title="1. 加载（注意是类加载）"></a>1. 加载（注意是类加载）</h3><p>英文为loading，顾名思义，加载某个类的java.lang.Class的对象到内存，作为方法区这个类的各个数据的入口。</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各个数据的访问入口。</li></ul><p>类加载的方式</p><ul><li>启动应用时候由JVM初始化加载</li><li>动态代理，通过Class.forName（）方法动态加载</li><li>Jar或War包</li></ul><p><a name="ee492a84"></a></p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，而不会危害虚拟机</p><p><a name="e88352bc"></a></p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>正式为类变量分配内存并设置类变量（static修饰）初始值阶段。即为方法区中分配其中类信息，常量，静态变量等所需的内存空间<br>注意<br>这里的初始值需要理解<br>如果是</p><pre><code>public static int num = 100</code></pre><p>则在准备阶段过后的初始化值为0而不是100。因为这阶段尚未执行任何JAVA方法，赋为100的操作是在程序被编译后，存放在类构造器方法之中<br>如果是</p><pre><code>public static final int num = 100</code></pre><p>则在准备阶段过后的初始化值为100，因为用final修饰则代表不可变性，非传递性</p><blockquote><p>延伸<br>final： 必须在声明的时候或者构造器初始化。不然编译器会报错</p><ul><li>修饰的method无法被重写（当你认为某个方法足够完整，子类中无需改变时，可以加上final）。final方法比非final方法要快，因为在编译时已经动态绑定了，无需运行时再绑定</li><li>修饰的类无法被继承，因为被final修饰的类通常是完整的，不可变的。如JAVA中的String、Integer类，一旦被创建就无法被更改。好处是它们的对象是只读的，可在多线程环境下安全的共享</li><li>修饰的变量为常量，在准备期就被初始化好，若试图修改，则编译器会报编译错误</li></ul></blockquote><p><a name="59d0c974"></a></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p><p><a name="97533e51"></a></p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>执行类构造器方法的过程。方法是由编译器自动收集类中的类变<br>量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类<br>的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译<br>器可以不为这个类生成()方法</p><blockquote><p>方法 与类的构造函数（实例构造器()方法）</p></blockquote><p><a name="2d8095b0"></a></p><h4 id="初始化时机："><a href="#初始化时机：" class="headerlink" title="初始化时机："></a>初始化时机：</h4><ul><li>new 字节码指令。使用new关键字实例化对象</li><li>getstatic 字节码指令。读取类的静态字段</li><li>pustatic 字节码指令。设置类的静态字段</li><li>invokestatic 字节码指令。使用java.lang.reflect包对类进行反射调用时</li><li>初始化类，发现其父类还没有进行初始化，则先触发父类初始化（若子类引用了父类中的静态字段，则只会触发父类的初始化，自身不会触发）</li><li>jvm启动时，程序指定一个执行main方法的主类，则先触发父类初始化</li></ul><p><a name="8502c5d3"></a></p><h4 id="初始化步骤："><a href="#初始化步骤：" class="headerlink" title="初始化步骤："></a>初始化步骤：</h4><ul><li>这个类还没被加载和连接，则先加载和连接该类</li><li>这个类的直接父类还没有被初始化，则先初始化该父类</li><li>这个类中有初识化语句，则依次执行</li></ul><p><a name="64dfc4c7"></a></p><h4 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h4><ul><li>System.exit()</li><li>程序正常结束</li><li>程序遇到异常或错误而异常终止</li><li>操作系统出错导致虚拟机进程终止</li></ul><p><a name="9995ffcc"></a></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><p>顾名思义，就是加载类到虚拟机中。虚拟机使用类的方式如下，java代码在编译器编译下生成字节码文件，接着通过类加载器读取字节码文件，生成对应的的一个java.lang.Class的一个实例，这个实例即代表一个类，再调用它的newInstance方法，即生成了一个类的对象。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185681698-fdb14d5a-fbb1-46d0-b750-adff2af72ba8.png#align=left&display=inline&height=399&name=class_loader.png&originHeight=399&originWidth=400&size=7516&status=done&style=none&width=400" alt="class_loader.png"></p><p>从JVM角度看，主要分为2种</p><ul><li>启动类加载器，使用C++语言实现，是虚拟机自身的一部分</li><li>其它的类加载器，使用java语言实现，独立于虚拟机外部，继承于java.lang.ClassLoader.</li></ul><p>从JAVA开发的角度看，主要分为3种</p><ul><li>启动类加载器（引导类加载器）：负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li><li>扩展类加载器：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用类加载器（系统类加载器）：这个类加载器是由<code>sun.misc.Launcher$AppClassLoader</code>实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader</code>方法的返回值，所以也叫系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li><li>自定义类加载器：由开发人员编写的自定义加载器。</li></ul><p><a name="f95efc19"></a></p><h4 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1 类与类加载器"></a>1 类与类加载器</h4><blockquote><p>一个类的唯一性的确定依赖于它类本身，加上加载它的类加载器。所以比较两个类是否相等，不仅要看它们是否有相同的全限定名，还要看他们是否属于同个类加载器加载。</p></blockquote><p>如下图所示，我们首先自定义了一个类加载器，用于加载同路径下的Class文件。然后使用这个加载器加载全限定名”jerry.jvm.ClassLoaderTest”的类。我们通过获取对象obj和ClassLoaderTest对应的类加载器，可以看出一个来自自定义的类加载器，另一个来自系统类加载器。故由以上的定义可得知，即使它两来自同个Class文件，但是所属的类加载器不同，所以它两本质上不相等。<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185707991-cdaf3eab-ebdc-4960-b395-938d9bdf06d0.jpeg#align=left&display=inline&height=833&name=code_1.jpg&originHeight=833&originWidth=747&size=37166&status=done&style=none&width=747" alt="code_1.jpg"></p><p><a name="c53fbce4"></a></p><h4 id="2-双亲委派模型（代理模式）"><a href="#2-双亲委派模型（代理模式）" class="headerlink" title="2 双亲委派模型（代理模式）"></a>2 双亲委派模型（代理模式）</h4><blockquote><p>JVM加载类时默认使用了双亲委派模型。双亲委派模型要求除了最顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。并且，这里的父子并不是由继承关系实现，而是由组合关系来复用父加载器的方法。</p></blockquote><pre><code>其工作原理是一个类加载器收到了类加载的请求，自己不会尝试去加载这个类，而是委托给父类加载器去加载，层层递归（本质上是loadClass的递归调用），最终会到达启动类加载器。如果父类加载器可以完成此次请求，则成功返回；否则（即父类加载器无法搜寻到这个类）子加载器才会尝试自己去加载。</code></pre><p>双亲委派的实现如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ClassNotFoundException    <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 若存在父类加载器，则依次递归获取</span>                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 获得顶层启动类加载器</span>                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                    <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                    <span class="token comment" spellcheck="true">// to find the class.</span>                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><a name="52b8c184"></a></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><pre><code>目的是保证java核心库api的类型安全。假设核心库中有`java.lang.Object`这个类（位于`rt.jar`），如果在JVM运行的时候，这个类需要加载到JVM中，如果此时是由应用类加载器来加载的话， 很可能会出现多个版本的`java.lang.Object`，这样会造成java核心库中的类型定义被随意定义，程序一片混乱。。所以有了双亲委派模型的话， 最终会传达到启动类加载器去尝试加载这个类，而在核心库中刚好有这个类，故而最终由它加载成功并返回，保证了应用中所使用的`java.lang.Object`都是同一个类。不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</code></pre><p><a name="2e769a75"></a></p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><pre><code>该模型决定了上层类加载器加载的类无法访问下层加载器加载的类。如Java 提供了很多**服务提供者接口（Service Provider Interface，SPI）**，允许第三方为这些接口提供实现。SPI的接口是java核心库的一部分，由启动类加载器加载，而SPI的实现类一般是由系统类加载器加载。这样会导致启动类加载器无法找到SPI的实现类，因为它只加载核心库。此时双亲委派模型就无法这个问题了。</code></pre><p><a name="50b41993"></a></p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><pre><code>为解决上述问题，JAVA设计团队引入了一个不太友好的设计：**线程上下文类加载器**（jdk1.2引入）。`java.lang.Thread`中的方法`getContextClassLoader()`和 `setContextClassLoader(ClassLoader cl)`来设置线程的上下文类加载器。若未通过 `setContextClassLoader(ClassLoader cl)`设置的话， 线程会继承父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是应用程序类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。通过**线程上下文类加载器**可以实现父类加载器去请求子类加载器完成类加载的操作。&lt;br /&gt;    这种行为实际上就是**打通了双亲委派模型的层次结构来逆向使用类加载器**，已经违背了双亲委派模型的一般性原则</code></pre><p><a name="8a30fc33"></a></p><h5 id><a href="#" class="headerlink" title></a></h5><p><a name="pYdku"></a></p><h5 id="思考—-gt-能不能自己写个类叫java-lang-System？"><a href="#思考—-gt-能不能自己写个类叫java-lang-System？" class="headerlink" title="思考—&gt;能不能自己写个类叫java.lang.System？"></a>思考—&gt;能不能自己写个类叫java.lang.System？</h5><p>肯定不行。从双亲委派的角度出发，System类最终会由启动类加载器加载并返回（从System.class.getClassLoader()==null 可以判断出）。假设不遵循双亲委派的话， 重写loadClass方法，尝试一下</p><p>首先自定义一个包名为java.lang的System类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">System</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再自定义一个类加载器去加载自定义的System类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 自定义一个类加载器</span>ClassLoader classLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 源代码需要先执行双亲委派的实现逻辑，这里去掉了，直接去加载类</span>        <span class="token keyword">return</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"java.lang.System"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object obj <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最终运行结果如下</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>SecurityException<span class="token operator">:</span> Prohibited <span class="token keyword">package</span> name<span class="token operator">:</span> java<span class="token punctuation">.</span>lang    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">preDefineClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">659</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">758</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SecureClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>SecureClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">142</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">467</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span>access$<span class="token function">100</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">73</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">368</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">362</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">361</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">424</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$AppClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>Launcher<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">331</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">357</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>launcher<span class="token punctuation">.</span>LauncherHelper<span class="token punctuation">.</span><span class="token function">checkAndLoadMain</span><span class="token punctuation">(</span>LauncherHelper<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">495</span><span class="token punctuation">)</span>Error<span class="token operator">:</span> A JNI error has occurred<span class="token punctuation">,</span> please check your installation and <span class="token keyword">try</span> againException in thread <span class="token string">"main"</span></code></pre><p>抛出一个安全异常：包名为禁用包名，进入preDefineClass()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> ProtectionDomain <span class="token function">preDefineClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>                                            ProtectionDomain pd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoClassDefFoundError</span><span class="token punctuation">(</span><span class="token string">"IllegalName: "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>name <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"java."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span>            <span class="token punctuation">(</span><span class="token string">"Prohibited package name: "</span> <span class="token operator">+</span>             name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pd <span class="token operator">=</span> defaultDomain<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">checkCerts</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> pd<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pd<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可见在内部已经做了限制，不允许java开头的包名被defineClass方法构造，而且defineClass是final方法，也无法通过重写来绕过该判断。<br>所以最终答案是不能！</p><p><a name="a11e41c7"></a></p><h4 id="3-自定义类加载器"><a href="#3-自定义类加载器" class="headerlink" title="3. 自定义类加载器"></a>3. 自定义类加载器</h4><p>要手写一个类加载器，需要先了解ClassLoader的主要方法</p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>defineClass(String name, byte[] b, int off, int len)</strong></td><td>把字节数组 b中的内容转换成 Java 类，该字节数组可以看成是二进制流字节组成的文件，返回的结果是<code>java.lang.Class</code>类的实例。这个方法被声明为 final的。</td></tr><tr><td><strong>loadClass(String name)</strong></td><td>上文中已贴出源码，实现了双亲委派模型，调用<code>findClass()</code>执行类加载动作,返回的是<code>java.lang.Class</code>类的实例。</td></tr><tr><td><strong>findClass(String name)</strong></td><td>通过传入的类全限定名name来获取对应的类，返回的是<code>java.lang.Class</code>类的实例，该类没有提供具体的实现，开发者在自定义类加载器时需重用此方法，在实现此方法时需调用<code>defineClass(String name, byte[] b, int off, int len)</code>方法。</td></tr></tbody></table><p>由之前的概述可得知，自定义类加载器有2种方式</p><ul><li>采用双亲委派模型，重写<code>findClass(String name)</code>，不需重写<code>loadClass(String name)</code></li><li>破坏双亲委派模型，重写<code>loadClass(String name)</code>，因为它内部正好实现了双亲委派。</li></ul><p>这里建议不要采取破坏双亲委派模型的操作去自定义类加载器。</p><p>以下是采用双亲委派模型的自定义类加载器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilesClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String roodDir<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FilesClassLoader</span><span class="token punctuation">(</span>String roodDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>roodDir <span class="token operator">=</span> roodDir<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FilesClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> classData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 找不到该类</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 生成并返回一个Class对象</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取该全限定名对应的类的文件路径</span><span class="token comment" spellcheck="true">//        String path = getClassNamePath(className);</span>        <span class="token comment" spellcheck="true">// 读取文件</span>        String filename <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">(</span>InputStream is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            InputStream is = new FileInputStream(path);</span>            ByteArrayOutputStream bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getClassNamePath</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 替换为不同操作系统的文件路径分割符</span>        className <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>roodDir<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> InstantiationException <span class="token punctuation">{</span>        FilesClassLoader classLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilesClassLoader</span><span class="token punctuation">(</span><span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">zclass</span> <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span><span class="token string">"my.jvm.FilesClassLoader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zclass<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zclass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// class my.jvm.FilesClassLoader</span>        <span class="token comment" spellcheck="true">// my.jvm.FilesClassLoader@677327b6</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="7efcb0ce"></a></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>容器资源隔离。如Tomcat，为了优化空间和防止不同webapp之间的jar包冲突，每个webapp都有自己的webAppClassLoader，用于加载自身classpath上的类，当遇到Tomcat容器自带的jar包时，委托给CommonClassLoader加载<br></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185864452-1fcc672e-0acb-421e-afe5-efbbab3c89e0.png#align=left&display=inline&height=355&name=jvm_9.png&originHeight=355&originWidth=449&size=30343&status=done&style=none&width=449" alt="jvm_9.png"></p><ol start="2"><li>代码保护。对于核心类，可能会把字节码加密，这时需要自定义Classloader，将字节码解密并加载。比如从网络输入流中读取类，先将其做解密操作，看是否符合相关的安全信息，再进行加载</li><li>特定位置获取类信息，如在自定义的路径、数据库、网络中获取。</li></ol><p><a name="99f1077c"></a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185871180-c755748c-d4fd-478d-883c-66d465109270.jpeg#align=left&display=inline&height=481&name=jvm_10.jpg&originHeight=481&originWidth=516&size=30525&status=done&style=none&width=516" alt="jvm_10.jpg"></p><p><a name="14834039"></a></p><h3 id="新生代收集器-Serial、ParNew、Parallel-Scavenge"><a href="#新生代收集器-Serial、ParNew、Parallel-Scavenge" class="headerlink" title="新生代收集器(Serial、ParNew、Parallel Scavenge)"></a>新生代收集器(Serial、ParNew、Parallel Scavenge)</h3><p><a name="6G2Yg"></a></p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>运行在Client模式下的默认新生代单线程收集器。<br>单线程意味着必须暂停其他所有工作线程（即Stop The World）、串行，<br>采用复制算法进行垃圾收集<br>收集器组合：Serial + CMS 、Serial + Serial Old<br>使用场景：Client模式（桌面应用）、单核服务器<br>使用方式：用-XX:+UseSerialGC 来选择Serial +Serial OId进行垃圾收集</p><p><a name="UNYAY"></a></p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial 多线程版本，其他一致。<br>收集器组合：ParNew + CMS 、ParNew + Serial Old<br>使用场景：多核服务器<br>使用方式：用-XX:+UseParNewGC 来选择ParNew +Serial OId进行垃圾收集<br>           用-XX:+UseConcMarkSweepGC 来选择ParNew+CMS+Serial Old进行垃圾收集</p><p><a name="RI5Iy"></a></p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>多线程收集器。<br>相较于以上的区别是尽可能缩短垃圾收集时用户线程停顿时间<br>目的是达到一个可控的吞吐量（CPU执行用户线程时间 / CPU执行总时间）<br>收集器组合：Parallel Scavenge + Serial Old、 Parallel Scavenge + Parallel Old<br>使用场景：注重吞吐量、高效利用CPU<br>使用方式：用-XX:+UseParallelGC 来选择Parallel Scavenge +Serial OId进行垃圾收集<br>           用-XX:+UseParallelOldGC 来选择 Parallel Scavenge + Parallel Old进行垃圾收集<br>相关参数：用-XX:+MaxGCPauseMillis 设置GC的最大停顿时间<br>           用-XX:+GCTimeRatio 设置GC时间占总时间的比率，默认值为99，即允许1%的GC时间<br>jdk1.7 1.8默认用它做新生代收集器</p><p><a name="fc3995ae"></a></p><h3 id="老年代收集器-Serial-Old、CMS、Parallel-Old"><a href="#老年代收集器-Serial-Old、CMS、Parallel-Old" class="headerlink" title="老年代收集器(Serial Old、CMS、Parallel Old)"></a>老年代收集器(Serial Old、CMS、Parallel Old)</h3><p><a name="9NibG"></a></p><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial 的老年代版本<br>采用标记-整理算法<br>收集器组合：Serial Old + Parallel Scavenge 、Serial Old + ParNew + CMS<br>使用场景：Client模式（桌面应用）、单核服务器、作为CMS收集器的后备方案</p><p><a name="hlJ9T"></a></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>以最短回收（用户线程）停顿时间为目标的收集器。<br>优点：并发收集、低停顿<br>缺点：</p><ul><li>对CPU资源敏感。随CPU数量下降，占用CPU资源越多，吞吐量越小。</li><li>无法处理浮动垃圾。可能会出现“Concurrent Mode Failure” 失败而导致另一次Full GC 的产生。在并发清理阶段，由于用户线程还在执行，伴随着有其他新的垃圾产生，导致因为出现在标记过后CMS无法在当次收集中处理掉他们。</li><li>内存碎片。在并发清除阶段采用了标记-清除算法，从而在收集结束后可能产生大量的内存碎片。可以使用-XX:+UseCMSCompactAtFullCollection 在CMS顶不住要进行Full GC时开启内存碎片的合并整理过程。由于内存碎片整理不是并行的，如果频繁操作的话会增加额外长的停顿时间。所以也可以使用-XX:+CMSFullGCsBeforeCompaction设置执行在进行若干次垃圾收集后再启动一次内存碎片整理</li></ul><p>过程分为4步骤：</p><ul><li>初识标记：标记GC Roots能直接到达的对象，速度较快（Stop The World）</li><li>并发标记：进行GC Roots Tracting，标记出所有垃圾对象，耗时较长</li><li>重新标记：修正并发标记 期间因用户程序继续运作而产生表达的那一部分对象的标记记录，初识标记&lt;耗时&lt;&lt;&lt;并发标记（Stop The World）</li><li>并发清除：用标记-清除算法清除垃圾对象，耗时较长（这里会产生内存碎片，可以用-XX:+UseCMSCompactAtFullCollection 或 -XX:+CMSFullGCsBeforeCompaction 进行内存碎片整理）</li></ul><p><a name="OGt9D"></a></p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p><a name="50f55aaf"></a></p><h3 id="堆内存收集器（G1）"><a href="#堆内存收集器（G1）" class="headerlink" title="堆内存收集器（G1）"></a>堆内存收集器（G1）</h3><p><a name="LY49m"></a></p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p><a name="4be0f743"></a></p><h2 id="JVM-配置常用参数"><a href="#JVM-配置常用参数" class="headerlink" title="JVM 配置常用参数"></a>JVM 配置常用参数</h2><p><a name="70bf997b"></a></p><h3 id="堆参数"><a href="#堆参数" class="headerlink" title="堆参数"></a>堆参数</h3><table><thead><tr><th align="left">参数</th><th>描述</th></tr></thead><tbody><tr><td align="left">-Xms</td><td>设置jvm启动时堆内存的初始化大小</td></tr><tr><td align="left">-Xmx</td><td>设置堆内存最大值</td></tr><tr><td align="left">-XX:PermSize</td><td>JVM初始分配的非堆内存</td></tr><tr><td align="left">-XX:MaxPermSize</td><td>JVM最大允许分配的非堆内存，按需分配</td></tr><tr><td align="left">-Xmn</td><td>设置新生代的空间大小，剩下的为老年代的空间大小</td></tr><tr><td align="left">-XX:PermGen</td><td>设置永久代内存的初始化大小（jdk1.8已废除永久代）</td></tr><tr><td align="left">-XX:MaxPermGen</td><td>设置永久代的最大值</td></tr><tr><td align="left">-XX:SurvivorRatio</td><td>设置Edem区和Survivor区的空间比例：Eden/S0 = Eden/S1，默认为8。即两个Survivor区与一个Eden区的比值为2:8</td></tr><tr><td align="left">-XX:NewRatio</td><td>设置新生代和老年代的比例大小，默认2。即新生代和老年代的比值为1:4</td></tr><tr><td align="left">-Xss</td><td>每个线程的堆栈大小</td></tr></tbody></table><p><a name="b7ccb2cc"></a></p><h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><blockquote><p>-XX:+ 启用选项<br>-XX:- 不启用选项</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器进行内存回收。串行，Young和old区都使用串行，使用复制算法回收，无线程切换开销</td></tr><tr><td>-XX:+UseParNewGC</td><td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器作为CMS收集器出现Coucurrent Mode Failure失败后的后备收集器使用。</td></tr><tr><td>-XX:+UseParallelGC</td><td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（由于Parallel Scavenge本身有PS MarkSweep收集器来对Old区进行回收，但是它和Serial Old的实现方式非常接近，故用其说明）的收集器组合进行内存回收。Young区：使用Parallel Scavenge回收算法，多线程并行回收。Old区：单线程</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td>-XX:+PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，设置后，大于这个参数的对象直接在老年代分配</td></tr><tr><td>-XX:+MaxTenuringThreshold</td><td>晋升到老年代的对象大小，设置后，大于这个参数的对象直接在老年代分配</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>-XX:+HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代剩余空间不足以应付新生代整个Eden区和Survivor区所有对象都存活的极端情况</td></tr><tr><td>-XX:+ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>-XX:+GCTimeRatio</td><td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>-XX:+MaxGCPauseMillis</td><td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>-XX:+CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td>-XX:+UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td>-XX:+CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><p>参考文章：</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p><p><a href="https://crowhawk.github.io/2017/08/21/jvm_6/" target="_blank" rel="noopener">深入理解JVM(6)——类加载器</a></p><p><a href="https://zhuanlan.zhihu.com/p/41672523" target="_blank" rel="noopener">细说JVM（类加载器）</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
