<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器系统日志管理logrotate</title>
      <link href="/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/"/>
      <url>/2020/05/31/fu-wu-qi-xi-tong-ri-zhi-guan-li-logrotate/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br />对于业务系统，每天都会输出大量的日志，并且增长极快，久而久之在有限的容量内总会消耗完服务器的磁盘空间；<br /><br><br />当我们遇到故障需要排查的时候，日志往往是第一选择，然而当日志日渐庞大的时候，排查成问题，空间也成问题；<br /><br><br />线上埋点系统出现问题，排查发现硬盘被日志撑爆了。<br /><br><br />。。。<br /><br><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>帮我们解决了日志方面的繁琐问题，<br /></p><ul><li>它支持自动执行日志的（周期性）切割，压缩，删除</li><li>可以指定目录存放压缩日志文件</li><li>当执行出错时可以指定email发出邮件报警</li></ul><p><a name="e05dce83"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><br /><a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">logrotate</a>旨在简化对生成大量日志文件的系统的管理。它允许自动旋转，压缩，删除和邮寄日志文件。每个日志文件可以每天，每周，每月或当它变得太大时处理。通常，logrotate作为每天cron任务运行。<br /></p><p><a name="e655a410"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br />主流的Linux系统一般都会自带logrotate包，如果没有，则使用以下命令安装<br /></p><pre class=" language-shell"><code class="language-shell">$ yum install logrotate crontabs $ logrotate -vlogrotate 3.8.6 - Copyright (C) 1995-2001 Red Hat, Inc.This may be freely redistributed under the terms of the GNU Public LicenseUsage: logrotate [-dfv?] [-d|--debug] [-f|--force] [-m|--mail command] [-s|--state statefile]        [-v|--verbose] [-l|--log STRING] [--version] [-?|--help] [--usage] [OPTION...] <configfile></code></pre><p><a name="6255b094"></a></p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的默认配置文件放在 <code>/etc/logrotate.conf</code>，我们无需对它进行操作<br /></p><p><a name="95cfe8dc"></a></p><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>有一个针对日志的自定义配置文件夹 <code>/etc/logrotate.d/</code>，可以看到系统已经默认配置了syslog、yum等日志管理配置<br /></p><pre><code>$ ll /etc/logrotate.d/-rw-r--r-- 1 root root  76 Aug  2  2018 bootlog-rw-r--r-- 1 root root 160 Sep 15  2017 chrony-rw-r--r-- 1 root root 408 Aug  2  2018 psacct-rw-r--r-- 1 root root 224 Aug  9  2018 syslog-rw-r--r-- 1 root root 100 Aug 21  2018 yum</code></pre><p><a name="19dc45e9"></a></p><h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><p><br /><a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>的执行文件放在 <code>/usr/sbin/logrotate</code><br /></p><p><a name="8dac4304"></a></p><h2 id="详细配置说明"><a href="#详细配置说明" class="headerlink" title="详细配置说明"></a>详细配置说明</h2><pre class=" language-shell"><code class="language-shell">/var/log/logback.log {    daily    rotate 30    compress    delaycompress    missingok       notifempty       size 30k       yearly    create 0600 root root    postrotate        # 输入指定的命令    endscript}</code></pre><ul><li>daily：日志文件按天轮换，还可以配置”weekly”，”monthly”，”yearly”。</li><li>rotate count：只能存储的归档文件数量，其他将被删除，如果count为0代表直接删除归档</li><li>compress：每次轮换完成后，将已轮换的归档用gzip压缩</li><li>delaycompress：与compress搭配使用，表示将最近归档文件的压缩推迟到下一个轮换周期</li><li>missingok：若当前日志文件缺少，则不发出错误消息而是继续执行下一个日志文件</li><li>notifempty：若当前日志为空，则不执行轮换</li><li>create mode owner group：在轮换之后，用指定权限创建新的日志文件，mode以八进制指定日志文件的模式（与chmod相同），owner指定将拥有日志文件的用户名，group指定日志文件将属于的组。可以省略任何日志文件属性，在这种情况下，新文件的那些属性将使用与原始日志文件相同的值来表示省略的属性。可以使用nocreate选项禁用此选项</li><li>postrotate/endscript：在所有指令完成后，postrotate和endscript里面指定的命令将被执行</li><li>size _size_：仅当日志文件大小超过指定字节大小时，才会触发轮换</li><li>dateext：使用当前日期作为命名格式</li><li>dateformat _format_string_：配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数</li></ul><p><br />更多配置查看<a href="https://linux.die.net/man/8/logrotate" target="_blank" rel="noopener">官方说明</a><br /></p><p><a name="4c763bb6"></a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><a name="ce559ba2"></a></p><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><ul><li>-d, –debug：开启调试模式，此时不会执行实际操作，但会打印出整个执行流程</li><li>-f, –force：强制轮换文件</li><li>-m, –mail ：压缩日志后，发送日志到指定邮箱</li><li>-s, –state=statefile ：使用指定的状态文件</li><li>-v, –verbose ：显示转储过程</li></ul><p><a name="17d444b6"></a></p><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>自动运行<br><br />默认情况下， <a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">logrotate</a>在安装时已创建了以天为单位的定时任务<pre class=" language-shell"><code class="language-shell">$ cat /etc/cron.daily/logrotate</code></pre></li></ul><p>#!/bin/sh<br>/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf<br>EXITVALUE=$?<br>if [ $EXITVALUE != 0 ]; then<br>    /usr/bin/logger -t logrotate “ALERT exited abnormally with [$EXITVALUE]”<br>fi<br>exit 0</p><pre><code>- &lt;br /&gt;当运行周期为周/月/年时，可以在/etc/cron.*/logrotate下配置即可，当然也可以手动配置到crontab上。- 手动运行   - debug模式（logrotate -d ）```shell$ logrotate -d /etc/logrotate.d/custom-log</code></pre><ul><li><p>verbose模式（logrotate -v ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -v /etc/logrotate.d/custom-log</code></pre></li><li><p>强制模式（logrotate -vf ）</p><pre class=" language-shell"><code class="language-shell">$ logrotate -vf /etc/logrotate.d/custom-log</code></pre></li></ul><p><a name="9c5945ef"></a></p><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><ol><li><p>强制模式不起作用<br><br />删除记录状态的文件</p><pre class=" language-shell"><code class="language-shell">$ rm /var/lib/logrotate/logrotate.status</code></pre></li><li><p>日志文件为空无法执行<br><br />那就让它不为空呗</p></li><li><p>使用nohup进行日志输出，接着日志切割后，原日志大小不变<br><br />改变nohup输出方式：nohup xxx.sh &gt;&gt; nohup.out &amp;，要有两个&gt;</p></li></ol><p><br />大概就是这样，让我们尝试接入到我们的系统内吧！</p>]]></content>
      
      
      <categories>
          
          <category> logrotate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器监控netdata</title>
      <link href="/2020/03/18/fu-wu-qi-jian-kong-netdata/"/>
      <url>/2020/03/18/fu-wu-qi-jian-kong-netdata/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Netdata"><a href="#什么是Netdata" class="headerlink" title="什么是Netdata"></a>什么是Netdata</h1><p>简单一句话，Netdata是一个分布式的实时健康监测系统。</p><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>对象</td><td>针对系统和应用程序的分布式，实时，性能和运行状况监视</td></tr><tr><td>可视化</td><td>Netdata使用高度互动的Web仪表板实时提供无与伦比的洞察力，以实时了解其运行的系统（包括Web服务器，数据库，应用程序）上发生的一切</td></tr><tr><td>自动化与集成化</td><td>它可以自动运行，无需任何第三方组件，也可以集成到现有的监视工具链（Prometheus，Graphite，OpenTSDB，Kafka，Grafana等）</td></tr><tr><td>高效</td><td>Netdata快速高效，旨在永久在所有系统（物理和虚拟服务器，容器，IoT设备）上运行，而不会中断其核心功能</td></tr><tr><td>分布式</td><td>可以针对多个节点进行统一管理</td></tr><tr><td>开源</td><td>Netdata是免费的开源软件，目前可在Linux，FreeBSD和MacOS上运行。</td></tr></tbody></table><p>Netdata诞生的背景，有兴趣的同学可以看看：<a href="https://blog.netdata.cloud/posts/redefining-monitoring-netdata/" target="_blank" rel="noopener">使用Netdata重新定义监视</a></p><p><a name="gXXM9"></a></p><h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><p>参考：<a href="https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/packaging/installer/#install-netdata-on-linux-manually</a></p><p><a name="eRo7M"></a></p><h2 id="Netdata插件"><a href="#Netdata插件" class="headerlink" title="Netdata插件"></a>Netdata插件</h2><p>以下插件，在安装时可以选择启用或禁用</p><table><thead><tr><th>软件包名</th><th>描述</th></tr></thead><tbody><tr><td><code>bash</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>curl</code></td><td>用于Shell插件和<strong>警报通知</strong></td></tr><tr><td><code>iproute</code> 或 <code>iproute2</code></td><td>用于监控** Linux流量QoS **<br />如果<code>iproute</code>提示不可用或已过时，请使用<code>iproute2</code></td></tr><tr><td><code>python</code></td><td>这对于大多数外部插件来说都是必须的</td></tr><tr><td><code>python-yaml</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-beanstalkc</code></td><td>用于监控<strong>beanstalkd</strong></td></tr><tr><td><code>python-dnspython</code></td><td>用于监控DNS的查询时间</td></tr><tr><td><code>python-ipaddress</code></td><td>用于监控** DHCPd **<br />只有Python V2才需要此软件包。Python V3已经嵌入了此功能</td></tr><tr><td><code>python-mysqldb</code><br />或<br /><code>python-pymysql</code></td><td>用于监控<strong>mysql</strong>或<strong>mariadb</strong> 数据库<br /><code>python-mysqldb</code>会运行地更快，所以它是首选</td></tr><tr><td><code>python-psycopg2</code></td><td>用于监控<strong>postgresql</strong>数据库</td></tr><tr><td><code>python-pymongo</code></td><td>用于监控<strong>mongodb</strong>数据库</td></tr><tr><td><code>nodejs</code></td><td>用于<code>node.js</code>插件来监控<strong>named</strong>和<strong>SNMP</strong>设备</td></tr><tr><td><code>lm-sensors</code></td><td>用于监控<strong>hardware sensors</strong></td></tr><tr><td><code>libmnl</code></td><td>用于收集netfilter指标</td></tr><tr><td><code>netcat</code></td><td>用于从远程系统中收集指标的Shell插件</td></tr></tbody></table><p>如果安装了上述软件包，Netdata功能将大大增加，但如果没有它们，Netdata仍然可以正常工作</p><p><a name="byYm9"></a></p><h2 id="自动安装"><a href="#自动安装" class="headerlink" title="自动安装"></a>自动安装</h2><blockquote><p>要在任何Linux系统（物理，虚拟，容器，IoT，边缘）上从源代码安装Netdata并使其与最新的版本自动保持最新，请运行以下命令</p></blockquote><pre class=" language-shell"><code class="language-shell"># make sure you run `bash` for your shellbash# install Netdata directly from GitHub sourcebash <(curl -Ss https://my-netdata.io/kickstart.sh)</code></pre><p>自动安装后，netdata默认的配置文件放在<code>/etc/netdata/netdata.conf</code>中</p><p>如果自动安装不顺利的同学， 可以采用手动安装的方式。</p><p><a name="2RgXA"></a></p><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p><a name="deBqx"></a></p><h3 id="安装Netdata所需的软件包"><a href="#安装Netdata所需的软件包" class="headerlink" title="安装Netdata所需的软件包"></a>安装Netdata所需的软件包<br /></h3><p><a name="djGNn"></a></p><h4 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h4><p>系统监控和许多应用程序监控，它没有mysql /mariadb，postgres，named，硬件监控和SNMP。</p><pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata</code></pre><br /><a name="G0hej"></a>#### 完整安装<pre class=" language-shell"><code class="language-shell">curl -Ss 'https://raw.githubusercontent.com/netdata/netdata-demo-site/master/install-required-packages.sh' >/tmp/kickstart.sh && bash /tmp/kickstart.sh -i netdata-all</code></pre><br /><a name="eEtu9"></a>### 安装Netdata<pre class=" language-shell"><code class="language-shell"># 下载Netdata（同时创建netdata目录）git clone https://github.com/netdata/netdata.git --depth=1cd netdata# 运行具有root权限的脚本来编译安装Netdata并启动它./netdata-installer.sh</code></pre><p>注意</p><ul><li>如果不想安装完后启动Netdata，加上<code>--dont-start-it</code> 参数</li><li>如果不想安装在默认目录，则可以这样，<code>./netdata-installer.sh --install /opt</code>，即可安装到<code>/opt/netdata</code> 中</li><li>安装完后， <code>/opt/netdata/etc/netdata/netdata.conf</code>配置文件会自动被创建，可以编辑此文件以更改设置首选项。一个最常见被调整选项是history，它控制Netdata将使用的内存数据库大小。其默认情况下应为“3600”秒（图表中一小时的数据），这使得Netdata将使用大约10-15MB的RAM（取决于系统检测到的图表数量）。请检查内存要求。  当修改配置后，需要重启</li></ul><p><a name="HBX6N"></a></p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>启动，停止和重新启动Netdata</p><pre class=" language-shell"><code class="language-shell">service netdata startservice netdata stopservice netdata restart</code></pre><p>当使用<code>service</code>（系统首选基于系统启动或停止的方法）无法实现的时候，可以尝试对<code>systemd</code>和<code>init.d</code>使用等效命令</p><pre class=" language-shell"><code class="language-shell">systemctl start netdatasystemctl stop netdatasystemctl restart netdata/etc/init.d/netdata start/etc/init.d/netdata stop/etc/init.d/netdata restart</code></pre><p><a name="OpWZX"></a></p><h2 id="访问Netdata仪表盘"><a href="#访问Netdata仪表盘" class="headerlink" title="访问Netdata仪表盘"></a>访问Netdata仪表盘</h2><p>打开<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><br />当出现无法访问的时候，检查下防火墙的状态，测试环境下将它关闭即可（生产环境不建议）。或者查看安全组是否屏蔽了该端口</p><pre class=" language-shell"><code class="language-shell"># 查看防火墙状态firewall-cmd --state# 关闭，或者指定开启某个端口的入站systemctl stop firewalld.service</code></pre><p><a name="qIvfM"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><table><thead><tr><th>路径</th><th>所有者</th><th>权限</th><th>Netdata</th><th>注释</th></tr></thead><tbody><tr><td><code>/etc/netdata</code></td><td>用户  <code>root</code><br />组 <code>netdata</code></td><td>目录<code>0755</code><br />文件<code>0640</code></td><td>读</td><td><strong>Netdata配置文件</strong><br />可能包含敏感信息，因此<code>netdata</code>允许组读取它们。</td></tr><tr><td><code>/usr/libexec/netdata</code></td><td>用户  <code>root</code><br />组 <code>root</code></td><td>任何人都可以执行<br />dirs <code>0755</code><br />文件<code>0644</code>或<code>0755</code></td><td>执行</td><td><strong>Netdata插件</strong><br />权限取决于文件-并非所有<strong>插件</strong>都应具有可执行标志。<br />有一些带有升级权限（Linux功能或<code>setuid</code>）的插件-这些插件应该仅按组可执行<code>netdata</code>。</td></tr><tr><td><code>/usr/share/netdata</code></td><td>用户  <code>root</code><br />组 <code>netdata</code></td><td>任何人的<br />目录<code>0755</code><br />文件都可读<code>0644</code></td><td>通过网络读取和发送</td><td><strong>Netdata Web静态文件</strong><br />这些文件通过网络发送给有权访问Netdata Web服务器的任何人。Netdata会检查这些文件的所有权（使用的<code>[web]</code>部分的设置<code>netdata.conf</code>），如果文件所有权不正确，则拒绝提供这些文件。不支持符号链接。Netdata也拒绝提供<code>..</code>名称中的URL 。</td></tr><tr><td><code>/var/cache/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>netdata</code></td><td>目录<code>0750</code><br />文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata临时数据库文件</strong><br />Netdata在此处存储其临时实时数据库。</td></tr><tr><td><code>/var/lib/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>netdata</code></td><td>目录<code>0750</code><br />文件<code>0660</code></td><td>读取，写入，创建，删除</td><td><strong>Netdata永久数据库文件</strong><br />Netdata在此处存储注册表数据，运行状况警报日志db等。</td></tr><tr><td><code>/var/log/netdata</code></td><td>用户  <code>netdata</code><br />组 <code>root</code></td><td>目录<code>0755</code><br />文件<code>0644</code></td><td>写，创造</td><td><strong>Netdata日志记录</strong><br />所有Netdata应用程序，将它们的错误或其他参考消息记录到此目录中的文件中。这些文件应进行日志轮换。</td></tr></tbody></table><p><a name="wvtdc"></a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a name="5aT8C"></a></p><h2 id="netdata-conf"><a href="#netdata-conf" class="headerlink" title="netdata.conf"></a>netdata.conf</h2><p>参考<a href="https://docs.netdata.cloud/daemon/config/" target="_blank" rel="noopener">https://docs.netdata.cloud/daemon/config/</a><br />可通过<a href="http://YOUR-HOST:19999" target="_blank" rel="noopener">http://YOUR-HOST:19999</a><a href="http://your_server_ip:19999/netdata.conf" target="_blank" rel="noopener">/netdata.conf</a> 查看netdata的配置信息，注释的配置使用对应的默认值<br />包含了很多配置项，如global、web、plugins、health、registry、cloud、backend、statsd等。每一个配置项下，有key-value的配置，通过key我们能比较快速地知道其含义。</p><p><a name="JP3Wj"></a></p><h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>默认端口为19999</p><pre class=" language-shell"><code class="language-shell">[web]        # default port = 19999</code></pre><p><a name="5EehV"></a></p><h3 id="修改左上角hostname"><a href="#修改左上角hostname" class="headerlink" title="修改左上角hostname"></a>修改左上角hostname</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350636961-acbafd22-e45c-43f3-ad1c-e21b62fe18f5.png#align=left&display=inline&height=81&name=image.png&originHeight=162&originWidth=438&size=11915&status=done&style=none&width=219" alt="image.png"></p><pre class=" language-shell"><code class="language-shell">[global]        hostname = localhost-1</code></pre><p><a name="6QA90"></a></p><h3 id="当配置多个节点后，修改注册节点的名称"><a href="#当配置多个节点后，修改注册节点的名称" class="headerlink" title="当配置多个节点后，修改注册节点的名称"></a>当配置多个节点后，修改注册节点的名称</h3><p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584350889946-22b8be07-eb61-41c8-9d86-d355b365c606.png#align=left&display=inline&height=170&name=image.png&originHeight=340&originWidth=558&size=28206&status=done&style=none&width=279" alt="image.png"></strong></p><pre class=" language-shell"><code class="language-shell">[registry]        registry hostname = local192.168.2.57</code></pre><p><a name="jcWWM"></a></p><h3 id="修改内存使用"><a href="#修改内存使用" class="headerlink" title="修改内存使用"></a>修改内存使用</h3><p>Netdata使用history标签作为配置内存使用的key，默认为3996秒，即在图表中你能看到的条目数。</p><p>参考以下估算标准，条目数与对应使用的内存</p><ul><li>3600秒（图表数据保留1小时）使用15 MB RAM</li><li>7200秒（图表数据保留2小时）使用30 MB RAM</li><li>14400秒（图表数据保留4小时）使用60 MB RAM</li><li>28800秒（图表数据保留8小时）使用120 MB RAM</li><li>43200秒（图表数据保留12小时）使用180 MB RAM</li><li>86400秒（24小时图表数据保留）使用360 MB RAM</li></ul><p>假设我想让Netdata保留2个小时的图表数据，则可以配置为</p><pre class=" language-shell"><code class="language-shell">[global]        history = 7200</code></pre><p><a name="3doYv"></a></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>参考<a href="https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start" target="_blank" rel="noopener">https://docs.netdata.cloud/docs/step-by-step/step-10/#required-before-you-start</a><br />为了提高性能和安全性，Netdata官方十分建议在Netdata前面添加一个代理。在这里，我们通常使用Nginx作为代理工具，并结合Cerbot来使用。</p><blockquote><p>什么是Cerbot？<br>Certbot是一种工具，可帮助您为您的域创建和续订证书+密钥对，注意，它是免费的！</p></blockquote><p><a name="18wXs"></a></p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>怎么安装和配置Nginx就不说了，这里贴一下官方建议的代理Netdata的配置<br />创建一个文件/etc/nginx/sites-available/netdata，内容如下 </p><pre class=" language-shell"><code class="language-shell">upstream backend {    server 127.0.0.1:19999;    keepalive 64;}server {    listen 80;    # Change `example.com` to match your domain name.    server_name netdata.example.com;    location / {        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://backend;        proxy_http_version 1.1;        proxy_pass_request_headers on;        proxy_set_header Connection "keep-alive";        proxy_store off;    }}</code></pre><p>运行测试配置文件是否正常</p><pre class=" language-shell"><code class="language-shell">sudo nginx -t</code></pre><p>如果没返回错误，再运行以下命令，在<code>sites-enabled</code>目录中创建软链接，重启以生效</p><pre class=" language-shell"><code class="language-shell">sudo ln -s /etc/nginx/sites-available/netdata /etc/nginx/sites-enabled/netdata</code></pre><p><a name="Dcdvn"></a></p><h3 id="Certbot"><a href="#Certbot" class="headerlink" title="Certbot"></a>Certbot</h3><p>Netdata还建议我们尽可能最大化地使用好代理：加密的HTTPS连接。所以Netdata给我们提供了一个免费的证书生成工具Certbot，使用它，我们将能自动生成证书，并能够支持自动地更新证书，运行以下命令</p><pre class=" language-shell"><code class="language-shell">sudo certbot --nginx</code></pre><p>系统会提示您一些问题。在Which names would you like to activate HTTPS for?提问时，点击 Enter。接下来是这个问题：</p><pre class=" language-shell"><code class="language-shell">Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you're confident your site works on HTTPS. You can undo thischange by editing your web server's configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</code></pre><p>如果确定想要强制使用HTTPS的话，则选择2，并且确定。</p><p>这样，我们就真正完成了代理的配置。</p><p><a name="FoKgv"></a></p><h3 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h3><p>当我们把代理设置完后，我们可能还需要一个密码验证，运行以下命令</p><pre class=" language-shell"><code class="language-shell"># 指定用户名为user，添加到.htpasswd文件中sudo sh -c "echo -n 'user:' >> /etc/nginx/.htpasswd"# 创建密码，系统将提示您创建一个密码sudo sh -c "openssl passwd -apr1 >> /etc/nginx/.htpasswd"</code></pre><p>打开Nginx配置文件，添加权限校验的配置吗，授权用户文件指向刚才创建的.htpasswd</p><pre class=" language-shell"><code class="language-shell">location / {        auth_basic "Restricted Content";        auth_basic_user_file /etc/nginx/.htpasswd;        ...}</code></pre><p>接着再重启nginx，即可开启密码校验功能。</p><p><a name="AOm0c"></a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a name="q69aK"></a></p><h2 id="仪表板区域"><a href="#仪表板区域" class="headerlink" title="仪表板区域"></a>仪表板区域</h2><p>Netdata的仪表板主要分为了三个区域：栏目、菜单、节点菜单<br><a name="n4R4n"></a></p><h3 id="栏目"><a href="#栏目" class="headerlink" title="栏目"></a>栏目</h3><p>分为多个部分，例如系统概述，CPU，磁盘，内存等<br />例如下面的内存栏目<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091930943-803eeaa8-14b8-46e2-83cd-e7b6987b027a.png#align=left&display=inline&height=1747&name=memorysection.png&originHeight=1747&originWidth=1108&size=218059&status=done&style=none&width=1108" alt="memorysection.png"></p><p><a name="up7Ct"></a></p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>菜单显示在标准仪表板的右侧，Netdata为每个部分生成一个菜单，菜单链接到它们所关联的部分。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091853647-8a8daaf5-edd2-4864-aa2c-05f7987dca3c.png#align=left&display=inline&height=823&name=menu.png&originHeight=823&originWidth=218&size=29721&status=done&style=none&width=218" alt="menu.png"></p><p><a name="8SCAR"></a></p><h3 id="节点菜单"><a href="#节点菜单" class="headerlink" title="节点菜单"></a>节点菜单</h3><p>节点菜单出现在标准仪表板的左上角，并标有Netdata正在监视的系统的主机名。<br />单击它会显示一个下拉菜单，其中包含您可能已通过Netdata注册表连接的所有节点。<br />默认情况下，“我的节点”标题下没有任何内容，但是您可以尝试使用任何演示Netdata节点来查看节点菜单的工作方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584091944663-e505e9ef-b2fc-4fa7-bf7e-87dabde524f7.png#align=left&display=inline&height=527&name=nodemenu.png&originHeight=527&originWidth=498&size=53129&status=done&style=none&width=498" alt="nodemenu.png"></p><p>通过Netdata Cloud或专用注册表添加节点后，您将看到它们出现在“我的节点”标题下。</p><p><a name="RA1Ep"></a></p><h2 id="自定义仪表板"><a href="#自定义仪表板" class="headerlink" title="自定义仪表板"></a>自定义仪表板</h2><p>Netdata将有关各个图表的信息存储在/netdata/web/dashboard_info.js文件中。<br />例如，以下是dashboard_info.js如何定义“系统概述”部分的方式。</p><pre class=" language-shell"><code class="language-shell">netdataDashboard.menu = {  'system': {    title: 'System Overview',    icon: '<i class="fas fa-bookmark"></i>',    info: 'Overview of the key system metrics.'  },</code></pre><p>注意，不能直接更改dashboard_info.js，而是应另外新建一个文件，Netdata已经提供了一个示例文件：dashboard_info_custom_example.js</p><pre class=" language-shell"><code class="language-shell">cd /netdata/web/sudo cp dashboard_info_custom_example.js your_dashboard_info_file.js</code></pre><p>自定义文件编写完后，在/netdata/web的目录下使用新建自定义文件的名称即可。</p><pre class=" language-shell"><code class="language-shell">[web] custom dashboard_info.js = your_dashboard_info_file.js</code></pre><p><a name="T1J1H"></a></p><h2 id="使用Netdata-Cloud监视多个系统"><a href="#使用Netdata-Cloud监视多个系统" class="headerlink" title="使用Netdata Cloud监视多个系统"></a>使用Netdata Cloud监视多个系统</h2><p>在第一个节点的仪表板上右上角点击登录按钮，此时Netdata将会发送一封验证邮件，点击链接后，该节点将自动链接到Netdata Cloud的账户，并重定向回仪表板。<br />其他节点也按同样的操作，即可。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1584331860428-276e3ea3-bfc4-4150-b9e5-186ecc0dc38b.png#align=left&display=inline&height=228&name=image.png&originHeight=456&originWidth=1903&size=112935&status=done&style=none&width=951.5" alt="image.png"></p><p><a name="MTK90"></a></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><a name="MFI0z"></a></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p><a name="Nnxqc"></a></p><h3 id="无需配置"><a href="#无需配置" class="headerlink" title="无需配置"></a>无需配置</h3><p><a name="Giiq1"></a></p><h3 id="长期指标存储"><a href="#长期指标存储" class="headerlink" title="长期指标存储"></a>长期指标存储</h3><p>使用我们的新数据库引擎，您可以存储每秒数天，数周或数月的历史指标。或者，您可以将指标归档到另一个数据库，例如MongoDB或Prometheus。</p><p><a name="bySdN"></a></p><h3 id="分布式，按系统安装"><a href="#分布式，按系统安装" class="headerlink" title="分布式，按系统安装"></a>分布式，按系统安装</h3><p>您无需将度量标准集中在一个位置，而是在每个系统上安装Netdata ，每个系统负责其度量标准。拥有分布式代理可以降低成本，并使Netdata可以在资源很少的设备（例如IoT和边缘设备）上运行，而不会影响其核心目的。</p><p><a name="jlznB"></a></p><h3 id="完善的健康监控功能"><a href="#完善的健康监控功能" class="headerlink" title="完善的健康监控功能"></a>完善的健康监控功能</h3><p>可确保您始终知道异常发生的时间</p><p><a name="HYtLj"></a></p><h3 id="高速，资源少的收集器"><a href="#高速，资源少的收集器" class="headerlink" title="高速，资源少的收集器"></a><strong>高速，资源少的收集器</strong></h3><p>每秒可以收集数千个指标，同时仅使用系统CPU资源的一小部分和少量MiB RAM。</p><p><a name="ghJbb"></a></p><h3 id="Netdata-Cloud"><a href="#Netdata-Cloud" class="headerlink" title="Netdata Cloud"></a>Netdata Cloud</h3><p>可帮助Netdata用户监视整个基础结构的运行状况和性能，无论它们是两千个（或两千个（或更多）！）系统。<br />如果使用Netdata监视多个系统，则Netdata Cloud可以提供集中监控解决方案的所有优势，同时又可以将工作负载分配给每个代理。<br />而且，更好的是，Netdata Cloud不存储系统的任何指标。它存储有关系统IP，主机名和随机创建的GUID的元数据，仅此而已。指标从系统直接流式传输到Web浏览器。<br />本质上，Web浏览器托管一个SaaS应用程序，并将Netdata Cloud的所有功能直接嵌入到仪表板中。<br />**<br><a name="mA1hH"></a></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>祥见：<a href="https://docs.netdata.cloud/zh/docs/netdata-security/" target="_blank" rel="noopener">https://docs.netdata.cloud/zh/docs/netdata-security/</a></p><p><a name="1KwLD"></a></p><h3 id="数据安全性"><a href="#数据安全性" class="headerlink" title="数据安全性"></a>数据安全性</h3><p>Netdata连接的数据源获取的原始数据只会保留在收集的主机，暴露出去的数据是图表元数据和度量标准值。</p><p><a name="Dwlwi"></a></p><h3 id="系统安全性"><a href="#系统安全性" class="headerlink" title="系统安全性"></a>系统安全性</h3><ul><li>Netdata守护程序，在收集系统以及因应用程序的各项指标时，以普通系统用户身份运行，没有构造特殊的特权。</li><li>从Netdata插件到Netdata守护程序，是通讯单向的，原始数据的不会离开收集过程，不会被保存；</li></ul><p><a name="KlAz0"></a></p><h3 id="只读收集指标"><a href="#只读收集指标" class="headerlink" title="只读收集指标"></a>只读收集指标</h3><p>Netdata只可以读取收集的指标，但是不能进行其他操作，也不会公开敏感信息和业务数据，如内核版本、O/S版本，应用程序版本等</p><p><a name="N0MJH"></a></p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>作为一个监视系统，查看者可以看到监视器上的所有的指标信息，此时应当受到保护，否则会出现 </p><ul><li><p>根据视图内容，进行探索测试DDOS攻击的入口</p><blockquote><p>什么是DDOS攻击？<br>分布式拒绝服务。短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线</p></blockquote></li><li><p>使用Netdata本身来给服务器施加压力，尽管只具有最低的进程优先级，仍可以导致OOM</p></li></ul><p><a name="e9VtT"></a></p><h1 id="github传送门"><a href="#github传送门" class="headerlink" title="github传送门"></a><a href="https://github.com/netdata/netdata/" target="_blank" rel="noopener">github传送门</a></h1><p><a name="bmtLw"></a></p><h1 id="Netdata中文汉化版"><a href="#Netdata中文汉化版" class="headerlink" title="Netdata中文汉化版"></a><a href="https://github.com/Fhaohaizi/netdata" target="_blank" rel="noopener">Netdata中文汉化版</a></h1>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务调度平台XXL-JOB</title>
      <link href="/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/"/>
      <url>/2020/02/27/fen-bu-shi-ren-wu-diao-du-ping-tai-xxl-job/</url>
      
        <content type="html"><![CDATA[<h1 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h1><p>以往系统中的周期性任务执行，一般有以下几种方式</p><ul><li>引入quartz or spring-task ，每一个任务对应编写一个执行类，配置调度规则执行</li><li>使用系统的执行器，比如centos的crontab，每一个任务对应编写一个执行类，并在crontab 配置调度规则</li></ul><p>此时，又会出现以下的问题</p><ul><li>任务出现异常，需增加报警功能</li><li>任务出现阻塞，比如上一次任务没执行完，下次任务会排队等待，以此累积</li><li>任务超时，需自己主动中断任务</li><li>单机任务调度下，系统出现异常，比如内存爆掉，磁盘空间不够用</li><li>任务失败，需hardcode 指定次数重试</li><li>在没有配日志可视化的前提下，查看日志需要去服务器上敲命令，面临rm -rf *的风险</li><li>…</li></ul><p><a name="03456e8f"></a></p><h1 id="二、什么是xxl-job"><a href="#二、什么是xxl-job" class="headerlink" title="二、什么是xxl-job"></a>二、什么是xxl-job</h1><p>XXL-JOB是一个轻量级分布式任务调度平台，支持通过 Web 页面对任务进行 CRUD 操作，支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，支持在线配置调度任务入参和在线查看调度结果。</p><p>它的特点有：</p><p>平台：</p><ul><li>调度中心式设计</li><li>解耦</li><li>用DB实现注册中心，实现轻量级部署</li><li>弹性扩、缩容</li><li>故障转移：执行器集群某台机器出现故障，能够自动切换正常的执行器</li><li>分片广播：且支持动态分片，提升任务运行效率</li><li>路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li><li>全异步化：异步调度和异步执行。</li></ul><p>任务：</p><ul><li>任务分布式执行</li><li>简单：支持通过web对任务进行crud</li><li>灵活：动态修改任务状态，自定义失败重试次数等，且即时生效</li><li>告警：任务失败，支持邮件告警</li></ul><p><a name="4a91069d"></a></p><h1 id="三、概念说明"><a href="#三、概念说明" class="headerlink" title="三、概念说明"></a>三、概念说明</h1><p><a name="0e46d8d6"></a></p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>调度任务，系统角色中的最小单元、</p><ul><li>可通过webide（GLUE模式） 或者ide（BEAN模式）自定义任务内容</li><li>支持多种路由策略和阻塞处理策略的选择</li><li>支持自定义失败重试次数和任务超时时间</li><li>支持任务失败告警</li><li>支持动态修改任务状态和各个配置策略的修改</li></ul><p><a name="f59ddb66"></a></p><h2 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h2><p>统一管理任务调度平台上的调度任务，负责触发调度执行，并提供可视化平台管理</p><p><a name="96a9b743"></a></p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>主要负责接收“调度中心”的调度并执行</p><p><a name="4e82ca40"></a></p><h1 id="四、安装启动"><a href="#四、安装启动" class="headerlink" title="四、安装启动"></a>四、安装启动</h1><p><a name="f26ef914"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job</a></p><p><a name="b6780d84"></a></p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Maven3+</li><li>JDK1.7+</li><li>MYSQL5.6+</li></ul><p><a name="1fa42afe"></a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a name="XzoRW"></a></p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><p>sql脚本在源码内，用navicat工具导入即可</p><pre class=" language-go"><code class="language-go">doc<span class="token operator">/</span>db<span class="token operator">/</span>tables_xxl_job<span class="token punctuation">.</span>sql</code></pre><p><a name="XHMkH"></a></p><h3 id="调度数据库配置说明"><a href="#调度数据库配置说明" class="headerlink" title="调度数据库配置说明"></a>调度数据库配置说明</h3><pre class=" language-go"><code class="language-go"><span class="token operator">-</span> xxl_job_lock：任务调度锁表；<span class="token operator">-</span> xxl_job_group：执行器信息表，维护任务执行器信息；<span class="token operator">-</span> xxl_job_info：调度扩展信息表： 用于保存XXL<span class="token operator">-</span>JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；<span class="token operator">-</span> xxl_job_log：调度日志表： 用于保存XXL<span class="token operator">-</span>JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；<span class="token operator">-</span> xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；<span class="token operator">-</span> xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；<span class="token operator">-</span> xxl_job_user：系统用户表；</code></pre><p><a name="WnTWG"></a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre class=" language-go"><code class="language-go">xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin：调度中心xxl<span class="token operator">-</span>job<span class="token operator">-</span>core：公共依赖xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>spring：Spring版本，通过Spring容器管理执行器，比较通用；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>frameless：无框架版本；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>jfinal：JFinal版本，通过JFinal管理执行器；    ：xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample<span class="token operator">-</span>nutz：Nutz版本，通过Nutz管理执行器；</code></pre><p><a name="UuWM4"></a></p><h3 id="配置部署“调度中心”（xxl-job-admin）"><a href="#配置部署“调度中心”（xxl-job-admin）" class="headerlink" title="配置部署“调度中心”（xxl-job-admin）"></a>配置部署“调度中心”（xxl-job-admin）</h3><p><a name="8rQNF"></a></p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">### web</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080</span><span class="token attr-name">server.context-path</span><span class="token punctuation">=</span><span class="token attr-value">/xxl-job-admin</span><span class="token comment" spellcheck="true">### resources</span><span class="token attr-name">spring.mvc.static-path-pattern</span><span class="token punctuation">=</span><span class="token attr-value">/static/**</span><span class="token attr-name">spring.resources.static-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/static/</span><span class="token comment" spellcheck="true">### freemarker</span><span class="token attr-name">spring.freemarker.templateLoaderPath</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/templates/</span><span class="token attr-name">spring.freemarker.suffix</span><span class="token punctuation">=</span><span class="token attr-value">.ftl</span><span class="token attr-name">spring.freemarker.charset</span><span class="token punctuation">=</span><span class="token attr-value">UTF-8</span><span class="token attr-name">spring.freemarker.request-context-attribute</span><span class="token punctuation">=</span><span class="token attr-value">request</span><span class="token attr-name">spring.freemarker.settings.number_format</span><span class="token punctuation">=</span><span class="token attr-value">0.##########</span><span class="token comment" spellcheck="true">### mybatis</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:/mybatis-mapper/*Mapper.xml</span><span class="token comment" spellcheck="true">### xxl-job, datasource</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">123456</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.tomcat.jdbc.pool.DataSource</span><span class="token attr-name">spring.datasource.tomcat.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">10000</span><span class="token attr-name">spring.datasource.tomcat.max-active</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">spring.datasource.tomcat.test-on-borrow</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.datasource.tomcat.validation-query</span><span class="token punctuation">=</span><span class="token attr-value">SELECT 1</span><span class="token attr-name">spring.datasource.tomcat.validation-interval</span><span class="token punctuation">=</span><span class="token attr-value">30000</span><span class="token comment" spellcheck="true">### xxl-job email</span><span class="token attr-name">spring.mail.host</span><span class="token punctuation">=</span><span class="token attr-value">smtp.qq.com</span><span class="token attr-name">spring.mail.port</span><span class="token punctuation">=</span><span class="token attr-value">25</span><span class="token attr-name">spring.mail.username</span><span class="token punctuation">=</span><span class="token attr-value">xxx@qq.com</span><span class="token attr-name">spring.mail.password</span><span class="token punctuation">=</span><span class="token attr-value">xxx</span><span class="token attr-name">spring.mail.properties.mail.smtp.auth</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.enable</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.starttls.required</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.mail.properties.mail.smtp.socketFactory.class</span><span class="token punctuation">=</span><span class="token attr-value">javax.net.ssl.SSLSocketFactory</span><span class="token comment" spellcheck="true">### xxl-job, access token</span><span class="token attr-name">xxl.job.accessToken</span><span class="token punctuation">=</span><span class="token comment" spellcheck="true">### xxl-job, i18n (default empty as chinese, "en" as english)</span><span class="token attr-name">xxl.job.i18n</span><span class="token punctuation">=</span></code></pre><p><a name="z5SBq"></a></p><h4 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h4><p><a name="KcwZA"></a></p><h5 id="方式一：项目打包部署"><a href="#方式一：项目打包部署" class="headerlink" title="方式一：项目打包部署"></a>方式一：项目打包部署</h5><ul><li>打包xxl-job-admin</li><li>调度中心访问地址：<a href="http://localhost:8080/xxl-job-admin" target="_blank" rel="noopener">http://localhost:8080/xxl-job-admin</a> (该地址执行器将会使用到，作为回调地址)<br><br />默认登录账号：admin    默认登录密码：123456</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786646307-a2fc191b-157e-4652-bd27-4a04bb881c71.jpeg#align=left&display=inline&height=689&name=center.jpg&originHeight=689&originWidth=1274&size=49771&status=done&style=none&width=1274" alt="center.jpg"></p><p><a name="d4afdc1b"></a></p><h5 id="方式二：Docker镜像搭建"><a href="#方式二：Docker镜像搭建" class="headerlink" title="方式二：Docker镜像搭建"></a>方式二：Docker镜像搭建</h5><ul><li><p>下载镜像</p><pre class=" language-shell"><code class="language-shell">docker pull xuxueli/xxl-job-admin</code></pre></li><li><p>创建容器</p><blockquote><p>由于官方镜像的配置文件（application.properties）是默认的，这里需要通过 “PARAMS” 指定，参数格式 RAMS=”–key=value  –key2=value2” 去修改；</p></blockquote></li></ul><pre class=" language-shell"><code class="language-shell">docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&characterEncoding=UTF-8" -p 8082:8080 -v /tmp:/data/applogs --name xxl-job-admin  -d xuxueli/xxl-job-admin</code></pre><ul><li>运行<pre class=" language-shell"><code class="language-shell">mvn clean packagedocker build -t xuxueli/xxl-job-admin ./xxl-job-admindocker run --name xxl-job-admin -p 8080:8080 -d xuxueli/xxl-job-admin</code></pre><a name="f68af6d7"></a><h5 id=""><a href="#" class="headerlink" title=""></a></h5><a name="hg5x5"></a><h5 id="调度中心集群（可选-）"><a href="#调度中心集群（可选-）" class="headerlink" title="调度中心集群（可选 ）"></a>调度中心集群（可选 ）</h5></li></ul><p>调度中心支持集群部署，提升调度系统容灾和可用性。<br />调度中心集群部署时，几点要求和建议：</p><ul><li>DB配置保持一致；</li><li>登陆账号配置保持一致；</li><li>集群机器时钟保持一致（单机集群忽视）；</li><li>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。</li></ul><p><a name="vz4xh"></a></p><h3 id="配置部署“执行器项目”（xxl-job-executor-sample）"><a href="#配置部署“执行器项目”（xxl-job-executor-sample）" class="headerlink" title="配置部署“执行器项目”（xxl-job-executor-sample）"></a>配置部署“执行器项目”（xxl-job-executor-sample）</h3><ul><li>执行器配置application.properties</li></ul><pre class=" language-go"><code class="language-go"># web portserver<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">8081</span># log configlogging<span class="token punctuation">.</span>config<span class="token operator">=</span>classpath<span class="token punctuation">:</span>logback<span class="token punctuation">.</span>xml### 调度中心部署跟地址 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行<span class="token string">"执行器心跳注册"</span>和<span class="token string">"任务结果回调"</span>；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>addresses<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>admin### 执行器AppName <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：执行器心跳注册分组依据；为空则关闭自动注册xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>appname<span class="token operator">=</span>xxl<span class="token operator">-</span>job<span class="token operator">-</span>executor<span class="token operator">-</span>sample### 执行器IP <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 <span class="token string">"执行器注册"</span> 和 <span class="token string">"调度中心请求并触发任务"</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>ip<span class="token operator">=</span>### 执行器端口号 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：小于等于<span class="token number">0</span>则自动获取；默认端口为<span class="token number">9999</span>，单机部署多个执行器时，注意要配置不同执行器端口xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">9999</span>### 执行器通讯TOKEN <span class="token punctuation">[</span>选填<span class="token punctuation">]</span>：非空时启用xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>accessToken<span class="token operator">=</span>### 执行器运行日志文件存储磁盘路径 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：需要对该路径拥有读写权限；为空则使用默认路径xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logpath<span class="token operator">=</span><span class="token operator">/</span>data<span class="token operator">/</span>applogs<span class="token operator">/</span>xxl<span class="token operator">-</span>job<span class="token operator">/</span>jobhandler### 执行器日志保存天数 <span class="token punctuation">[</span>选填<span class="token punctuation">]</span> ：值大于<span class="token number">3</span>时生效，启用执行器Log文件定期清理功能，否则不生效xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>logretentiondays<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span></code></pre><ul><li>部署项目<br />官方提供了多种执行器的示例项目，这里默认使用springboot。<br>执行器集群（可选）<br /><br><br />执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。<br><br />执行器集群部署时，几点要求和建议：<ul><li>执行器回调地址（xxl.job.admin.addresses）需要保持一致；执行器根据该配置进行执行器自动注册等操作。</li><li>同一个执行器集群内AppName（xxl.job.executor.appname）需要保持一致；调度中心根据该配置动态发现不同集群的在线执行器列表。</li></ul></li></ul><p><a name="26cc147d"></a></p><h1 id="五、开发"><a href="#五、开发" class="headerlink" title="五、开发"></a>五、开发</h1><blockquote><p>任务运行模式主要有Bean模式和Gule模式（理解为脚本）</p></blockquote><p><a name="048b136f"></a></p><h2 id="BEAN模式"><a href="#BEAN模式" class="headerlink" title="BEAN模式"></a>BEAN模式</h2><blockquote><p>在该模式下，任务的具体实现逻辑是 以JobHandler的形式存在于“执行器项目”中。</p></blockquote><ul><li>步骤一：新建执行器项目</li></ul><p>这里只要copy 项目<code>xxl-job-executor-sample-springboot</code> 即可</p><ul><li>步骤二：修改执行器appname</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> <span class="token string">"classpath:logback.xml"</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">xxl</span><span class="token punctuation">:</span>  <span class="token key atrule">job</span><span class="token punctuation">:</span>    <span class="token key atrule">accessToken</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">addresses</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8080/xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>admin    <span class="token key atrule">executor</span><span class="token punctuation">:</span>      <span class="token key atrule">appname</span><span class="token punctuation">:</span> xxl<span class="token punctuation">-</span>job<span class="token punctuation">-</span>executor<span class="token punctuation">-</span>test      <span class="token key atrule">ip</span><span class="token punctuation">:</span> <span class="token string">''</span>      <span class="token key atrule">logpath</span><span class="token punctuation">:</span> /data/applogs/xxl<span class="token punctuation">-</span>job/jobhandler      <span class="token key atrule">logretentiondays</span><span class="token punctuation">:</span> <span class="token number">-1</span>      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9999</span></code></pre><ul><li>步骤三：新建一个任务Handler：TestJobHandler</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>ReturnT<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>IJobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>handler<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>JobHandler<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>log<span class="token punctuation">.</span>XxlJobLogger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * &lt;p>Title:lyy-modular-saas-api&lt;/p> * &lt;p>Desc: 运行模式为Bean模式&lt;/p> * 开发步骤： * 1、继承"IJobHandler"：“com.xxl.job.core.handler.IJobHandler”； * 2、注册到Spring容器：添加“@Component”注解，被Spring容器扫描为Bean实例； * 3、注册到执行器工厂：添加“@JobHandler(value="自定义jobhandler名称")”注解，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 4、执行日志：需要通过 "XxlJobLogger.log" 打印执行日志； * @author Jerry * @version 1.0 * @since 2019/8/8 */</span><span class="token annotation punctuation">@JobHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"testJobHandler"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestJobHandler</span> <span class="token keyword">extends</span> <span class="token class-name">IJobHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ReturnT<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execute</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# start to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"beat at:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"################# end to job test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> SUCCESS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>步骤四：执行器管理，新增执行器</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786788896-d5796647-8a22-4b58-95dd-10dff177e364.jpeg#align=left&display=inline&height=472&name=actuator.jpg&originHeight=472&originWidth=601&size=11783&status=done&style=none&width=601" alt="actuator.jpg"></p><ul><li>步骤五：任务管理，新建调度任务</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786798752-af536e8e-0f70-4e85-a1a2-d9bdc2218c98.jpeg#align=left&display=inline&height=533&name=task.jpg&originHeight=533&originWidth=901&size=23727&status=done&style=none&width=901" alt="task.jpg"></p><ul><li>步骤六：执行任务，并查看日志</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786809410-16cd6399-94c2-44b3-8f79-41e91ddff21d.jpeg#align=left&display=inline&height=414&name=console_log.jpg&originHeight=414&originWidth=891&size=36655&status=done&style=none&width=891" alt="console_log.jpg"></p><p>可以看到，这里成功执行了先前自定义的调度任务，并输出了log，结合代码分析，任务执行的log通过<code>XxlJobLogger.log</code>记录并写到日志表内，调度中心后台读取日志表得到详细的log</p><p><a name="958f5368"></a></p><h2 id="GLUE模式"><a href="#GLUE模式" class="headerlink" title="GLUE模式"></a>GLUE模式</h2><blockquote><p>任务以源码方式维护在调度中心，支持通过Web IDE在线更新，实时编译和生效，因此不需要指定JobHandler</p></blockquote><p>拿GULE模式（JAVA）来解释，每一个GLUE模式的代码，在“执行器”接受到调度请求时，会通过Groovy类加载器加载出代码，并实例化成Java对象，同时注入此代码中声明的Spring服务（这里要确保代码中所引用的类或服务在“执行器项目中存在”），接着调用该对象的execute方法，执行具体的任务逻辑。</p><ul><li>步骤一：任务管理，新建调度任务<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786826556-7207d017-d8a7-4837-aabd-48381a7d4824.jpeg#align=left&display=inline&height=533&name=task_glue.jpg&originHeight=533&originWidth=902&size=24651&status=done&style=none&width=902" alt="task_glue.jpg"></p><ul><li>步骤二：点击操作，选择GLUE IDE，进入Web Ide界面<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786835674-f696b25f-cb86-48ff-ae46-f60eb95a042e.jpeg#align=left&display=inline&height=408&name=web_ide.jpg&originHeight=408&originWidth=694&size=13347&status=done&style=none&width=694" alt="web_ide.jpg"></p><p><a name="21449655"></a></p><h2 id="任务执行失败-邮件告警"><a href="#任务执行失败-邮件告警" class="headerlink" title="任务执行失败-邮件告警"></a>任务执行失败-邮件告警</h2><ul><li>步骤一：在之前 <code>3.3.1 更改配置</code>中，有相关邮件报警的发送方配置，配置即可</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">### 这里是用腾讯企业邮箱测试</span>spring.mail.host=smtp.exmail.qq.comspring.mail.port=465spring.mail.username=error@qq.comspring.mail.password=123456</code></pre><ul><li>步骤二：在 <code>任务管理，新建调度任务</code>中，配置接收告警邮件的邮箱，多个用“,”隔开即可</li></ul><p>相关的处理逻辑在调度中心的<code>JobFailMonitorHelper</code>类中</p><p><a name="6911d0e4"></a></p><h2 id="分片广播-amp-动态分片"><a href="#分片广播-amp-动态分片" class="headerlink" title="分片广播&amp;动态分片"></a>分片广播&amp;动态分片</h2><blockquote><p>执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务。<br>使用场景：</p><ol><li>分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；</li><li>广播任务场景：广播执行器机器运行shell脚本、广播集群节点进行缓存更新等</li></ol></blockquote><p><a name="z07er"></a></p><h3 id="步骤一：执行器集群部署，暂设置为2个节点"><a href="#步骤一：执行器集群部署，暂设置为2个节点" class="headerlink" title="步骤一：执行器集群部署，暂设置为2个节点"></a>步骤一：执行器集群部署，暂设置为2个节点</h3><p>执行器管理可以看到：一个APP有两个机器地址</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786903400-2e72b744-8d2d-42d5-bc4f-1bea33e059f3.jpeg#align=left&display=inline&height=337&name=actuators.jpg&originHeight=337&originWidth=1528&size=21343&status=done&style=none&width=1528" alt="actuators.jpg"></p><p><a name="A7kJB"></a></p><h3 id="步骤二：新增or更新任务，更改路由策略为分片广播"><a href="#步骤二：新增or更新任务，更改路由策略为分片广播" class="headerlink" title="步骤二：新增or更新任务，更改路由策略为分片广播"></a>步骤二：新增or更新任务，更改路由策略为分片广播</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582786916544-715046ad-6150-40bb-a59b-01918374aa3c.jpeg#align=left&display=inline&height=531&name=broadcast.jpg&originHeight=531&originWidth=898&size=23259&status=done&style=none&width=898" alt="broadcast.jpg"></p><p><a name="02TFX"></a></p><h3 id="步骤三：编写业务代码"><a href="#步骤三：编写业务代码" class="headerlink" title="步骤三：编写业务代码"></a>步骤三：编写业务代码</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分片参数</span>ShardingUtil<span class="token punctuation">.</span>ShardingVO shardingVO <span class="token operator">=</span> ShardingUtil<span class="token punctuation">.</span><span class="token function">getShardingVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分片参数：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XxlJobLogger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"分片参数1：当前分片序号 = {}, 总分片数 = {}"</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shardingVO<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 业务逻辑</span><span class="token comment" spellcheck="true">// ...</span></code></pre><p><a name="wybCl"></a></p><h3 id="步骤四：执行任务，查看运行日志"><a href="#步骤四：执行任务，查看运行日志" class="headerlink" title="步骤四：执行任务，查看运行日志"></a>步骤四：执行任务，查看运行日志</h3><pre class=" language-verilog"><code class="language-verilog"># 节点<span class="token number">1</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 分片参数：当前分片序号 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 命中分片开始处理<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>executor<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">37</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 忽略# 节点<span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 分片参数<span class="token number">1</span>：当前分片序号 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 总分片数 <span class="token operator">=</span> <span class="token number">2</span><span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">0</span> 片<span class="token punctuation">,</span> 忽略<span class="token number">2019</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">09</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">:</span><span class="token number">38</span> <span class="token punctuation">[</span>com<span class="token punctuation">.</span>lyyopen<span class="token punctuation">.</span>saas<span class="token punctuation">.</span>service<span class="token punctuation">.</span>jobhandler<span class="token punctuation">.</span>ShardingJobHandler#execute<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span> 第 <span class="token number">1</span> 片<span class="token punctuation">,</span> 命中分片开始处理</code></pre><p>可以看到一个集群的两个节点都收到了分片调度请求，业务逻辑即可针对对应的分片序号进行业务逻辑分片处理！</p><p><a name="6346b6d9"></a></p><h1 id="六、架构设计"><a href="#六、架构设计" class="headerlink" title="六、架构设计"></a>六、架构设计</h1><p><a name="41db83b4"></a></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>实现 调度+任务 两者解耦</li><li>调度行为在调度中心（admin后台），负责发起调度请求</li><li>任务抽象化为一个个JobHandler，交由“<code>执行器</code>”统一管理，“<code>执行器</code>”负责接收调度请求并找到对应的JobHandler，执行具体的业务逻辑（execute）</li></ul><p><a name="ff23e032"></a></p><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><ul><li><strong>调度模块（调度中心）</strong>： 负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块； 支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li><li><strong>执行模块（执行器）</strong>： 负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效； 接收“调度中心”的执行请求、终止请求和日志请求等。</li></ul><p><a name="65aa05f0"></a></p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582786987822-69688faa-9f2b-4d55-aea8-012599876e51.png#align=left&display=inline&height=822&name=architecture.png&originHeight=822&originWidth=1562&size=376301&status=done&style=none&width=1562" alt="architecture.png"></p><p><a name="ec0ef4cd"></a></p><h3 id="架构特性"><a href="#架构特性" class="headerlink" title="架构特性"></a>架构特性</h3><ul><li>解耦<br><br /><code>调度中心</code> 通过类rpc的调用模式，调用<code>执行器</code>暴露的远程服务；<br><br />详见日志远程调用源码：</li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>remoting<span class="token punctuation">.</span>invoker<span class="token punctuation">.</span>reference<span class="token punctuation">.</span>XxlRpcReferenceBean#getObject</code></pre><ul><li><p>线程池<br><br />调度采用线程池方式实现，避免用单线程出现阻塞而导致任务调度延迟；</p></li><li><p>并行调度<br><br />调度模块采用并行机制，而调度传递到<code>执行器</code>则是串行执行</p></li><li><p>多种路由策略</p></li><li><p>过期处理策略<br><br />过期5s内立即触发一次，过期超5s则忽略</p></li><li><p>日志回调服务<br><br /><code>“执行器”</code>在收到调度请求并执行任务后，会将任务的执行结果回调通知给调度中心，调度中心再对应更新日志表。<br><br />执行器触发回调线程处理源码：</p></li></ul><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>TriggerCallbackThread#doCallback</code></pre><ul><li><p>调度中心接受回调源码：</p><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>AdminBizImpl#<span class="token function">callback</span><span class="token punctuation">(</span>com<span class="token punctuation">.</span>xxl<span class="token punctuation">.</span>job<span class="token punctuation">.</span>core<span class="token punctuation">.</span>biz<span class="token punctuation">.</span>model<span class="token punctuation">.</span>HandleCallbackParam<span class="token punctuation">)</span></code></pre></li><li><p>任务集群<br><br />执行器如若集群部署，调度中心将会感知到在线的所有执行器</p></li><li><p>全异步化</p><ul><li>异步调度：调度中心每次任务触发时仅发送一次调度请求，该调度请求首先推送“异步调度队列”，然后异步推送给远程执行器</li><li>异步执行：执行器会将请求存入“异步执行队列”并且立即响应调度中心，异步运行。</li></ul></li><li><p>轻量级设计<br><br />XXL-JOB调度中心中每个JOB逻辑非常 “轻”，在全异步化的基础上，单个JOB一次运行平均耗时基本在 “10ms” 之内（基本为一次请求的网络开销）；因此，可以保证使用有限的线程支撑大量的JOB并发运行</p></li></ul><p><a name="ab715697"></a></p><h3 id="通讯流程分析"><a href="#通讯流程分析" class="headerlink" title="通讯流程分析"></a>通讯流程分析</h3><ul><li><code>调度中心</code>向<code>执行器</code>发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌Server，默认端口9999;</li><li><code>执行器</code>执行任务逻辑</li><li><code>执行器</code>http回调<code>调度中心</code>调度结果: <code>调度中心</code>中接收回调的服务，是针对<code>执行器</code>开放一套API服务;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> XXL-JOB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈（二）JAVA集合</title>
      <link href="/2020/02/20/lao-sheng-chang-tan-er-java-ji-he/"/>
      <url>/2020/02/20/lao-sheng-chang-tan-er-java-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="java-util-List"><a href="#java-util-List" class="headerlink" title="java.util.List"></a>java.util.List</h2><h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><ol><li>底层是基于（可调整大小）数组的数据结构，使用一块连续的内存空间保存数据</li><li>性能<ul><li>添加（或删除）操作。<ul><li>在不需要调整数组大小（即在末尾操作）的情况下，时间复杂度为O(1)；</li><li>在超过大小 时，会触发底层数组扩容（System.arraycopy()，复制到新的存储空间）最坏情况下（即超过了大小或者添加、修改了第一个数据）时间复杂度为O(n)。扩容后数组长度为原来的1.5倍。</li></ul></li><li>查询操作。直接通过下标访问元素，时间复杂度为O(1)；循环查找指定元素，时间复杂度为O(n)</li></ul></li><li>缺省下初始容量为10</li></ol><p><a name="LinkedList"></a></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote><p>什么是双向循环链表？</p><ol><li>链表中任意一个存储单元都可以通过向前或向后寻址的方式获取到其前一个存储单元和后一个存储单元</li><li>链表的尾节点的后一个节点是链表的头节点，链表的头节点的前一个节点是链表的尾节点</li></ol></blockquote><ol><li>底层是基于循环双向链表的数据结构，在非连续的内存空间中保存数据。在双向链表中，通过指针将各个内存单元连接在一起。每个节点都指向它的上一个和下一个节点。当需要存储数据时，分配一块内存空间并将这块内存插入链表中</li><li>性能<ul><li>添加（或删除）操作<br><br />时间复杂度为O(1)，不需重排原结构，只需要调整上一个和下一个节点的指针</li><li>查询操作。查找第n个数据或循环查找指定元素的时间复杂度为O(n)</li></ul></li><li>缺省下无初始容量</li></ol><p><a name="CopyOnWriteArrayList"></a></p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><blockquote><p>线程安全的ArrayList，通过增加 <code>写时复制语义</code>来实现线程安全性。特点如下</p><ol><li><code>延时懒惰策略</code>，当对list修改时，会先将list copy 一个副本，在副本里进行修改，接着将指向原来内存的指针指向新内存</li><li>适用于list 大小不大，读操作多于可变操作（因为可变操作：add、set 会导致复制整个list，意味着重新开辟一个内存区域，开销大）</li><li>使用迭代器进行遍历速度很快，在多线程下不会导致异常（Arraylist 在多线程下进行迭代，<code>可能会出现java.util.ConcurrentModificationException</code>异常，因为遍历时其他线程对list做了修改），因为CopyOnWriteArrayList 每次进行读写操作都会创建一个副本进行操作</li><li>内部用了Reentrantlock来保证线程安全</li></ol></blockquote><p>add源码如下：</p><p>在添加集合的时候上锁，保证同步，避免出现多线程写入时会copy出n个副本</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="java.util.Map"></a></p><h2 id="java-util-Map"><a href="#java-util-Map" class="headerlink" title="java.util.Map"></a>java.util.Map</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195085532-df2303dc-7ce4-4206-aa58-3fd29e756552.jpeg#align=left&display=inline&height=389&name=map-interface.jpg&originHeight=389&originWidth=640&size=28029&status=done&style=none&width=640" alt="map-interface.jpg"></p><p><a name="0e6b089f"></a></p><h3 id="Hashmap-数组-列表-红黑树"><a href="#Hashmap-数组-列表-红黑树" class="headerlink" title="Hashmap(数组+列表+红黑树)"></a>Hashmap(数组+列表+红黑树)</h3><blockquote><p>用一个数组（table[i]）来分散所有的key，一个key加入时，会用hash算法通过key计算出hash值，进而得到对应的数组下标i（这里是使用<code>(n - 1) &amp; hash</code> 位操作而不是取余），然后把这个entry插入到table[i]中，但是当有多个key同时被计算出同一个下标i，此时会产生冲突，即碰撞。对应采取的方案是会在table[i]上形成一个单向链表。当链表过多或过长时，查找算法会变成低效率的链表遍历，这是hash表的缺陷。而后java8做了改进，当链表中的元素超过8个时，会自动转为红黑树，此时查找效率提升为O(log n)，即根据树的高度去查找。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195097956-860f60e2-43b4-440c-aff1-f74c47b9b53f.jpeg#align=left&display=inline&height=419&name=hashmap.jpg&originHeight=419&originWidth=1242&size=124356&status=done&style=none&width=1242" alt="hashmap.jpg"></p><p><a name="ea8a77ba"></a></p><h4 id="什么是hashmap"><a href="#什么是hashmap" class="headerlink" title="什么是hashmap"></a>什么是hashmap</h4><p>是一个用于存储key-value的键值对集合，每一个键值对都是一个Entry，这些Entry分散存储在一个数组中，数组的每一个元素的初始值都是NULL.</p><p><a name="ed83bf84"></a></p><h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>通过put和get存取对象。用put存储对象时，主要是先通过调用hashcode计算hash从而得到bucket(桶)的位置，而后进一步存储，如果没碰撞就直接放入bucket；如果碰撞了，就以链表的形式存入；如果碰撞导致链表长度&gt;=TREEIFY_THRESHOLD，则将链表转为红黑树；如果该节点已存在值，则替换。当发现数组元素个数超过Threshold （Capacity * Loadfactor）时，会自动扩容为原来的2倍，即数组容量始终是2的幂。用get获取对象时，主要是先通过调用hashcode计算hash从而得到bucket（桶）的位置，并进一步调用了equal()确定键值对。当在bucket的第一个节点找到，则直接命中，如果是树结构，则在树中调用key.equals(k)查找，时间复杂度为O(log n)，如果是链表结构，则在链表中调用key.equals(k)，时间复杂度为O(n)</p><ol><li>初始长度16，Loadfactor 负载因子（当前Capacity 填满程度的最大比例）默认0.75。<br><br />建议为了避免性能消耗，初始化时确定好Map的容量，并且需要注意<br><br />容量 = ((float)期望容量大小 / 0.75F ) + 1.0F，源码在putAll()内:float ft = ((float)s / loadFactor) + 1.0F;<br><br />当我们确定好容量（并且需要是2的幂次方，这样可以避免一次运算）时，就可以避免rehash的操作，即扩容。这是一种用内存换性能的操作。</li><li>Capacity 当前数组容量，始终为2的幂。扩容后数组长度为原来的2倍。</li><li>Threshold 扩容阈值，等于Capacity * Loadfactor。当数组元素个数超过阈值时需要进行扩容（需要重建hash表），数组长度为原来的2倍。</li><li>可接受Null值</li><li>非线程安全。也就是没有加锁，查询会很快。但是任意时刻多个线程同时写入，会导致数据错乱或者其他异常情况，比如死锁导致CPU100%（环形链表）等。</li><li>发生hash碰撞时，jdk1.7是在链表头部添加元素（这也是导致死锁的原因之一），jdk1.8改进为在链表尾部添加元素<br><br />在多线程下，那些map是线程安全的<ul><li>Collections.synchronizedMap(内部用了synchronized，高并发效率低，不采用)</li><li>HashTable(内部用了synchronized，高并发效率低，不采用)</li><li>ConcurrentHashMap</li></ul></li><li>里面是一个数组，每个元素又是一个单向链表，所以查询时是根据hash值找到对应的数组下标，之后要顺着链表找到具体的值，所以时间复杂度为O(n)，而后java8作了修改，当链表元素超过TREEIFY_THRESHOLD = 8个（即某个桶中的记录超过8个）会自动转为红黑树，此时时间复杂度为O(log n)</li></ol><p><a name="d303267a"></a></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol><li>在获取bucket下标的时候，为什么要用位操作：(n - 1) &amp; hash 来代替 取余操作 hash % n？<br><br />由于hashmap底层实现上规定数组长度为2的幂（就算初始化非2的幂也会强制换算为最接近的2的幂），所以在此条件下，(n - 1) &amp; hash = hash % n。一样的效果，但是位操作的效率更高。假设数组长度为8，此时hash值为15，15 % 8 = 7，15 &amp; (8-1)=7</li><li>为什么数组长度必须是2的幂？<br><br />只有当数组长度为2的幂次方时，(n - 1) &amp; hash = hash % n，即实现了key的定位<br><br />2的幂次方也可以减少碰撞几率，提高HashMap的查询效率；当不是2的幂时，会导致(n-1)的二进制末位是0，进而导致数组可使用位置小了很多，导致碰撞的几率增大</li><li>能否使用任何类作为Map的key？<br><br />可以，遵循equals()和hashCode()方法的定义规则。由于map中存取对象put和get时，会遇到计算key的hash值，进而确定它在bucket中的位置。然而当key是自定义对象时，假设它是一个可变对象，也就意味着它的hash值也是可变。当自定义对象在存到Map后，内部做了修改，此时再也无法在Map内通过它找到原来的Entry。所以自定义对象的话，需要将它变成不可变对象，即重写hashCode和equals()方法。所以我们一般会用String，Integer这种不可变对象来作为key。</li><li>当两个键的hashcode相等时，如何获取值对象？<br><br />通过key的hash值找到bucket的位置，接着通过key.equals(k)方法找到对应的节点，最终找到值。</li><li>为什么负载因子默认是0.75？<br><br />这是一种概率问题，当负载因子过大时，会导致hash碰撞的概率增大，而且在降低空间开销的同时，提高了查找的时间开销；当负载因子过小时，会导致rehash频率增加，而且增大了已使用和未使用的空间的差值，浪费空间；0.75的话，在源码里面有说到TreeNote大小大约是常规节点的两倍，在理想情况下一个bin（也就是bucket）中的链表长度达到8的概率是0.00000006。简单地总结就是空间与时间的权衡选择了0.75。所以我们在初始化hashmap设置负载因子时，需要考虑要在空间上做优化还是时间上。</li><li>为什么定义桶中个数超过8才转红黑树？</li></ol><ul><li>首先我们要知道，桶中元素初始化是用链表保存的，其查找性能是O(n)，但是树结构决定了它的查找性能是O(log(n))，性能提升。<br /><br>在链表长度很小时，即时遍历速度也很快，但是当不断变长后，链表的查询性能肯定会受影响<br /><br>链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195141518-0649f97a-d62d-422f-9cf7-1409022da25f.jpeg#align=left&display=inline&height=1845&name=hashmap_1.jpg&originHeight=1845&originWidth=1242&size=679596&status=done&style=none&width=1242" alt="hashmap_1.jpg"></p><p>这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。由此可见，发展30年的Java每一项改动和优化都是非常严谨和科学的。</p><p>参考文章</p><p><a href="https://www.cnblogs.com/chinajava/p/5808416.html" target="_blank" rel="noopener">深入理解哈希表</a><br /><a href="http://www.importnew.com/14417.html" target="_blank" rel="noopener">Java 8：HashMap的性能提升</a><br /><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br /><a href="https://www.hollischuang.com/archives/2431" target="_blank" rel="noopener">关于HashMap容量的初始化，还有这么多学问</a><br /><a href="http://youzhixueyuan.com/the-underlying-structure-and-principle-of-hashmap.html" target="_blank" rel="noopener">深入探讨HashMap的底层结构、原理、扩容机制</a></p><p><a name="ConcurrentHashmap"></a></p><h3 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h3><p>以下是jdk1.7的整体结构图<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195162939-6b3b269e-4d49-4c3f-b130-ffc742610f44.jpeg#align=left&display=inline&height=683&name=chashmap.jpg&originHeight=683&originWidth=1242&size=176252&status=done&style=none&width=1242" alt="chashmap.jpg"></p><ol><li>一个Segment数组，每个Segment可看做一个hashmap，其引入了分段锁技术，即每一个Segment继承了Reentrantlock进而实现加锁，即每次保证线程安全锁住的是一个Segment，并行度默认为16，即最多可以有16个Segment(线程)支持并发写。而后java8也引入了红黑树<blockquote><p>分段锁：锁的时候不锁住整个hash表，而是锁一个segment</p></blockquote></li></ol><p>假设出现极端情况下，所有数据都集中在一个Segment，相当于并发下锁住了全表，这种情况下其实和HashTable差不多，但是整体上看效率还是有提升。<br><br />所以在jdk1.8后，摒弃了Segment思想，加入Cas和synchronized组合的方式实现线程安全：</p><ul><li>若插入位置为空，则使用cas来将数据放入table 的第一个位置。若插入不成功，会一直自旋…</li><li>若插入位置不为空，对当前数组位置的头节点上锁<ul><li>如果该节点为forwarding nodes，表明该位置上的链表或红黑树正在进行扩容，让当前线程参与协助并发扩容，提高效率</li><li>如果为链表，则逐层遍历，当发现key的hashcode值相等，则将该节点的数据替换，否则添加到链表末尾</li><li>如果为红黑树，则按对应规则put<ol start="2"><li>线程安全，支持并发操作。</li><li>key和value值不能为null</li></ol></li></ul></li></ul><p>以下是jdk1.8的整体结构图，看似很像hashmap的结构。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195215246-97e06ea3-f1ec-426d-aa44-0320f4e33318.jpeg#align=left&display=inline&height=419&name=chashmap_1.jpg&originHeight=419&originWidth=1242&size=114087&status=done&style=none&width=1242" alt="chashmap_1.jpg"><br />链表为O（n），因为取决于链表的长度<br />红黑树为O(log n），取决于树的高度</p><p>参考文章<br /><a href="https://www.codercto.com/a/68503.html" target="_blank" rel="noopener">解读Java8中ConcurrentHashMap是如何保证线程安全的</a></p><p><a name="TreeMap"></a></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol><li>数据结构是红黑树，即自平衡的排序二叉树。与哈希映射不同，树映射能保证其元素按升序键进行排序</li><li>继承了AbstractMap，所以它是一个key-value的map集合</li><li>实现了NavigableMap接口，能够按保存的key值排序，默认升序</li><li>实现了Cloneable接口，即支持被克隆</li><li>实现了java.io.Serializable接口，即支持序列化<table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>TreeMap()</td><td>此构造函数构造一个空树图，将使用键的自然顺序进行排序。</td></tr><tr><td>TreeMap(Comparator comparator)</td><td>此构造函数构造一个空的基于树的映射，该映射将使用比较器<code>comp</code>进行排序。</td></tr><tr><td>TreeMap(Map m)</td><td>此构造函数使用<code>m</code>中的条目初始化树映射，该映射将使用键的自然顺序进行排序。</td></tr><tr><td>TreeMap(SortedMap sm)</td><td>此构造函数使用<code>SortedMap sm</code>中的条目初始化树映射，该映射将按与<code>sm</code>相同的顺序排序。</td></tr></tbody></table></li></ol><p><a name="b6f16212"></a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>定义</p><ul><li>根节点必黑</li><li>每个叶节点必黑，即树尾端NIL指针或NULL节点</li><li>如果一个节点是红的，则它两个儿子都是黑的</li><li>对任一节点，它到树尾端NIL指针的每条路径都包含相同数目的黑节点，即相等黑节点数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195239143-93031ce5-6d92-411f-9fc1-4ae9850f070a.jpeg#align=left&display=inline&height=710&name=redwhitetree.jpg&originHeight=710&originWidth=1242&size=149130&status=done&style=none&width=1242" alt="redwhitetree.jpg"></p><p><a name="ulGXu"></a></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><a name="HashSet"></a></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>即hash表，存放的是哈希值。存储顺序非插入顺序，按哈希值存取。底层是使用了Hashmap来保存元素。<br />如何判断相等？先判断哈希值是否一样，再判断equal方法是否为true，则为同一个元素。<br />问题来了，equal为false但是哈希值是相等的，是怎么存的。其实是把相等哈希值放到一个哈希桶里，哈希一样的存一列。如下图1代表哈希值不同，图2代表相同，但是equal为false</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582195268204-7cc58b51-3062-4e66-8285-3db4d9d90a30.jpeg#align=left&display=inline&height=392&name=hashset.jpg&originHeight=392&originWidth=1242&size=73700&status=done&style=none&width=1242" alt="hashset.jpg"></p><p>最终可得结论，一个hashcode位置上可存放多个元素，Hashset通过hashcode确定元素在内存中的位置</p><p><a name="3f52d474"></a></p><h3 id="TreeSet-二叉树"><a href="#TreeSet-二叉树" class="headerlink" title="TreeSet(二叉树)"></a>TreeSet(二叉树)</h3><ol><li>利用二叉树的原理，将add的元素按指定的顺序进行排序，插入到二叉树指定的位置</li><li>Integer String可实现默认的排序，但是自定义对象需要实现Comparable接口，且要覆写该接口，并要有返回值</li></ol><p><a name="LinkHashSet"></a></p><h3 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h3><ol><li>继承于Hashset</li><li>基于LinkedHashMap实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老生常谈（一）TCP与UDP</title>
      <link href="/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/"/>
      <url>/2020/02/20/lao-sheng-chang-tan-yi-tcp-yu-udp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了更进一步了解网络层面的知识，先晒出一张网络体系结构图，加深理解。</p></blockquote><p><a name="0qP7n"></a></p><h1 id="计算机网络体系结构图"><a href="#计算机网络体系结构图" class="headerlink" title="计算机网络体系结构图"></a>计算机网络体系结构图</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582188081209-c85b7515-50d4-42c9-baf8-702116242721.png#align=left&display=inline&height=621&name=all.png&originHeight=621&originWidth=1041&size=251518&status=done&style=none&width=1041" alt="all.png"><br /><br><a name="4Wa7C"></a></p><h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP UDP的区别"></a>TCP UDP的区别</h1><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接的协议。基于这种连接方式， 通信设备应在传输数据前建立连接，并应在传输数据后关闭连接</td><td>面向数据报的协议。意味着打开、维护、终止连接不会有开销。UDP对于广播和多播类型的网络传输是有效的</td></tr><tr><td>点对点通信，连接两端的socket</td><td></td></tr><tr><td>面向字节流。TCP把传输的各种数据当做无结构的字节流来用</td><td></td></tr><tr><td>可靠性。它能够保证向目标路由器的数据传输</td><td>不可靠性。不能保证向目的地传送数据</td></tr><tr><td>错误检测机制。TCP提供了广泛的错误检查机制，这是因为它提供流量控制和数据确认。</td><td>UDP只有使用校验和的基本错误检查机制</td></tr><tr><td>数据排序。数据包能够按照顺序到达接收器</td><td>没有数据排序。若有需求，则需要再应用程序层进行管理</td></tr><tr><td>速度较慢。相对UDP而言速度较慢。</td><td>快、简单、高效</td></tr><tr><td>重传机制。支持重传丢失的数据包</td><td>无重传机制</td></tr><tr><td>标头大小为20个字节</td><td>标头大小为8个字节</td></tr><tr><td>重量级</td><td>轻量级</td></tr><tr><td>用于HTTP，HTTP，FTP，SMTP和Telnet</td><td>用于DNS，DHCP，TFTP，SNMP，RIP和VoIP</td></tr></tbody></table><p>注：本文所指的Client 均为发送方，Server为接收方</p><p><a name="wXUm8"></a></p><h1 id="TCP-三次握手、四次挥手"><a href="#TCP-三次握手、四次挥手" class="headerlink" title="TCP 三次握手、四次挥手"></a>TCP 三次握手、四次挥手</h1><p><a name="N7y6K"></a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><p>建立一个TCP连接时，需要Client和Server总共发送3个包。<br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191193844-5cd363e1-ca8f-42bc-8541-c6882e2d5ffe.jpeg#align=left&display=inline&height=421&name=3-way-handshake_1.jpg&originHeight=421&originWidth=572&size=35580&status=done&style=none&width=572" alt="3-way-handshake_1.jpg"></p><ul><li>Step 1（SYN）.<br />Client 端要和Server端 建立连接，所以要发一个SYN（即同步序列号）的包，初始序号x，保存在包头的序列号（Sequence Number）字段里，指明打算连接的Service port，。<br />用于告知Server：我（Client）可能要与你开始通讯了，现在发给你一个我（Client）启动段的序列号。<br />此时Client进入<code>SYN_SEND</code>状态<br /></li><li>Step 2（SYN+ACK）.<br>Server 端 接收到数据包（通知）后<br />使用一个SYN-ACK信号位设置，来响应Client 端的请求。<br />即发送了自己的序列号（SVN），初始序号为y，和确认号（ACK，即Client发来的序列号递增1， 即x + 1）。<br />此时Server进入 <code>SYN_RCVD</code> 状态<br /></li><li>Step 3（ACK）.<br />Client接收到Server端的响应后<br />发送确认包（ACK，即Server 发来的序列号递增1， 即y + 1）来确认收到响应，此时Client 进入 <code>ESTABLISHED</code> 状态，当Server 接收到该ACK包后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p><a name="2kajc"></a></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)。<br>需要四个包的原因是是因为TCP的半关闭引起的<br>客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p></blockquote><p>下面假设Client主动发起挥手动作<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191219910-edfed3ce-3fd3-42a2-97be-5274cc01272f.jpeg#align=left&display=inline&height=450&name=4-way-connect-termination.jpg&originHeight=450&originWidth=571&size=36350&status=done&style=none&width=571" alt="4-way-connect-termination.jpg"></p><ul><li>Step 1（FIN）.<br />Client 端（发起方）要关闭TCP连接，所以要发一个FIN包，序号为x。<br />发送完毕后，此时Client进入 <code>FIN_WAIT_1</code> 状态（此时表明无数据可发送，但仍可接受数据）<br /></li><li>Step 2（ACK）.<br />当Server 端 接收到FIN包后，立即向Client发送确认包（即Client发来的FIN包的序号递增1，x + 1）。<br />发送完毕后，此时Server 进入 <code>CLOSE_WAIT</code> 状态（此时表明接收到了Client的关闭，但还没做好“思想准备“关闭连接）<br />当Client 端 接收到ACK包后，进入 <code>FIN_WAIT_2</code> 状态<br /></li><li>Step 3（FIN）.<br />Server 端 发送ACK包一段时间（这段时间它有一些关闭过程）后，开始发送FIN包，序号为y<br />发送完毕后，此时Server 进入 <code>LAST_ACK</code> 状态<br /></li><li>Step 4（ACK）.<br />当Client 端 接收到FIN包，即关闭请求后，发送一个确认包（即Server发来的FIN包的序号递增1，y + 1）<br />发送完毕后，此时Client  进入 <code>TIME_WAIT</code> 状态，目的在于在时间周期n内，允许Client 在发送的ACK包丢失的情况下重新发<br />当Server 端接收到ACK包后，连接正式关闭，此时Server进入 <code>CLOSED</code> 状态。Client资源（包括端口号、缓冲区数据）都被释放<br />当Client在时间周期n结束后，仍没收到Server 发的ACK包，则认为已正常关闭连接，此时Client 也进入 <code>CLOSE</code> 状态</li></ul><p><a name="EdGau"></a></p><h1 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h1><blockquote><p>从上面的体系图可以看到，TCP（即运输层）的报文信息最终会交付到网际层。而网际层不会提供可靠的服务。所以还是要TCP来保证可靠的传输，才能最终保证数据服务的可靠</p></blockquote><p><a name="ojMfe"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code>宏观上看，从TCP的特性可以得知，它有自己的错误检测机制、数据按序传输、确认应答+序列号、支持重传的功能。然后具体的内部处理是怎样的呢？主要有以下两点</code></pre><ul><li>停止等待协议这是最简单的保证可靠传输的协议以下会发生两种情况<ul><li>无差错<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191248595-92370406-641f-497b-a9c8-b50d1b81d4a7.jpeg#align=left&display=inline&height=452&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E6%97%A0%E5%B7%AE%E9%94%99.jpg&originHeight=452&originWidth=511&size=27921&status=done&style=none&width=511" alt="停止等待协助-无差错.jpg"><br />可以看到Client 在发送分组M1(即数据单元)后，暂停，等到Server发回确认后，继续发送下一个分组…<br />这是理想条件下的无差错情况</li><li>有差错</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191306837-86029c09-7535-4067-ad2a-84a581932092.jpeg#align=left&display=inline&height=451&name=%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E5%8A%A9-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg&originHeight=451&originWidth=513&size=33516&status=done&style=none&width=513" alt="停止等待协助-超时重传.jpg"><br />当Client 发送 分组M1（会先设置一个计时器，在此计时器内M1仍存在，以便重传）时，可能会遇到数据无法到达Server，或者Server 检测出问题并丢弃了它，在指定时间内Client 如果未收到来自Server 的确认，则会重传M1，即人们常说的<code>超时重传</code>超时重传会有以下情况</p><pre><code>  - 确认丢失（发回延迟）&lt;br /&gt;Client发送分组M1,Server收到M1并发送确认分组，而在指定的时间内Client没有收到确认，后会重传M1.&lt;br /&gt;而由于Server 已经收到过M1了， 所以此时它需要 丢弃M1分组, 发送确认分组&lt;br /&gt;  - 确认迟到（发送延迟）&lt;br /&gt;由于网络延迟等原因，Client发送的分组M1，在指定时间后才到Server， 此时Client 还没来得及收到确认，再次发送分组M1&lt;br /&gt;而由于Server 刚好收到了M1，所以此时它需要 丢弃M1分组, 发送确认分组，&lt;br /&gt;Client 收到&gt;=2个以上的确认，会执行丢弃操作，并且停止发送&lt;br /&gt;</code></pre><ul><li>连续ARQ协议<br />由于停止等待协议对信道的利用率太低，故可以采用流水线的方式来传输，即连续ARQ协议。<br />这里需要提到一个<code>发送窗口</code>的概念。发送窗口支持滑动，所以也有<code>滑动窗口</code>这么一个概念<br />    Client 会维护一个发送窗口，一个窗口内可以有多个连续分组进行发送，而不必等待对方的确认一条条分组发。<br />    Server 亦不会对每个分组进行回传确认，而是在按需发送到达的最后一个分组到达之后，发送确认，代表这个窗口的分组已经发送成功</li></ul><p><a name="1Ljjk"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><a name="3vTak"></a></p><h3 id="1-使用滑动窗口"><a href="#1-使用滑动窗口" class="headerlink" title="1. 使用滑动窗口"></a>1. 使用滑动窗口</h3><pre><code>窗口主要分为接收窗口和发送窗口</code></pre><ul><li>接收窗口<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582191463835-75b3e1a7-bae5-40e1-b310-3efe8b95950f.png#align=left&display=inline&height=104&name=%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png&originHeight=104&originWidth=636&size=21213&status=done&style=none&width=636" alt="接收窗口.png"></li></ul><p>“接收窗口”大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。图中，接收窗口是31~50，大小为20。<br />　　在接收窗口中，黑色的表示已收到的数据，白色的表示未收到的数据。<br />　　当收到窗口左边的数据，如27，则丢弃，因为这部分已经交付给主机；<br />　　当收到窗口右边的数据，如52，则丢弃，因为还没轮到它；<br />　　当收到已收到的窗口中的数据，如32，丢弃；<br />　　当收到未收到的窗口中的数据，如35，缓存在窗口中。</p><ul><li><p>发送窗口<br /></p><pre><code>  ![发送窗口.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191487752-d6496e44-5da6-4121-922b-845d2dfbcf60.png#align=left&amp;display=inline&amp;height=126&amp;name=%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png&amp;originHeight=126&amp;originWidth=636&amp;size=20821&amp;status=done&amp;style=none&amp;width=636)</code></pre></li></ul><p>发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制，暂时可以理解swnd= rwnd =20。<br />　　图中分为四个区段，其中P1到P3是发送窗口。<br />　　tips：发送窗口以字节为单位。为了方便画图，图中展示得像以报文为单位一样。但这不影响理解。</p><p><a name="eXF2w"></a></p><h3 id="2-重传与确认"><a href="#2-重传与确认" class="headerlink" title="2. 重传与确认"></a>2. 重传与确认</h3><ul><li>确认<br />这里主要是通过累计确认的方式<br /></li><li>重传<br />这里主要是上面说的<code>超时重传</code>，每一个报文都会有超时计数器，当超过指定时间后，Client（发送方）会触发重传报文</li></ul><p><a name="x3Wpy"></a></p><h3 id="3-流量控制（基于滑动窗口）"><a href="#3-流量控制（基于滑动窗口）" class="headerlink" title="3. 流量控制（基于滑动窗口）"></a>3. 流量控制（基于滑动窗口）</h3><pre><code>流量即发送方发送的报文流量。当接收方来不及处理数据时，通过滑动窗口，告诉发送方能够接受的单位字节是多少，以降低发送的频率，防止包丢失&lt;br /&gt;![流量控制.png](https://cdn.nlark.com/yuque/0/2020/png/243176/1582191515681-2b00f8b3-3584-415e-9fb8-061bc3b5e8cc.png#align=left&amp;display=inline&amp;height=367&amp;name=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png&amp;originHeight=367&amp;originWidth=619&amp;size=98699&amp;status=done&amp;style=none&amp;width=619)</code></pre><ul><li><p>在建立连接时,接收方(B),告诉了发送方(A):<code>我的接收窗口是400(单位字节)</code>.<br /></p></li><li><p>图中的<code>ACK</code>为TCP首部的ACK字段,<code>ack</code>为首部的确认号字段.<br /></p></li><li><p>流量控制体现在:<code>rwnd=300, rwnd=100, rwnd=0</code>.在确认报文的窗口字段设定了发送方能够发出的数据多少,从而控制流量.注意只有到首部的<code>ACK</code>字段值为1,窗口字段的值才有效.<br /></p></li><li><p>假设在B发送了<code>rwnd=0</code>之后,过段时间由于自己又希望接收到数据,于是发出<code>rwnd=400</code>的报文,但是该报文丢失了,这样A依然无法发送数据,B希望接收但接收不到数据.<br /></p><p>  为解决该问题,TCP为每个链接都设有一个<code>持续计时器</code>.只要接收到对方窗口为0的通知,就启动持续计时器.在计时器到期后,就发送<code>探测报文</code>,对方可以在该报文的确认中告知当前的窗口值.若窗口任然为0,那么就重新设定计时器,若不为0,那么上述的问题就解决了。</p></li></ul><p><a name="V732a"></a></p><h3 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h3><pre><code>拥塞是指对网络某一资源(带宽,缓存等)的需求超过了可提供的部分,从而使网络中传送的数据不能按时到达,网络性能变差的情况.&lt;br /&gt;拥塞控制就是防止过多的数据注入到网络中,这样网络中的资源压力就小了.&lt;br /&gt;流量控制和拥塞控制似乎很相似,但是他们不同.前者立足于接收和发送者双方的情况;而后者注重的是数据量对网络环境的影响</code></pre><p><a name="CwpQP"></a></p><h1 id="TCP-粘包、拆包"><a href="#TCP-粘包、拆包" class="headerlink" title="TCP 粘包、拆包"></a>TCP 粘包、拆包</h1><blockquote><p>由于TCP 是一个面向字节流的协议，这也决定了它的数据是无结构的。所以TCP无法得知应用层对于这快数据的定义，而是基于自身缓冲区的实际情况进行数据包的拆分，或者将多个数据包进行合并来发送。</p></blockquote><p>参考下图，在不同的条件下，会发生多种现象</p><ul><li>Server 分别接收P1,P2，没有发生粘包、拆包<br /></li><li>Server 一次接收P1+P2两个报文，发生了粘包<br /></li><li>Server 先接收P2, 再分别接收了P1_1, P1_2，发生了拆包<br /></li><li>Server 先接收了P2+P1_2，再接收了P1_1，发生了粘包、拆包<br /></li><li>另一种极端情况，当窗口非常小，恰逢P1又很大时，可能会发生多次对P1进行拆包<br /></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582191541317-f601cb98-df74-4f9f-af86-e6a992687057.jpeg#align=left&display=inline&height=482&name=%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85.jpg&originHeight=482&originWidth=601&size=22960&status=done&style=none&width=601" alt="粘包与拆包.jpg"></p><p>首先我们要知道，发送的数据会先传入发送缓冲区，再通过网络传输发送到接收端的缓冲区<br />以上现象发生的原因主要是</p><ul><li>发送的字节 大于 TCP发送缓冲区的大小，会发生拆包<br /></li><li>发送的报文 大于 MSS(最大报文长度)，会发生拆包<br /></li><li>发送的字节 小于 TCP发送缓冲区的大小，会将多次写入缓冲区的报文一并发送，即发生粘包<br /></li></ul><p>解决方案，需要上层应用程序做对应的处理</p><ul><li><code>规定报文长度</code>。例如设定每条报文固定长度为200字节，当不够时，用空格填充<br /></li><li><code>报文末尾添加回车换行符</code>。例如FTP协议<br /></li><li><code>将报文分为header and body</code>，在头部中声明报文长度，然后根据这个长度来获取报文<br /></li></ul><p>我们常用的Netty 已经帮我们处理好这些问题，我们仅需调用特定的方法即可。这个在后续的Netty挖掘机系列文章会提到栗子。<br />比如有：</p><ul><li><code>LineBasedFrameDecoder</code>  基于换行符解决<br /></li><li><code>DelimiterBasedFrameDecoder</code> 基于分隔符解决<br /></li><li><code>FixedLengthFrameDecoder</code> 指定长度解决</li></ul><p>参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">【读】这一次,让我们再深入一点 - TCP协议</a><br />参考链接：<a href="https://juejin.im/post/5a49d95af265da430a50ed8c#heading-12" target="_blank" rel="noopener">什么是 TCP 拆、粘包？如何解决？</a></p>]]></content>
      
      
      <categories>
          
          <category> 老生常谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常见知识点整理</title>
      <link href="/2020/02/20/jvm-chang-jian-zhi-shi-dian-zheng-li/"/>
      <url>/2020/02/20/jvm-chang-jian-zhi-shi-dian-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM常见知识点整理"><a href="#JVM常见知识点整理" class="headerlink" title="JVM常见知识点整理"></a>JVM常见知识点整理</h1><p><a name="25742b8b"></a></p><h2 id="JAVA-代码执行顺序"><a href="#JAVA-代码执行顺序" class="headerlink" title="JAVA 代码执行顺序"></a>JAVA 代码执行顺序</h2><p>代码—编译器→字节码文件—JVM的解释器（类加载器）→机器码</p><p><a name="80000bf5"></a></p><h2 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="JVM 内存区域"></a>JVM 内存区域</h2><blockquote><p>分为直接内存，线程私有内存，线程共享内存。私有内存包括程序计数器，虚拟机栈，本地方法栈</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185140199-d875bdd3-9c15-4dca-a3cd-88707999ece8.jpeg#align=left&display=inline&height=1041&name=jvm_1.jpg&originHeight=1041&originWidth=1242&size=137836&status=done&style=none&width=1242" alt="jvm_1.jpg"><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185146698-c0172500-5c06-4ee7-919c-d0fb422e3be4.jpeg#align=left&display=inline&height=663&name=jvm_2.jpg&originHeight=663&originWidth=1242&size=116477&status=done&style=none&width=1242" alt="jvm_2.jpg"></p><ul><li>程序计数器，当前线程所执行的字节码的行号指示器，每个线程都需要一个独立的计数器</li><li>虚拟机栈，线程私有，每执行一个方法都会创建一个栈帧，用于存储局部变量表、操作数栈，动态链接（运行期间获取对常量池的引用 等），方法出口等。方法从调用到执行完成，相当于一个栈帧在虚拟机栈入栈到出栈</li><li>本地方法区， 线程私有</li><li>堆，线程共享的一块内存区域，创建的对象和数组都在堆内存中，因重要区域而可被垃圾收集器收集，gc角度看可分为新生代和老年代</li><li>方法区，即永久代，线程共享。存储被jvm加载的类信息，常量，静态变量，即时编译器编译后的代码等。</li></ul><p><a name="2cd18ca3"></a></p><h2 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h2><blockquote><p>java堆从gc角度分为新生代和老年代</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185182099-b5a37c1b-d668-423a-816f-ed576de3570a.png#align=left&display=inline&height=264&name=jvm_3.png&originHeight=264&originWidth=627&size=42184&status=done&style=none&width=627" alt="jvm_3.png"></p><ul><li>新生代<br />存放新生对象，占堆的1/3空间。会频繁触发MinorGC进行垃圾回收。分为Eden（原始区），ServivorFrom（存活区），ServivorTo（存活区）三个区</li></ul><ol><li><p>Eden——新对象的出生地。如果该对象占用内存太大则会被分配到老年代。当它内存不够时会触发MinorGC</p><blockquote><p>简单描述下MinorGC的过程:即复制—清空—转换。主要采用复制算法。</p><ol><li>先将Eden和ServivorFrom中存活的对象复制到ServivorTo区（此时如果对象的年龄达到老年代的标准，则复制到老年代 || ServiceTo不够位置放了也复制到老年代），同时把对象的年龄+1</li><li>复制完后，清空Eden和ServiceFrom中的对象</li><li>再将ServiceFrom和ServiceTo进行互换。原ServiceTo中的对象作为下一次GC的被扫描者</li></ol></blockquote></li><li><p>ServivorFrom——上一次GC回收的幸存者，这一次GC回收的被扫描者</p></li><li><p>ServivorTo——保留一次MinorGC过程中的幸存者</p></li></ol><ul><li>老年代<br />主要存放生命周期长的内存对象。不会频繁执行MajorGC。当发生MajorGC时，至少已发生了一次MinorGC.当它满了装不下时，会产生OOM异常<blockquote><p>简单描述下MajorGC：即扫描—标记—整理（回收）。采用标记清除和标记整理的混合算法（因为单独采用标记清除算法会产生内存碎片）</p><ol><li>先扫描一次所有的老年代</li><li>标记存活的对象</li><li>回收未标记的对象</li></ol></blockquote>FullGC:针对整个堆的GC（新生代，老年代、元空间）操作，Full GC不等于Major GC，也不等于Minor GC+Major GC。</li></ul><ul><li>永久代<br />内存的永久保存区域。存放class和元数据的信息。当class被加载后则放入永久代，GC并不会对其进行清理。所以有机会会因为Class文件过多加载而导致OOM异常<blockquote><p>JAVA8中已移除永久代，被一个元数据区（元空间）的区域取代。元空间不在虚拟机中，而是直接在本地内存，所以它受限于本地内存的大小，而不再是虚拟机分配的区域大小</p></blockquote></li></ul><p><a name="265a5463"></a></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185270374-a17e3a59-33af-4afa-aea0-4d17210b0e98.png#align=left&display=inline&height=698&name=jvm_4.png&originHeight=698&originWidth=705&size=123324&status=done&style=none&width=705" alt="jvm_4.png"></p><p><a name="iLMP6"></a></p><h3 id="如何确定垃圾（对象已经死亡）"><a href="#如何确定垃圾（对象已经死亡）" class="headerlink" title="如何确定垃圾（对象已经死亡）"></a>如何确定垃圾（对象已经死亡）</h3><p><a name="klwkl"></a></p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>每创建一个对象就会有一个引用计数器。当对象被引用一次则计数器+1，引用失效则-1。所以当计数器为0时会认定它是垃圾！即可被GC回收<br />看似很合理，嗯<br />但是！一旦两个对象相互引用的时候，计数器永远不为0。此时就会导致OOM！</p><p><a name="3kKhM"></a></p><h4 id="可达性算法（JVM采用）"><a href="#可达性算法（JVM采用）" class="headerlink" title="可达性算法（JVM采用）"></a>可达性算法（JVM采用）</h4><p>从GC Roots为起点开始搜索，整个连通图中的对象都是可达（活）对象。对于无法到达的对象，便是不可达对象。此时并非死刑（即非可回收对象）。它们需要至少两次的标记过程，才会变为可回收对象，进而被GC回收</p><p><a name="JwUdv"></a></p><h3 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h3><p><a name="vzjrW"></a></p><h4 id="1-标记清除法"><a href="#1-标记清除法" class="headerlink" title="1. 标记清除法"></a>1. 标记清除法</h4><blockquote><p>从GC Roots根节点开始标记对象，未被标记的就为垃圾对象，然后将未被标记的对象进行清除</p></blockquote><p>缺点是 1. 内存碎片化严重，导致后面分配较大对象时无法找到足够的连续内存，而不得不提前触发一次垃圾收集； 2.标记清除效率不高<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185399768-6f3c72f5-5bc5-4ea1-a74a-796a26e81ebb.png#align=left&display=inline&height=442&name=jvm_5.png&originHeight=442&originWidth=716&size=86851&status=done&style=none&width=716" alt="jvm_5.png"></p><p><a name="iXlTX"></a></p><h4 id="2-复制（Copying）算法"><a href="#2-复制（Copying）算法" class="headerlink" title="2. 复制（Copying）算法"></a>2. 复制（Copying）算法</h4><blockquote><p>为了解决效率问题而生。将可用内存按容量分为大小相等的两块，每次只使用一块（活动区间）。当这一块内存用完了，则将还存活的对象（按前面说的，什么是存活对象？即从GC Roots出发，能到达的每个对象都是存活对象）放（复制）到另一块（空闲区间）上，接着把原来那块内存清理掉。这里的复制是按照内存地址依次排列，每次复制后将该存活对象的引用地址指向新的内存地址</p></blockquote><p>优点：不必考虑内存碎片；高效<br />缺点：浪费了一半的内存空间，无法让可用内存得到充分利用。<br />总结：对象的存活率非常低的时候就可采用，且能够克服50%内存的浪费，如新生代就采用了<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185433277-369ff9db-ae4e-4aa1-b519-93016fda9abf.png#align=left&display=inline&height=444&name=jvm_6.png&originHeight=444&originWidth=753&size=97721&status=done&style=none&width=753" alt="jvm_6.png"></p><p><a name="w4tEz"></a></p><h4 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3. 标记整理算法"></a>3. 标记整理算法</h4><blockquote><p>为了解决当对象存活率高无法采用复制算法而生。和标记清除法的标记过程一样，只是标记后不直接清除，而是将存活对象都移动到内存的一端。端外部分就直接清理掉。老年代就采用这种算法</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185455380-6fd9d87c-273b-4767-ae0f-d6b5770b956c.png#align=left&display=inline&height=437&name=jvm_7.png&originHeight=437&originWidth=679&size=65150&status=done&style=none&width=679" alt="jvm_7.png"></p><p><a name="qGJzF"></a></p><h4 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h4><blockquote><p>jvm主采用。顾名思义，即根据对象存活的生命周期，将内存划分为不同的区域。将java堆划分为老年代和新生代。根据不同代采用不同的垃圾收集算法</p></blockquote><p>面试：请问当前主流jvm采用的垃圾收集算法是什么？ —&gt; 分代收集算法，划分不同代之后再根据对应特点采取合适的GC算法，如新生代采用复制算法，效率高，老年代采用标记算法</p><p><a name="c5ecc552"></a></p><h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><blockquote><p>什么是引用？<br>一个对象的创建，会对应在内存中申请一块空间来存放数据。当访问该对象的时候，不是直接访问它的内存地址，而是通过（指向该对象的内存地址的）引用去访问</p></blockquote><ul><li>强引用<br /></li></ul><p>把一个对象赋给一个引用变量，则这个引用变量就是一个强引用<br />绝不会被GC回收<br />易造成内存泄漏<br />什么时候才会被回收？当不存在强引用，即没有任何引用对象指向它时</p><ul><li>软引用<br /></li><li>弱引用<br /></li><li>虚引用<br /></li></ul><p><a name="bd0012cf"></a></p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><blockquote><p>将类的.class文件中的二进制数据加载到内存中，将其储存在方法区内。在堆中创建一个java.lang.Class对象，用于封装方法区内的数据结构</p></blockquote><p>分为五部分：加载，验证，准备，解析，初始化<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185499437-7ea7ffba-83c1-4ee7-b825-688cf4afc9e9.png#align=left&display=inline&height=400&name=jvm_8.png&originHeight=400&originWidth=1101&size=123605&status=done&style=none&width=1101" alt="jvm_8.png"></p><p><a name="ccc7aee1"></a></p><h3 id="1-加载（注意是类加载）"><a href="#1-加载（注意是类加载）" class="headerlink" title="1. 加载（注意是类加载）"></a>1. 加载（注意是类加载）</h3><p>英文为loading，顾名思义，加载某个类的java.lang.Class的对象到内存，作为方法区这个类的各个数据的入口。</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各个数据的访问入口。</li></ul><p>类加载的方式</p><ul><li>启动应用时候由JVM初始化加载</li><li>动态代理，通过Class.forName（）方法动态加载</li><li>Jar或War包</li></ul><p><a name="ee492a84"></a></p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，而不会危害虚拟机</p><p><a name="e88352bc"></a></p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>正式为类变量分配内存并设置类变量（static修饰）初始值阶段。即为方法区中分配其中类信息，常量，静态变量等所需的内存空间<br />注意<br />这里的初始值需要理解<br />如果是</p><pre><code>public static int num = 100</code></pre><p>则在准备阶段过后的初始化值为0而不是100。因为这阶段尚未执行任何JAVA方法，赋为100的操作是在程序被编译后，存放在类构造器方法之中<br />如果是</p><pre><code>public static final int num = 100</code></pre><p>则在准备阶段过后的初始化值为100，因为用final修饰则代表不可变性，非传递性</p><blockquote><p>延伸<br>final： 必须在声明的时候或者构造器初始化。不然编译器会报错</p><ul><li>修饰的method无法被重写（当你认为某个方法足够完整，子类中无需改变时，可以加上final）。final方法比非final方法要快，因为在编译时已经动态绑定了，无需运行时再绑定</li><li>修饰的类无法被继承，因为被final修饰的类通常是完整的，不可变的。如JAVA中的String、Integer类，一旦被创建就无法被更改。好处是它们的对象是只读的，可在多线程环境下安全的共享</li><li>修饰的变量为常量，在准备期就被初始化好，若试图修改，则编译器会报编译错误</li></ul></blockquote><p><a name="59d0c974"></a></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p><p><a name="97533e51"></a></p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>执行类构造器方法的过程。方法是由编译器自动收集类中的类变<br />量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类<br />的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译<br />器可以不为这个类生成()方法</p><blockquote><p>方法 与类的构造函数（实例构造器()方法）</p></blockquote><p><a name="2d8095b0"></a></p><h4 id="初始化时机："><a href="#初始化时机：" class="headerlink" title="初始化时机："></a>初始化时机：</h4><ul><li>new 字节码指令。使用new关键字实例化对象</li><li>getstatic 字节码指令。读取类的静态字段</li><li>pustatic 字节码指令。设置类的静态字段</li><li>invokestatic 字节码指令。使用java.lang.reflect包对类进行反射调用时</li><li>初始化类，发现其父类还没有进行初始化，则先触发父类初始化（若子类引用了父类中的静态字段，则只会触发父类的初始化，自身不会触发）</li><li>jvm启动时，程序指定一个执行main方法的主类，则先触发父类初始化</li></ul><p><a name="8502c5d3"></a></p><h4 id="初始化步骤："><a href="#初始化步骤：" class="headerlink" title="初始化步骤："></a>初始化步骤：</h4><ul><li>这个类还没被加载和连接，则先加载和连接该类</li><li>这个类的直接父类还没有被初始化，则先初始化该父类</li><li>这个类中有初识化语句，则依次执行</li></ul><p><a name="64dfc4c7"></a></p><h4 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h4><ul><li>System.exit()</li><li>程序正常结束</li><li>程序遇到异常或错误而异常终止</li><li>操作系统出错导致虚拟机进程终止</li></ul><p><a name="9995ffcc"></a></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><p>顾名思义，就是加载类到虚拟机中。虚拟机使用类的方式如下，java代码在编译器编译下生成字节码文件，接着通过类加载器读取字节码文件，生成对应的的一个java.lang.Class的一个实例，这个实例即代表一个类，再调用它的newInstance方法，即生成了一个类的对象。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185681698-fdb14d5a-fbb1-46d0-b750-adff2af72ba8.png#align=left&display=inline&height=399&name=class_loader.png&originHeight=399&originWidth=400&size=7516&status=done&style=none&width=400" alt="class_loader.png"></p><p>从JVM角度看，主要分为2种</p><ul><li>启动类加载器，使用C++语言实现，是虚拟机自身的一部分</li><li>其它的类加载器，使用java语言实现，独立于虚拟机外部，继承于java.lang.ClassLoader.</li></ul><p>从JAVA开发的角度看，主要分为3种</p><ul><li>启动类加载器（引导类加载器）：负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</li><li>扩展类加载器：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用类加载器（系统类加载器）：这个类加载器是由<code>sun.misc.Launcher$AppClassLoader</code>实现的。由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader</code>方法的返回值，所以也叫系统类加载器。它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li><li>自定义类加载器：由开发人员编写的自定义加载器。</li></ul><p><a name="f95efc19"></a></p><h4 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1 类与类加载器"></a>1 类与类加载器</h4><blockquote><p>一个类的唯一性的确定依赖于它类本身，加上加载它的类加载器。所以比较两个类是否相等，不仅要看它们是否有相同的全限定名，还要看他们是否属于同个类加载器加载。</p></blockquote><p>如下图所示，我们首先自定义了一个类加载器，用于加载同路径下的Class文件。然后使用这个加载器加载全限定名”jerry.jvm.ClassLoaderTest”的类。我们通过获取对象obj和ClassLoaderTest对应的类加载器，可以看出一个来自自定义的类加载器，另一个来自系统类加载器。故由以上的定义可得知，即使它两来自同个Class文件，但是所属的类加载器不同，所以它两本质上不相等。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185707991-cdaf3eab-ebdc-4960-b395-938d9bdf06d0.jpeg#align=left&display=inline&height=833&name=code_1.jpg&originHeight=833&originWidth=747&size=37166&status=done&style=none&width=747" alt="code_1.jpg"></p><p><a name="c53fbce4"></a></p><h4 id="2-双亲委派模型（代理模式）"><a href="#2-双亲委派模型（代理模式）" class="headerlink" title="2 双亲委派模型（代理模式）"></a>2 双亲委派模型（代理模式）</h4><blockquote><p>JVM加载类时默认使用了双亲委派模型。双亲委派模型要求除了最顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。并且，这里的父子并不是由继承关系实现，而是由组合关系来复用父加载器的方法。</p></blockquote><pre><code>其工作原理是一个类加载器收到了类加载的请求，自己不会尝试去加载这个类，而是委托给父类加载器去加载，层层递归（本质上是loadClass的递归调用），最终会到达启动类加载器。如果父类加载器可以完成此次请求，则成功返回；否则（即父类加载器无法搜寻到这个类）子加载器才会尝试自己去加载。</code></pre><p>双亲委派的实现如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ClassNotFoundException    <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 若存在父类加载器，则依次递归获取</span>                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 获得顶层启动类加载器</span>                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                    <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                    <span class="token comment" spellcheck="true">// to find the class.</span>                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><a name="52b8c184"></a></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><pre><code>目的是保证java核心库api的类型安全。假设核心库中有`java.lang.Object`这个类（位于`rt.jar`），如果在JVM运行的时候，这个类需要加载到JVM中，如果此时是由应用类加载器来加载的话， 很可能会出现多个版本的`java.lang.Object`，这样会造成java核心库中的类型定义被随意定义，程序一片混乱。。所以有了双亲委派模型的话， 最终会传达到启动类加载器去尝试加载这个类，而在核心库中刚好有这个类，故而最终由它加载成功并返回，保证了应用中所使用的`java.lang.Object`都是同一个类。不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</code></pre><p><a name="2e769a75"></a></p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><pre><code>该模型决定了上层类加载器加载的类无法访问下层加载器加载的类。如Java 提供了很多**服务提供者接口（Service Provider Interface，SPI）**，允许第三方为这些接口提供实现。SPI的接口是java核心库的一部分，由启动类加载器加载，而SPI的实现类一般是由系统类加载器加载。这样会导致启动类加载器无法找到SPI的实现类，因为它只加载核心库。此时双亲委派模型就无法这个问题了。</code></pre><p><a name="50b41993"></a></p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><pre><code>为解决上述问题，JAVA设计团队引入了一个不太友好的设计：**线程上下文类加载器**（jdk1.2引入）。`java.lang.Thread`中的方法`getContextClassLoader()`和 `setContextClassLoader(ClassLoader cl)`来设置线程的上下文类加载器。若未通过 `setContextClassLoader(ClassLoader cl)`设置的话， 线程会继承父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是应用程序类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。通过**线程上下文类加载器**可以实现父类加载器去请求子类加载器完成类加载的操作。&lt;br /&gt;    这种行为实际上就是**打通了双亲委派模型的层次结构来逆向使用类加载器**，已经违背了双亲委派模型的一般性原则</code></pre><p><a name="8a30fc33"></a></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p><a name="pYdku"></a></p><h5 id="思考—-gt-能不能自己写个类叫java-lang-System？"><a href="#思考—-gt-能不能自己写个类叫java-lang-System？" class="headerlink" title="思考—&gt;能不能自己写个类叫java.lang.System？"></a>思考—&gt;能不能自己写个类叫java.lang.System？</h5><p>肯定不行。从双亲委派的角度出发，System类最终会由启动类加载器加载并返回（从System.class.getClassLoader()==null 可以判断出）。假设不遵循双亲委派的话， 重写loadClass方法，尝试一下</p><p>首先自定义一个包名为java.lang的System类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">System</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再自定义一个类加载器去加载自定义的System类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 自定义一个类加载器</span>ClassLoader classLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 源代码需要先执行双亲委派的实现逻辑，这里去掉了，直接去加载类</span>        <span class="token keyword">return</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Class <span class="token class-name">c</span> <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"java.lang.System"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object obj <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最终运行结果如下</p><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>SecurityException<span class="token operator">:</span> Prohibited <span class="token keyword">package</span> name<span class="token operator">:</span> java<span class="token punctuation">.</span>lang    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">preDefineClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">659</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">758</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SecureClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>SecureClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">142</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">467</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span>access$<span class="token function">100</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">73</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">368</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">362</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>Native Method<span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLClassLoader<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>URLClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">361</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">424</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$AppClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>Launcher<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">331</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>ClassLoader<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">357</span><span class="token punctuation">)</span>    at sun<span class="token punctuation">.</span>launcher<span class="token punctuation">.</span>LauncherHelper<span class="token punctuation">.</span><span class="token function">checkAndLoadMain</span><span class="token punctuation">(</span>LauncherHelper<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">495</span><span class="token punctuation">)</span>Error<span class="token operator">:</span> A JNI error has occurred<span class="token punctuation">,</span> please check your installation and <span class="token keyword">try</span> againException in thread <span class="token string">"main"</span></code></pre><p>抛出一个安全异常：包名为禁用包名，进入preDefineClass()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> ProtectionDomain <span class="token function">preDefineClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>                                            ProtectionDomain pd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoClassDefFoundError</span><span class="token punctuation">(</span><span class="token string">"IllegalName: "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>name <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"java."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span>            <span class="token punctuation">(</span><span class="token string">"Prohibited package name: "</span> <span class="token operator">+</span>             name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pd <span class="token operator">=</span> defaultDomain<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token function">checkCerts</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> pd<span class="token punctuation">.</span><span class="token function">getCodeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pd<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可见在内部已经做了限制，不允许java开头的包名被defineClass方法构造，而且defineClass是final方法，也无法通过重写来绕过该判断。<br />所以最终答案是不能！</p><p><a name="a11e41c7"></a></p><h4 id="3-自定义类加载器"><a href="#3-自定义类加载器" class="headerlink" title="3. 自定义类加载器"></a>3. 自定义类加载器</h4><p>要手写一个类加载器，需要先了解ClassLoader的主要方法</p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>defineClass(String name, byte[] b, int off, int len)</strong></td><td>把字节数组 b中的内容转换成 Java 类，该字节数组可以看成是二进制流字节组成的文件，返回的结果是<code>java.lang.Class</code>类的实例。这个方法被声明为 final的。</td></tr><tr><td><strong>loadClass(String name)</strong></td><td>上文中已贴出源码，实现了双亲委派模型，调用<code>findClass()</code>执行类加载动作,返回的是<code>java.lang.Class</code>类的实例。</td></tr><tr><td><strong>findClass(String name)</strong></td><td>通过传入的类全限定名name来获取对应的类，返回的是<code>java.lang.Class</code>类的实例，该类没有提供具体的实现，开发者在自定义类加载器时需重用此方法，在实现此方法时需调用<code>defineClass(String name, byte[] b, int off, int len)</code>方法。</td></tr></tbody></table><p>由之前的概述可得知，自定义类加载器有2种方式</p><ul><li>采用双亲委派模型，重写<code>findClass(String name)</code>，不需重写<code>loadClass(String name)</code></li><li>破坏双亲委派模型，重写<code>loadClass(String name)</code>，因为它内部正好实现了双亲委派。</li></ul><p>这里建议不要采取破坏双亲委派模型的操作去自定义类加载器。</p><p>以下是采用双亲委派模型的自定义类加载器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilesClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String roodDir<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FilesClassLoader</span><span class="token punctuation">(</span>String roodDir<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>roodDir <span class="token operator">=</span> roodDir<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">FilesClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> classData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 找不到该类</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 生成并返回一个Class对象</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取该全限定名对应的类的文件路径</span><span class="token comment" spellcheck="true">//        String path = getClassNamePath(className);</span>        <span class="token comment" spellcheck="true">// 读取文件</span>        String filename <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">(</span>InputStream is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            InputStream is = new FileInputStream(path);</span>            ByteArrayOutputStream bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getClassNamePath</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 替换为不同操作系统的文件路径分割符</span>        className <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>roodDir<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>File<span class="token punctuation">.</span>separatorChar<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> InstantiationException <span class="token punctuation">{</span>        FilesClassLoader classLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilesClassLoader</span><span class="token punctuation">(</span><span class="token string">"D://"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">zclass</span> <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span><span class="token string">"my.jvm.FilesClassLoader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zclass<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zclass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// class my.jvm.FilesClassLoader</span>        <span class="token comment" spellcheck="true">// my.jvm.FilesClassLoader@677327b6</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a name="7efcb0ce"></a></p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>容器资源隔离。如Tomcat，为了优化空间和防止不同webapp之间的jar包冲突，每个webapp都有自己的webAppClassLoader，用于加载自身classpath上的类，当遇到Tomcat容器自带的jar包时，委托给CommonClassLoader加载<br /></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/243176/1582185864452-1fcc672e-0acb-421e-afe5-efbbab3c89e0.png#align=left&display=inline&height=355&name=jvm_9.png&originHeight=355&originWidth=449&size=30343&status=done&style=none&width=449" alt="jvm_9.png"></p><ol start="2"><li>代码保护。对于核心类，可能会把字节码加密，这时需要自定义Classloader，将字节码解密并加载。比如从网络输入流中读取类，先将其做解密操作，看是否符合相关的安全信息，再进行加载</li><li>特定位置获取类信息，如在自定义的路径、数据库、网络中获取。</li></ol><p><a name="99f1077c"></a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/243176/1582185871180-c755748c-d4fd-478d-883c-66d465109270.jpeg#align=left&display=inline&height=481&name=jvm_10.jpg&originHeight=481&originWidth=516&size=30525&status=done&style=none&width=516" alt="jvm_10.jpg"></p><p><a name="14834039"></a></p><h3 id="新生代收集器-Serial、ParNew、Parallel-Scavenge"><a href="#新生代收集器-Serial、ParNew、Parallel-Scavenge" class="headerlink" title="新生代收集器(Serial、ParNew、Parallel Scavenge)"></a>新生代收集器(Serial、ParNew、Parallel Scavenge)</h3><p><a name="6G2Yg"></a></p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>运行在Client模式下的默认新生代单线程收集器。<br />单线程意味着必须暂停其他所有工作线程（即Stop The World）、串行，<br />采用复制算法进行垃圾收集<br />收集器组合：Serial + CMS 、Serial + Serial Old<br />使用场景：Client模式（桌面应用）、单核服务器<br />使用方式：用-XX:+UseSerialGC 来选择Serial +Serial OId进行垃圾收集</p><p><a name="UNYAY"></a></p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial 多线程版本，其他一致。<br />收集器组合：ParNew + CMS 、ParNew + Serial Old<br />使用场景：多核服务器<br />使用方式：用-XX:+UseParNewGC 来选择ParNew +Serial OId进行垃圾收集<br />           用-XX:+UseConcMarkSweepGC 来选择ParNew+CMS+Serial Old进行垃圾收集</p><p><a name="RI5Iy"></a></p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>多线程收集器。<br />相较于以上的区别是尽可能缩短垃圾收集时用户线程停顿时间<br />目的是达到一个可控的吞吐量（CPU执行用户线程时间 / CPU执行总时间）<br />收集器组合：Parallel Scavenge + Serial Old、 Parallel Scavenge + Parallel Old<br />使用场景：注重吞吐量、高效利用CPU<br />使用方式：用-XX:+UseParallelGC 来选择Parallel Scavenge +Serial OId进行垃圾收集<br />           用-XX:+UseParallelOldGC 来选择 Parallel Scavenge + Parallel Old进行垃圾收集<br />相关参数：用-XX:+MaxGCPauseMillis 设置GC的最大停顿时间<br />           用-XX:+GCTimeRatio 设置GC时间占总时间的比率，默认值为99，即允许1%的GC时间<br />jdk1.7 1.8默认用它做新生代收集器</p><p><a name="fc3995ae"></a></p><h3 id="老年代收集器-Serial-Old、CMS、Parallel-Old"><a href="#老年代收集器-Serial-Old、CMS、Parallel-Old" class="headerlink" title="老年代收集器(Serial Old、CMS、Parallel Old)"></a>老年代收集器(Serial Old、CMS、Parallel Old)</h3><p><a name="9NibG"></a></p><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial 的老年代版本<br />采用标记-整理算法<br />收集器组合：Serial Old + Parallel Scavenge 、Serial Old + ParNew + CMS<br />使用场景：Client模式（桌面应用）、单核服务器、作为CMS收集器的后备方案</p><p><a name="hlJ9T"></a></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>以最短回收（用户线程）停顿时间为目标的收集器。<br />优点：并发收集、低停顿<br />缺点：</p><ul><li>对CPU资源敏感。随CPU数量下降，占用CPU资源越多，吞吐量越小。</li><li>无法处理浮动垃圾。可能会出现“Concurrent Mode Failure” 失败而导致另一次Full GC 的产生。在并发清理阶段，由于用户线程还在执行，伴随着有其他新的垃圾产生，导致因为出现在标记过后CMS无法在当次收集中处理掉他们。</li><li>内存碎片。在并发清除阶段采用了标记-清除算法，从而在收集结束后可能产生大量的内存碎片。可以使用-XX:+UseCMSCompactAtFullCollection 在CMS顶不住要进行Full GC时开启内存碎片的合并整理过程。由于内存碎片整理不是并行的，如果频繁操作的话会增加额外长的停顿时间。所以也可以使用-XX:+CMSFullGCsBeforeCompaction设置执行在进行若干次垃圾收集后再启动一次内存碎片整理</li></ul><p>过程分为4步骤：</p><ul><li>初识标记：标记GC Roots能直接到达的对象，速度较快（Stop The World）</li><li>并发标记：进行GC Roots Tracting，标记出所有垃圾对象，耗时较长</li><li>重新标记：修正并发标记 期间因用户程序继续运作而产生表达的那一部分对象的标记记录，初识标记&lt;耗时&lt;&lt;&lt;并发标记（Stop The World）</li><li>并发清除：用标记-清除算法清除垃圾对象，耗时较长（这里会产生内存碎片，可以用-XX:+UseCMSCompactAtFullCollection 或 -XX:+CMSFullGCsBeforeCompaction 进行内存碎片整理）</li></ul><p><a name="OGt9D"></a></p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p><a name="50f55aaf"></a></p><h3 id="堆内存收集器（G1）"><a href="#堆内存收集器（G1）" class="headerlink" title="堆内存收集器（G1）"></a>堆内存收集器（G1）</h3><p><a name="LY49m"></a></p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p><a name="4be0f743"></a></p><h2 id="JVM-配置常用参数"><a href="#JVM-配置常用参数" class="headerlink" title="JVM 配置常用参数"></a>JVM 配置常用参数</h2><p><a name="70bf997b"></a></p><h3 id="堆参数"><a href="#堆参数" class="headerlink" title="堆参数"></a>堆参数</h3><table><thead><tr><th align="left">参数</th><th>描述</th></tr></thead><tbody><tr><td align="left">-Xms</td><td>设置jvm启动时堆内存的初始化大小</td></tr><tr><td align="left">-Xmx</td><td>设置堆内存最大值</td></tr><tr><td align="left">-XX:PermSize</td><td>JVM初始分配的非堆内存</td></tr><tr><td align="left">-XX:MaxPermSize</td><td>JVM最大允许分配的非堆内存，按需分配</td></tr><tr><td align="left">-Xmn</td><td>设置新生代的空间大小，剩下的为老年代的空间大小</td></tr><tr><td align="left">-XX:PermGen</td><td>设置永久代内存的初始化大小（jdk1.8已废除永久代）</td></tr><tr><td align="left">-XX:MaxPermGen</td><td>设置永久代的最大值</td></tr><tr><td align="left">-XX:SurvivorRatio</td><td>设置Edem区和Survivor区的空间比例：Eden/S0 = Eden/S1，默认为8。即两个Survivor区与一个Eden区的比值为2:8</td></tr><tr><td align="left">-XX:NewRatio</td><td>设置新生代和老年代的比例大小，默认2。即新生代和老年代的比值为1:4</td></tr><tr><td align="left">-Xss</td><td>每个线程的堆栈大小</td></tr></tbody></table><p><a name="b7ccb2cc"></a></p><h3 id="垃圾收集器参数"><a href="#垃圾收集器参数" class="headerlink" title="垃圾收集器参数"></a>垃圾收集器参数</h3><blockquote><p>-XX:+ 启用选项<br>-XX:- 不启用选项</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器进行内存回收。串行，Young和old区都使用串行，使用复制算法回收，无线程切换开销</td></tr><tr><td>-XX:+UseParNewGC</td><td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器作为CMS收集器出现Coucurrent Mode Failure失败后的后备收集器使用。</td></tr><tr><td>-XX:+UseParallelGC</td><td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（由于Parallel Scavenge本身有PS MarkSweep收集器来对Old区进行回收，但是它和Serial Old的实现方式非常接近，故用其说明）的收集器组合进行内存回收。Young区：使用Parallel Scavenge回收算法，多线程并行回收。Old区：单线程</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td>-XX:+PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，设置后，大于这个参数的对象直接在老年代分配</td></tr><tr><td>-XX:+MaxTenuringThreshold</td><td>晋升到老年代的对象大小，设置后，大于这个参数的对象直接在老年代分配</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>-XX:+HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代剩余空间不足以应付新生代整个Eden区和Survivor区所有对象都存活的极端情况</td></tr><tr><td>-XX:+ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数</td></tr><tr><td>-XX:+GCTimeRatio</td><td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>-XX:+MaxGCPauseMillis</td><td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>-XX:+CMSInitiatingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td>-XX:+UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td>-XX:+CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><p>参考文章：</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">深入探讨 Java 类加载器</a></p><p><a href="https://crowhawk.github.io/2017/08/21/jvm_6/" target="_blank" rel="noopener">深入理解JVM(6)——类加载器</a></p><p><a href="https://zhuanlan.zhihu.com/p/41672523" target="_blank" rel="noopener">细说JVM（类加载器）</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
